通过解决下面的练习，可以练习本章讨论的内容。所有练习的解决方案都可以在本书的网站\url{www.wiley.com/go/proc++6e}下载到源码。然而，若在练习中卡住了，在从网站上寻找解决方案之前，可以考虑先重读本章的部分内容，试着自己找到答案。

\begin{itemize}
\item
Exercise 25-1: Write an algorithm called transform\_if(), similar to the Standard Library’s transform(), discussed in Chapter 20. The difference is that transform\_if() should accept an extra predicate and that it only transforms elements for which the predicate returns true. Other elements are left untouched. To test your algorithm, create an array of integers, and then use transform\_if() to copy the integers into a vector while multiplying all odd values by 2.

\item
Exercise 25-2: Write an algorithm called generate\_fibonacci(), which fills a given range with a Fibonacci series of numbers.[The ratio of two successive Fibonacci numbers converges to the golden ratio, 1.618034 ... The Fibonacci numbers and the golden ratio often occur in nature, such as branching in trees, flowering of artichokes, flower petals, shells, and many more. The golden ratio is artistically attractive for humans, and hence is often used by architects to design rooms, for the arrangements of plants in gardens, and more.] The Fibonacci series starts with 0 and 1, and any subsequent value is the sum of the two previous values, so: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, and so on. Your implementation is not allowed to contain any manually written loops or be implemented using a recursive algorithm. Instead, you should use the Standard Library’s generate() algorithm to do most of the work.

\item
Exercise 25-3: Implement a find(const T\&) member function for the directed\_graph class template.

\item
Exercise 25-4: All associative containers have a contains() member function that returns true if a given element is in the container and false otherwise. As this could be useful for a directed\_graph as well, add an implementation of contains() to directed\_graph.
\end{itemize}












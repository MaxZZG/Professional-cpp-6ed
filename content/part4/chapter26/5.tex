
Normal templates can take only a fixed number of template parameters. Variadic templates can take a variable number of template parameters. For example, the following code defines a template that can accept any number of template parameters, using a parameter pack called Types:

\begin{cpp}
template <typename... Types>
class MyVariadicTemplate { };
\end{cpp}

\begin{myNotic}{NOTE}
The three dots following typename are not an error. This is the syntax to define a parameter pack for variadic templates. A parameter pack is something that can accept a variable number of arguments.
\end{myNotic}

You can instantiate MyVariadicTemplate with any number of template arguments, as in this example:

\begin{cpp}
MyVariadicTemplate<int> instance1;
MyVariadicTemplate<string, double, vector<int>> instance2;
\end{cpp}

It can even be instantiated with zero template arguments:

\begin{cpp}
MyVariadicTemplate<> instance3;
\end{cpp}

To disallow instantiating a variadic template with zero template arguments, you can write the template as follows:

\begin{cpp}
template <typename T1, typename... Types>
class MyVariadicTemplate { };
\end{cpp}

With this definition, trying to instantiate MyVariadicTemplate with zero template arguments results in a compilation error.

It is not possible to directly iterate over the arguments given to a variadic template. The only way you can do this is with the aid of template recursion or fold expressions. The following sections show examples of both.


\mySubsubsection{26.5.1.}{Type-Safe Variable-Length Argument Lists}

Variadic templates allow you to create type-safe variable-length argument lists. The following example defines a variadic template called processValues(), allowing it to accept a variable number of arguments with different types in a type-safe manner. The processValues() function processes each value in the variable-length argument list and executes a function called handleValue() for each single argument. This means you have to write an overload of handleValue() for each type that you want to handle—int, double, and string in this example:

\begin{cpp}
void handleValue(int value) { println("Integer: {}", value); }
void handleValue(double value) { println("Double: {}", value); }
void handleValue(const string& value) { println("String: {}", value); }

void processValues() // Base case to stop recursion
{ /* Nothing to do in this base case. */ }

template <typename T1, typename... Tn>
void processValues(const T1& arg1, const Tn&... args)
{
    handleValue(arg1);
    processValues(args...);
}
\end{cpp}

This example demonstrates a double use of the triple dots (...) operator. This operator appears in three places and has two different meanings. First, it is used after typename in the template parameter list and after type Tn in the function parameter list. In both cases, it denotes a parameter pack.
A parameter pack can accept a variable number of arguments.

The second use of the ... operator is following the parameter name args in the function body. In this case, it means a parameter pack expansion; the operator unpacks/expands the parameter pack into separate arguments. It basically takes what is on the left side of the operator and repeats it for every template parameter in the pack, separated by commas. Take the following statement:

\begin{cpp}
processValues(args...);
\end{cpp}

This statement expands the args parameter pack into its separate arguments, separated by commas, and then calls the processValues() function with the list of expanded arguments. The template always requires at least one parameter, T1. The act of recursively calling processValues() with args... is that on each call there is one parameter less.

Because the implementation of the processValues() function is recursive, you need to have a way to stop the recursion. This is done by implementing a processValues() function that accepts no arguments.

You can test the processValues() variadic template as follows:

\begin{cpp}
processValues(1, 2, 3.56, "test", 1.1f);
\end{cpp}

The recursive calls generated by this example are as follows:

\begin{cpp}
processValues(1, 2, 3.56, "test", 1.1f);
    handleValue(1);
        processValues(2, 3.56, "test", 1.1f);
        handleValue(2);
        processValues(3.56, "test", 1.1f);
            handleValue(3.56);
            processValues("test", 1.1f);
                handleValue("test");
                processValues(1.1f);
                    handleValue(1.1f);
                    processValues();
\end{cpp}

It is important to remember that this implementation of variable-length argument lists is fully typesafe. The processValues() function automatically calls the correct handleValue() overload based on the actual type. The compiler will issue an error when you call processValues() with an argument of a certain type for which there is no handleValue() overload defined.

You can also use forwarding references, introduced in Chapter 12, in the implementation of processValues(). The following implementation uses forwarding references, T\&\&, and uses std::forward() for perfect forwarding of all parameters. Perfect forwarding means that if an rvalue is passed to processValues(), it is forwarded as an rvalue reference. If an lvalue is passed, it is forwarded as an lvalue reference.

\begin{cpp}
void processValues() // Base case to stop recursion
{ /* Nothing to do in this base case.*/ }

template <typename T1, typename... Tn>
void processValues(T1&& arg1, Tn&&... args)
{
    handleValue(forward<T1>(arg1));
    processValues(forward<Tn>(args)...);
}
\end{cpp}

There is one statement that needs further explanation:

\begin{cpp}
processValues(forward<Tn>(args)...);
\end{cpp}

The ... operator is used to unpack the parameter pack. It uses std::forward() on each individual argument in the pack and separates them with commas. For example, suppose args is a parameter pack with three arguments, a1, a2, and a3, of three types, A1, A2, and A3. The expanded call then looks as follows:

\begin{cpp}
processValues(forward<A1>(a1),
              forward<A2>(a2),
              forward<A3>(a3));
\end{cpp}

Inside the body of a function using a parameter pack, you can retrieve the number of arguments in the pack using sizeof...(pack). Notice that this is not doing a pack expansion with ..., but is using the special keyword-like syntax sizeof...

\begin{cpp}
int numberOfArguments { sizeof...(args) };
\end{cpp}

A practical example of using variadic templates is to write a secure and type-safe printf()-like function template. This would be a good practice exercise for you to try.

\mySamllsection{constexpr if}

constexpr if statements are if statements executed at compile time, not at run time. If a branch of a constexpr if statement is never taken, it is never compiled. Such compile-time decisions can come in handy with variadic templates. For example, the earlier implementation of processValues() requires a base case to stop the recursion (void processValues()\{\}). Using constexpr if, such a base case can be avoided. Notice that the feature is officially called constexpr if, but in actual code you write if constexpr.

\begin{cpp}
template <typename T1, typename... Tn>
void processValues(T1&& arg1, Tn&&... args)
{
    handleValue(forward<T1>(arg1));
    if constexpr (sizeof...(args) > 0) {
        processValues(forward<Tn>(args)...);
    }
}
\end{cpp}

In this implementation, the recursion stops as soon as the variadic parameter pack, args, becomes empty. The only difference with the previous implementations is that you can no longer call processValues() without any arguments. Doing so results in a compilation error.

\mySubsubsection{26.5.2.}{Variable Number of Mixin Classes}

Parameter packs can be used almost everywhere. For example, the following code uses a parameter pack to define a variable number of mixin classes for MyClass. Chapter 5, “Designing with Classes,” discusses the concept of mixin classes.

\begin{cpp}
class Mixin1
{
    public:
        explicit Mixin1(int i) : m_value { i } {}
        virtual void mixin1Func() { println("Mixin1: {}", m_value); }
    private:
        int m_value;
};

class Mixin2
{
    public:
        explicit Mixin2(int i) : m_value { i } {}
        virtual void mixin2Func() { println("Mixin2: {}", m_value); }
    private:
        int m_value;
};

template <typename... Mixins>
class MyClass : public Mixins...
{
    public:
        explicit MyClass(const Mixins&... mixins) : Mixins { mixins }... {}
        virtual ˜MyClass() = default;
};
\end{cpp}

This code first defines two mixin classes: Mixin1 and Mixin2. They are kept pretty simple for this example. Their constructor accepts an integer, which is stored, and they have a function to print information about a specific instance of the class. The MyClass variadic template uses a parameter pack typename... Mixins to accept a variable number of mixin classes. The class then inherits from all those mixin classes, and the constructor accepts the same number of arguments to initialize each inherited mixin class. Remember that the ... expansion operator basically takes what is on the left of the operator and repeats it for every template parameter in the pack, separated by commas. The class can be used as follows:

\begin{cpp}
MyClass<Mixin1, Mixin2> a { Mixin1 { 11 }, Mixin2 { 22 } };
a.mixin1Func();
a.mixin2Func();

MyClass<Mixin1> b { Mixin1 { 33 } };
b.mixin1Func();
//b.mixin2Func(); // Error: does not compile.

MyClass<> c;
//c.mixin1Func(); // Error: does not compile.
//c.mixin2Func(); // Error: does not compile.
\end{cpp}

When you try to call mixin2Func() on b, you will get a compilation error because b is not inheriting from the Mixin2 class. The output of this program is as follows:

\begin{shell}
Mixin1: 11
Mixin2: 22
Mixin1: 33
\end{shell}

\mySubsubsection{26.5.3.}{Fold Expressions}

C++ supports fold expressions. This makes working with parameter packs in variadic templates much easier. Fold expressions can be used to apply a certain operation to every value of a parameter pack, to reduce all values in a parameter pack to a single value, and more.

The following table lists the four types of folds that are supported. In this table, Ѳ can be any of the following operators: +, -, *, /, \%, \^{}, \&, |, <{}<, >{}>, +=, -=, *=, /=, \%=, \^{}=, \&=, |=, <{}<=, >{}>=, =, ==, !=, <, >, <=, >=, \&\&, ||, .*,d ->*.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME}             & \textbf{EXPRESSION} & \textbf{IS EXPANDED TO}             \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Unary right fold} & (pack Ѳ . . .)      & $pack_0$ Ѳ (. . . Ѳ ($pack_{n-1}$ Ѳ $pack_n$)) \\ \hline
\textbf{Unary left fold}  & (. . . Ѳ pack)      & (($pack_0$ Ѳ $pack_1$) Ѳ . . .) Ѳ $pack_n$   \\ \hline
\textbf{Binary right fold} & (pack Ѳ . . . Ѳ Init) & $pack_0$ Ѳ (. . . Ѳ ($pack_{n-1}$ Ѳ ($pack_n$ Ѳ Init))) \\ \hline
\textbf{Binary left fold}  & (Init Ѳ . . . Ѳ pack) & (((Init Ѳ $pack_0$) Ѳ $pack_1$) Ѳ . . .) Ѳ $pack_n$   \\ \hline
\end{longtable}

Let’s look at some examples. Earlier, the processValue() function template was defined recursively as follows:

\begin{cpp}
void processValues() { /* Nothing to do in this base case.*/ }

template <typename T1, typename... Tn>
void processValues(T1&& arg1, Tn&&... args)
{
    handleValue(forward<T1>(arg1));
    processValues(forward<Tn>(args)...);
}
\end{cpp}

Because it is defined recursively, it needs a base case to stop the recursion. With fold expressions, this can be implemented with a single function template using a unary right fold over the comma operator:

\begin{cpp}
template <typename... Tn>
void processValues(Tn&&... args) { (handleValue(forward<Tn>(args)) , ...); }
\end{cpp}

Basically, the three dots in the function body trigger folding with the comma operator for Ѳ. That line is expanded to call handleValue() for each argument in the parameter pack, and each call to handleValue() is separated by a comma. For example, suppose args is a parameter pack with three arguments, a1, a2, and a3, of three types, A1, A2, and A3. The expansion of the unary right fold then becomes as follows:

\begin{cpp}
(handleValue(forward<A1>(a1)) ,
    (handleValue(forward<A2>(a2)) , handleValue(forward<A3>(a3))));
\end{cpp}

Here is another example. The printValues() function template writes all its arguments to the console, separated by newlines.

\begin{cpp}
template <typename... Values>
void printValues(const Values&... values) { (println("{}", values) , ...); }
\end{cpp}

Suppose that values is a parameter pack with three arguments, v1, v2, and v3. The expansion of the unary right fold then becomes as follows:

\begin{cpp}
(println("{}", v1) , (println("{}", v2) , println("{}", v3)));
\end{cpp}

You can call printValues() with as many arguments as you want, for example:

\begin{cpp}
printValues(1, "test", 2.34);
\end{cpp}

In the examples up to now, the folding is done with the comma operator, but it can be used with almost any kind of operator. For example, the following code defines a variadic function template using a binary left fold to calculate the sum of all the values given to it. A binary left fold always requires an Init value (see the overview table earlier). Hence, sumValues() has two template type parameters: a normal one to specify the type of Init, and a parameter pack that can accept 0 or more arguments.

\begin{cpp}
template <typename T, typename... Values>
auto sumValues(const T& init, const Values&... values)
{ return (init + ... + values);}
\end{cpp}

Suppose that values is a parameter pack with three arguments, v1, v2, and v3. Here is the expansion of the binary left fold in that case:

\begin{cpp}
return (((init + v1) + v2) + v3);
\end{cpp}

The sumValues() function template can be tested as follows:

\begin{cpp}
println("{}", sumValues(1, 2, 3.3));
println("{}", sumValues(1));
\end{cpp}

The sumValues() function template can also be defined in terms of a unary left fold as follows.

\begin{cpp}
template <typename... Values>
auto sumValues(const Values&... values) { return (... + values); }
\end{cpp}

Concepts, discussed in Chapter 12, can also be variadic. For example, the sumValues() function template can be constrained so that it can be called only with a set of arguments of the same type:

\begin{cpp}
template <typename T, typename... Us>
concept SameTypes = (std::same_as<T, Us> && ...);

template <typename T, typename... Values>
    requires SameTypes<T, Values...>
auto sumValues(const T& init, const Values&... values)
{ return (init + ... + values); }
\end{cpp}

Calling this constrained version as follows works fine:

\begin{cpp}
println("{}", sumValues(1.1, 2.2, 3.3)); // OK: 3 doubles, output is 6.6
println("{}", sumValues(1)); // OK: 1 integer, output is 1
println("{}", sumValues("a"s, "b"s)); // OK: 2 strings, output is ab
\end{cpp}

However, the following call fails as the argument list contains an integer and two doubles:

\begin{cpp}
println("{}", sumValues(1, 2.2, 3.3)); // Error
\end{cpp}

Parameter packs with zero length are allowed for unary folds, but only in combination with the logical AND (\&\&), logical OR (||), and comma (,) operators. For an empty parameter pack, applying \&\& to it results in true, applying || results in false, and applying , results in void(), i.e., a no-op. For example:

\begin{cpp}
template <typename... Values>
bool allEven(const Values&... values) { return ((values % 2 == 0) && ...); }

template <typename... Values>
bool anyEven(const Values&... values) { return ((values % 2 == 0) || ...); }

int main()
{
    println("{} {} {}", allEven(2,4,6), allEven(2,3), allEven());//true false true
    println("{} {} {}", anyEven(1,2,3), anyEven(1,3), anyEven());//true false false
}
\end{cpp}

















通过解决下面的练习，可以练习本章讨论的内容。所有练习的解决方案都可以在本书的网站\url{www.wiley.com/go/proc++6e}下载到源码。若在练习中卡住了，可以考虑先重读本章的部分内容，试着自己找到答案，再在从网站上寻找解决方案。

\begin{itemize}
\item
\textbf{练习 26-1}: 在 练习 12-2 中，为 KeyValuePair 类模板写了一个全特化，用于处理 const char* 类型的键和值。用一个偏特化替换这个全特化，其中值类型为 const char*，但键可以是任何类型。

\item
\textbf{练习 26-2}: 使用模板递归来在编译时计算斐波那契数列的第 n 个数字。斐波那契数列以 0 和 1 开始，后续的值都是前两个值的和，所以数列为：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 等。

能提供一个变量模板，使递归斐波那契模板更容易使用吗？

\item
\textbf{练习 26-3}: 基于 练习 26-2 中的解决方案，并修改它，使其在编译时计算仍然发生，但不使用模板或函数递归。

\item
\textbf{练习 26-4}: 编写一个变长函数模板 push\_back\_values()，它接受一个vector的引用和一个可变数量的值。该函数应使用折叠表达式将所有值推入给定的vector。然后，编写一个 insert\_values() 函数模板，完成相同的事情，但使用 vector::insert(initializer\_list<value\_type>)。这与 push\_back\_values() 的实现有什么区别？

\item
\textbf{练习 26-5}: 编写一个名为 multiply() 的非缩写函数模板，接受两个模板类型参数 T1 和 T2。使用类型特性来验证这两个类型是否为算术类型。如果是，执行乘法并返回结果；如果不是，抛出一个包含两个类型名称的异常。

\item
\textbf{练习 26-6}: (进阶) 基于 练习 26-5 中的解决方案转换为使用简化的函数模板。
\end{itemize}






















As discussed earlier in this chapter, using std::thread to launch a thread that calculates a single result does not make it easy to get the computed result back once the thread has finished executing. Another problem with std::thread is in how it handles errors like exceptions. If a thread throws an exception and this exception is not caught by the thread itself, the C++ runtime calls std::terminate(), which usually terminates the entire application.

A future can be used to more easily get the result out of a thread and to transport exceptions from one thread to another thread, which can then handle the exception however it wants.

A promise is something in which a thread stores its result. A future is used to get access to the result stored in a promise. That is, a promise is the input side for a result, a future is the output side. Once a function, running in the same thread or in another thread, has calculated the value that it wants to return, it puts this value in a promise. This value can then be retrieved through a future. A promise/ future pair is an inter-thread one-shot communication channel for a result.

C++ provides a standard future, called std::future. You can retrieve the result from an std::future as follows. T is the type of the calculated result.

\begin{cpp}
future<T> myFuture { ... }; // Is discussed later.
T result { myFuture.get() };
\end{cpp}

The call to get() retrieves the result and stores it in the variable result. If calculating the result is not finished yet, the call to get() blocks until the value becomes available. You can call get() only once on a future. The behavior of calling it a second time is undefined by the standard.

If you want to avoid blocking, you can first ask the future if there is a result available:

\begin{cpp}
if (myFuture.wait_for(0)) { // Value is available.
    T result { myFuture.get() };
} else { // Value is not yet available.
    ...
}
\end{cpp}

\mySubsubsection{27.9.1.}{std::promise and std::future}

C++ provides the std::promise class as one way to implement the concept of a promise. You can call set\_value() on a promise to store a result, or you can call set\_exception() on it to store an exception in the promise. You can call set\_value() or set\_exception() only once on a specific promise. If you call it multiple times, an std::future\_error exception will be thrown.

Alternatively, you can use set\_value\_at\_thread\_exit() or set\_exception\_at\_thread\_exit() to set a value or an exception in a promise. Using these, the value or the exception is stored in the promise at the time the thread exits and after all thread-local storage variables have been destroyed.

A thread A that launches another thread B to calculate something can create a promise and pass it to the launched thread. A promise cannot be copied, but it can be moved into a thread! Thread B uses that promise to store the result. Before moving the promise into thread B, thread A calls get\_future() on the created promise to be able to get access to the result once B has finished. Here is a simple example:

\begin{cpp}
void doWork(promise<int> thePromise)
{
    // ... Do some work ...
    // And ultimately store the result in the promise.
    thePromise.set_value(42);
}

int main()
{
    // Create a promise to pass to the thread.
    promise<int> myPromise;
    // Get the future of the promise.
    auto theFuture { myPromise.get_future() };
    // Create a thread and move the promise into it.
    jthread theThread { doWork, move(myPromise) };

    // Do some more work...

    // Get the result.
    int result { theFuture.get() };
    println("Result: {}", result);
}
\end{cpp}

\begin{myNotic}{NOTE}
This code is just for demonstration purposes. It starts the calculation in a new thread and then calls get() on the future, which blocks until the result is calculated. This sounds like an expensive function call. In real-world applications, you can use futures by periodically checking if there is a result available or not (using wait\_for() as discussed earlier) or by using a synchronization mechanism such as a condition variable. When the result is not yet available, you can do something else in the meantime, instead of blocking.
\end{myNotic}

\mySubsubsection{27.9.2.}{std::packaged\_task}

A std::packaged\_task makes it easier to work with promises than explicitly using std::promise, as in the previous section. The following code demonstrates this. It creates a packaged\_task to execute calculateSum(). The future is retrieved from the packaged\_task by calling get\_future(). A thread is launched, and the packaged\_task is moved into it. A packaged\_task, like a std::promise, is move-only. After the thread is launched, get() is called on the retrieved future to get the result. This blocks until the result is available.

calculateSum() does not store anything explicitly in any kind of promise. A packaged\_task automatically creates a promise, and automatically stores the result of the callable—calculateSum() in this case—in the promise, no matter whether that result is a value or a thrown exception.

\begin{cpp}
int calculateSum(int a, int b) { return a + b; }

int main()
{
    // Create a packaged task to run calculateSum.
    packaged_task task { calculateSum };
    // Get the future for the result of the packaged task.
    auto theFuture { task.get_future() };
    // Create a thread, move the packaged task into it, and
    // execute the packaged task with the given arguments.
    jthread theThread { move(task), 39, 3 };

    // Do some more work...

    // Get the result.
    int result { theFuture.get() };
    println("Result: {}", result);
}
\end{cpp}

\mySubsubsection{27.9.3.}{std::async}

If you want to give the C++ runtime more control over whether or not a thread is created to calculate something, you can use std::async(). It accepts a callable to be executed and returns a future that you can use to retrieve the result. There are two ways in which async() can run a callable:

\begin{itemize}
\item
By running it on a separate thread asynchronously

\item
By running it on the calling thread synchronously at the time you call get() on the returned future
\end{itemize}

If you call async() without additional arguments, the runtime automatically chooses one of the two mechanisms depending on factors such as the number of CPU cores in your system and the amount of concurrency already taking place. You can influence the runtime’s behavior by specifying a policy argument:

\begin{itemize}
\item
launch::async: Forces the runtime to execute the callable asynchronously on a different thread.

\item
launch::deferred: Forces the runtime to execute the callable synchronously on the calling thread when get() is called.

\item
launch::async | launch::deferred: Lets the runtime choose (= default behavior).
\end{itemize}

The following example demonstrates the use of async():

\begin{cpp}
int calculateSum(int a, int b) { return a + b; }

int main()
{
    auto myFuture { async(calculateSum, 39, 3) };
    //auto myFuture { async(launch::async, calculateSum, 39, 3) };
    //auto myFuture { async(launch::deferred, calculateSum, 39, 3) };

    // Do some more work...

    // Get the result.
    int result { myFuture.get() };
    println("Result: {}", result);
}
\end{cpp}

As you can see from this code snippet, std::async() is one of the easiest techniques to perform some calculations either asynchronously (on a different thread) or synchronously (on the same thread) and retrieve the result afterward.

\begin{myWarning}{WARNING}
A future returned by a call to async() blocks in its destructor until the result is available. (This is not true of ordinary futures; only the kind returned from async().) This means that if you call async() without capturing the returned future, the async() call effectively becomes a blocking call! For example, the following line synchronously calls calculateSum():

\begin{cpp}
async(calculateSum, 39, 3);
\end{cpp}

What happens with this statement is that async() creates and returns a future. This future is not captured, so it is a temporary. Because it is a temporary future, its destructor is called at the end of this statement, and this destructor blocks until the result is available.
\end{myWarning}

\mySubsubsection{27.9.4.}{Exception Handling}

A big advantage of using futures is that they can transport exceptions between threads. Calling get() on a future either returns the calculated result or rethrows any exception that has been stored in the promise linked to the future. When you use packaged\_task or async(), any exception thrown from the launched callable is automatically stored in the promise. If you use std::promise directly as your promise, you can call set\_exception() to store an exception in it. Here is an example using async():

\begin{cpp}
int calculate()
{
    throw runtime_error { "Exception thrown from calculate()." };
}

int main()
{
    // Use the launch::async policy to force asynchronous execution.
    auto myFuture { async(launch::async, calculate) };

    // Do some more work...

    // Get the result.
    try {
        int result { myFuture.get() };
        println("Result: {}", result);
    } catch (const exception& ex) {
        println("Caught exception: {}", ex.what());
    }
}
\end{cpp}

\mySubsubsection{27.9.5.}{std::shared\_future}

std::future<T> only requires T to be move-constructible. When you call get() on a future<T>, the result is moved out of the future and returned to you. This means you can call get() only once on a future<T>.

If you want to be able to call get() multiple times, even from multiple threads, then you need to use an std::shared\_future<T>. A shared\_future can be created by using std::future::share() or by passing a future to the shared\_future constructor. A future is not copyable, so you have to move it into the shared\_future constructor.

shared\_future can be used to wake up multiple threads at once. For example, the following piece of code defines two lambda expressions to be executed asynchronously on different threads. The first thing each lambda expression does is set a value to their respective promise to signal that they have started. Then they both call get() on signalFuture, which blocks until a parameter is made available through the future, after which they continue their execution. Each lambda expression captures their respective promise by reference and captures signalFuture by value, so both lambda expressions have a copy of signalFuture. The main thread uses async() to execute both lambda expressions asynchronously on different threads, waits until both threads have started, and then sets the parameter in the signalPromise, which wakes up both threads.

\begin{cpp}
promise<void> thread1Started, thread2Started;

promise<int> signalPromise;
auto signalFuture { signalPromise.get_future().share() };
//shared_future<int> signalFuture { signalPromise.get_future() };

auto function1 { [&thread1Started, signalFuture] {
        thread1Started.set_value();
        // Wait until parameter is set.
        int parameter { signalFuture.get() };
        // ...
} };

auto function2 { [&thread2Started, signalFuture] {
        thread2Started.set_value();
        // Wait until parameter is set.
        int parameter { signalFuture.get() };
        // ...
} };

// Run both lambda expressions asynchronously.
// Remember to capture the future returned by async()!
auto result1 { async(launch::async, function1) };
auto result2 { async(launch::async, function2) };

// Wait until both threads have started.
thread1Started.get_future().wait();
thread2Started.get_future().wait();

// Both threads are now waiting for the parameter.
// Set the parameter to wake up both of them.
signalPromise.set_value(42);
\end{cpp}













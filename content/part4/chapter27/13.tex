本节列出了一些与多线程编程相关的最佳实践。

\begin{itemize}
\item
使用并行标准库算法：标准库包含大量算法。其中超过60个算法支持并行执行。尽可能使用这些并行算法，而不是自己编写多线程代码。有关如何为算法指定并行化选项的详细信息，请参见第20章。

\item
优先使用jthread，而非thread：由于jthread在其析构函数中会自动汇入，因此比thread更难出错。

\item
关闭应用程序之前，确保所有线程对象都不可汇入：如果使用thread，请确保对所有线程对象都调用了join()或detach()。如果线程对象仍然可汇入，其析构函数会调用std::terminate()，这会突然终止所有线程和应用程序本身。如果将线程分离，会继续运行。如果它仍然访问非简单类型的全局变量，这些访问可能会与进程关闭时的全局变量销毁竞争，导致程序在退出时崩溃，这类错误很难调试。

\item
最好的同步是无同步：如果能设计线程以这种方式工作，即所有线程都在共享数据上只读取而不写入，或者只写入其他线程从不读取的部分，则多线程编程就会变得更容易。这种情况下，不需要同步，也不会遇到数据竞争或死锁等问题。

\item
尽量使用单线程所有权模式：数据块任何时刻只由一个线程拥有，拥有数据意味着其他线程不允许读取或写入数据。当线程完成使用数据时，可以将数据传递给另一个线程，该线程现在对数据有唯一的完全责任/所有权，在这种情况下不需要同步。

\item
可能的情况下使用原子类型和操作：原子类型和原子操作使得编写无数据竞争和无死锁的代码变得更加容易，它们会自动处理同步。如果多线程设计中无法使用原子类型和操作，并且需要共享数据，需要使用一些同步机制，例如互斥锁。

\item
使用锁来保护可变共享数据：如果需要多个线程可以写入的可变共享数据，并且无法使用原子类型和操作，必须使用锁定机制来确保不同线程之间的读写同步。

\item
尽快释放锁：当需要用锁保护共享数据时，请尽快释放锁。当线程持有锁时，会阻止其他等待相同锁的线程，这很可能会影响性能。

\item
使用RAII锁对象：使用lock\_guard、unique\_lock、shared\_lock或scoped\_lock RAII类在正确的时间自动释放锁。

\item
不要手动获取多个锁，使用std::lock()、try\_lock()或scoped\_lock：如果多个线程需要获取多个锁，必须在所有线程中以相同的顺序获取，避免死锁。应该使用通用的std::lock()、try\_lock()或scoped\_lock类来获取多个锁。

\item
使用支持多线程的性能分析器：这有助于发现多线程应用程序中的性能瓶颈，并确定多个线程是否确实利用了系统中的所有可用处理能力。一个支持多线程的性能分析器的例子是Microsoft Visual Studio中的分析器。

\item
了解调试器对多线程支持的功能：大多数调试器至少具有调试多线程应用程序的基本支持。应该能够获得应用程序中所有正在运行的线程的列表，并且能够切换到这些线程中的任何一个来检查其调用栈。可以使用这个功能来检查死锁，可以确切地看到每个线程正在做什么。

\item
使用线程池而不是动态创建和销毁大量线程：如果动态创建和销毁大量线程，程序性能会降低。这种情况下，最好使用线程池来重用现有线程。

\item
使用更高级的多线程库：C++标准目前只提供了编写多线程代码的基本构建块。正确使用这些内容并不简单。可能的情况下，使用更高层次的多线程库，如Intel Threading Building Blocks (TBB)、Microsoft Parallel Patterns Library (PPL)等，而不是重新发明轮子。多线程编程容易出错。很多时候，自己轮子可能没有想象的那么圆。
\end{itemize}










































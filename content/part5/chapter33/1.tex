
The strategy design pattern is one way to support the dependency inversion principle (DIP); see Chapter 6, “Designing for Reuse.” With this pattern, interfaces are used to invert dependency relationships. Interfaces are created for every provided service. If a component needs a set of services, interfaces to those services are injected into the component, a mechanism called dependency injection. Using the strategy pattern makes unit testing easier, as you can easily mock services away. As an example, this section discusses a logging mechanism implemented with the strategy pattern.

\mySubsubsection{33.1.1.}{Example: A Logging Mechanism}

The strategy-based logger example uses an interface, or abstract base class, called ILogger. Any code that wants to log something uses this ILogger interface. Subsequently, a concrete implementation of this interface is then injected into any code that needs to be able to use the logging functionality. With this pattern, a unit test can, for example, inject a special mock implementation for the ILogger interface to verify that the right information gets logged. A huge advantage of this pattern is that concrete loggers can easily be swapped without having to modify any library code; client code simply passes in the logger it wants to use.

\mySubsubsection{33.1.2.}{Implementation of a Strategy-Based Logger}

This implementation provides a Logger class with the following features:

\begin{itemize}
\item
It can log single strings.

\item
Each log message is prefixed with the current system time and an associated log level.

\item
The logger can be set up to only log messages above a certain log level.

\item
Every logged message is flushed to disk so that it will appear in the file immediately.
\end{itemize}

Let’s first define the ILogger interface:

\begin{cpp}
export class ILogger
{
    public:
        virtual ˜ILogger() = default; // Virtual destructor.

        // Enumeration for the different log levels.
        enum class LogLevel { Debug, Info, Error };

        // Sets the log level.
        virtual void setLogLevel(LogLevel level) = 0;

        // Logs a single message at the given log level.
        virtual void log(std::string_view message, LogLevel logLevel) = 0;
};
\end{cpp}

Next, a concrete Logger class is implemented as follows:

\begin{cpp}
export class Logger : public ILogger
{
    public:
        explicit Logger(const std::string& logFilename);
        void setLogLevel(LogLevel level) override;
        void log(std::string_view message, LogLevel logLevel) override;
    private:
        // Converts a log level to a human readable string.
        std::string_view getLogLevelString(LogLevel level) const;

        std::ofstream m_outputStream;
        LogLevel m_logLevel { LogLevel::Error };
};
\end{cpp}

The implementation of the Logger class is straightforward. Once the log file has been opened, each log message is written to it with the log level prepended and then flushed to disk.

\begin{cpp}
Logger::Logger(const string& logFilename)
{
    m_outputStream.open(logFilename, ios_base::app);
    if (!m_outputStream.good()) {
        throw runtime_error { "Unable to initialize the Logger!" };
    }
    println(m_outputStream, "{}: Logger started.", chrono::system_clock::now());
}

void Logger::setLogLevel(LogLevel level)
{
    m_logLevel = level;
}

string_view Logger::getLogLevelString(LogLevel level) const
{
    switch (level) {
        case LogLevel::Debug: return "DEBUG";
        case LogLevel::Info: return "INFO";
        case LogLevel::Error: return "ERROR";
    }
    throw runtime_error { "Invalid log level." };
}

void Logger::log(string_view message, LogLevel logLevel)
{
    if (m_logLevel > logLevel) { return; }
    println(m_outputStream, "{}: [{}] {}", chrono::system_clock::now(),
        getLogLevelString(logLevel), message);
}
\end{cpp}

\mySubsubsection{33.1.3.}{Using the Strategy-Based Logger}

Suppose you have a class called Foo that wants to use the logging functionality. With the strategy pattern, a concrete ILogger instance is injected into the class, for example through the constructor:

\begin{cpp}
class Foo
{
    public:
        explicit Foo(ILogger* logger) : m_logger { logger }
        {
            if (m_logger == nullptr) {
                throw invalid_argument { "ILogger cannot be null." };
            }
        }
        void doSomething()
        {
            m_logger->log("Hello strategy!", ILogger::LogLevel::Info);
        }
    private:
        ILogger* m_logger;
};
\end{cpp}

When a Foo instance is created, a concrete ILogger is injected into it:

\begin{cpp}
Logger concreteLogger { "log.out" };
concreteLogger.setLogLevel(ILogger::LogLevel::Debug);

Foo f { &concreteLogger };
f.doSomething();
\end{cpp}































通过解决下面的练习，可以练习本章讨论的内容。所有练习的解决方案都可以在本书的网站\url{www.wiley.com/go/proc++6e}下载到源码。然而，若在练习中卡住了，在从网站上寻找解决方案之前，可以考虑先重读本章的部分内容，试着自己找到答案。

\begin{itemize}
\item
\textbf{练习 20-1}：使用标准手册查找 ranges::fill() 算法的参数。然后向用户要一个数字，并使用 fill() 算法填充一个包含 10 个整数的vector。将vector的内容写入标准输出以供验证，并再提供一个使用 std::fill() 算法的解决方案。

\item
\textbf{练习 20-2}：回顾第 16 章的部分，然后使用标准库手册查找它们的参数。编写一个程序，要求用户输入几个数字，然后使用其中一个排列算法打印出这些数字的所有可能排列。提供两个解决方案，一个只使用约束算法，另一个使用无约束算法。

\item
\textbf{练习 20-3}：编写一个名为 trim() 的函数，该函数从给定的字符串中移除所有前导和尾随空白字符，并返回结果。只使用约束算法。提示：要检查字符 c 是否是空白字符，可以使用 std::isspace(c)(定义在 <cctype> 中)。如果 c 是空白字符，将返回非零值，否则返回 0。在 main() 函数中使用几个字符串测试一下你的实现。

\item
\textbf{练习 20-4}：使用约束算法创建一个包含数字 1 到 20 的vector。然后，使用单个约束算法，将所有偶数和奇数复制到 evens 和 odds 容器中，而不在这些容器上进行任何空间预留，并确保偶数按升序排列，奇数按降序排列。仔细选择 evens 和 odds 容器的类型。提示：在第 17 章中可能有可以使用的东西。

\item
\textbf{练习 20-5}：练习 20-3 的解决方案只使用了约束算法。能只使用无约束算法来做同样的事情吗？
\end{itemize}













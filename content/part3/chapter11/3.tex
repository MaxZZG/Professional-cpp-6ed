
This section describes the concept of linkage in C++. As Chapter 1 explains, C++ source files are first processed by the preprocessor, which processes all preprocessor directives, resulting in translation units. All translation units are then compiled independently into object files, which contain the machine executable code but in which references to functions and so on are not yet defined. Resolving those references is done by the final phase, the linker, which links all object files together into the final executable. Technically, there are a few more phases in the compilation process, but for this discussion, this simplified view is sufficient.

Each name in a C++ translation unit, including functions and global variables, either has linkage or has no linkage, and this specifies where that name can be defined and from where it can be accessed. There are four types of linkage:

\begin{itemize}
\item
No linkage: The name is accessible only from the scope in which it is defined.

\item
External linkage: The name is accessible from any translation unit.

\item
Internal linkage (also called static linkage): The name is accessible only from the current translation unit, but not from other translation units.

\item
Module linkage: The name is accessible from any translation unit from the same module.
\end{itemize}

\mySubsubsection{11.3.1.}{Internal Linkage}

By default, functions and global variables have external linkage. However, you can specify internal (or static) linkage by employing anonymous namespaces. For example, suppose you have two source files: FirstFile.cpp and AnotherFile.cpp. Here is FirstFile.cpp:

\begin{cpp}
void f();

int main()
{
    f();
}
\end{cpp}

Note that this file provides a prototype for f() but doesn’t show the definition. Here is AnotherFile.cpp:

\begin{cpp}
import std;

void f();

void f()
{
    std::println("f");
}
\end{cpp}

This file provides both a prototype and a definition for f(). Note that it is legal to write prototypes for the same function in two different files. That’s precisely what the preprocessor does for you if you put the prototypes in a header file that you \#include in each of the source files. For this example, I don’t use a header file. The reason to use header files used to be that it was easier to maintain (and keep synchronized) one copy of the prototype, but now that C++ has support for modules, using modules is recommended over using header files.

Each of these source files compiles without error, and the program links fine: because f() has external linkage, main() can call it from a different file.

However, suppose you wrap the f() function in AnotherFile.cpp in an anonymous namespace to give it internal linkage as follows:

\begin{cpp}
import std;

namespace
{
    void f();

    void f()
    {
        std::println("f");
    }
}
\end{cpp}

Entities in an anonymous namespace have internal linkage and thus can be accessed anywhere following their declaration in the same translation unit, but cannot be accessed from other translation units. With this change, each of the source files still compiles without error, but the linker step fails because f() has internal linkage, making it unavailable from FirstFile.cpp.

An alternative to using anonymous namespaces to give a name internal linkage is to prefix the declaration with the keyword static. The earlier anonymous namespace example can be written as follows. Note that you don’t need to repeat the static keyword in front of the definition of f(). As long as it precedes the first instance of the function name, there is no need to repeat it.

\begin{cpp}
import std;

static void f();

void f()
{
    std::println("f");
}
\end{cpp}

The semantics of this version of the code are exactly the same as the one using an anonymous namespace.

\begin{myWarning}{WARNING}
If a translation unit needs a helper entity that is only required within that translation unit, wrap it in an anonymous namespace to give it internal linkage. Using the static keyword for this is discouraged.
\end{myWarning}

\mySubsubsection{11.3.2.}{The extern Keyword}

A related keyword, extern, seems like it should be the opposite of static, specifying external linkage for the names it precedes, and it can be used that way in certain cases. For example, consts and typedefs have internal linkage by default. You can use extern to give them external linkage. However, extern has some complications. When you specify a name as extern, the compiler treats it as a declaration, not a definition. For variables, this means the compiler doesn’t allocate space for the variable. You must provide a separate definition for the variable without the extern keyword. For example, here is the content of AnotherFile.cpp:

\begin{cpp}
extern int x;
int x { 3 };
\end{cpp}

Alternatively, you can initialize x in the extern statement, which then serves as the declaration and the definition:

\begin{cpp}
extern int x { 3 };
\end{cpp}

The extern in this case is not very useful, because x has external linkage by default anyway. The real use of extern is when you want to use x from another source file, FirstFile.cpp:

\begin{cpp}
import std;

extern int x;

int main()
{
    std::println("{}", x);
}
\end{cpp}

Here, FirstFile.cpp uses an extern declaration so that it can use x. The compiler needs a declaration of x to use it in main(). If you declared x without the extern keyword, the compiler would think it’s a definition and would allocate space for x, causing the linkage step to fail (because there are then two x variables in the global scope). With extern, you can make variables globally accessible from multiple source files.

\begin{myWarning}{WARNING}
It is not recommended to use global variables at all. They are confusing and error-prone, especially in large programs. Use them judiciously!

The only exception are global constants. Don’t define the same constants all over the place: define them once and use them from everywhere.
\end{myWarning}




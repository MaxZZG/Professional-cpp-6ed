

In legacy code, you might come across the use of C-style variable-length argument lists. In new code, you should avoid using these and instead use variadic templates for type-safe variable-length argument lists, which are covered in Chapter 26, “Advanced Templates.”

So that you are aware of C-style variable-length argument lists, consider the C function printf() from <cstdio>. You can call it with any number of arguments:

\begin{cpp}
printf("int %d\n", 5);
printf("String %s and int %d\n", "hello", 5);
printf("Many ints: %d, %d, %d, %d, %d\n", 1, 2, 3, 4, 5);
\end{cpp}

C/C++ provides the syntax and some utility macros for writing your own functions with a variable number of arguments. These functions usually look a lot like printf(). For example, suppose you want to write a quick-and-dirty debug function that prints strings to stderr if a debug flag is set but does nothing if the debug flag is not set. Just like printf(), this function should be able to print strings with an arbitrary number of arguments and arbitrary types of arguments. A simple implementation looks as follows:

\begin{cpp}
import std;
#include <cstdarg>
#include <cstdio>

bool debug { false };

void debugOut(const char* str, ...)
{
    if (debug) {
        va_list ap;
        va_start(ap, str);
        vfprintf(stderr, str, ap);
        va_end(ap);
    }
}
\end{cpp}

The code uses va\_list(), va\_start(), and va\_end(), which are macros defined in <cstdarg> and thus require an explicit \#include <cstdarg>, as import std; does not export any macros. Similarly, stderr is a macro defined in <cstdio> requiring an explicit \#include <cstdio>.

The prototype for debugOut() contains one typed and named parameter str, followed by ... (ellipses). They stand for any number and type of arguments. To access these arguments, you must declare a variable of type va\_list and initialize it with a call to va\_start. The second parameter to va\_start() must be the rightmost named variable in the parameter list. All functions with variablelength argument lists require at least one named parameter. The debugOut() function simply passes this list to vfprintf() (a standard function in <cstdio>). After the call to vfprintf() returns, debugOut() calls va\_end() to terminate the access of the variable argument list. You must always call va\_end() after calling va\_start() to ensure that the function ends with the stack in a consistent state.

You can use the function in the following way:

\begin{cpp}
debug = true;
debugOut("int %d\n", 5);

debugOut("String %s and int %d\n", "hello", 5);
debugOut("Many ints: %d, %d, %d, %d, %d\n", 1, 2, 3, 4, 5);
\end{cpp}

\mySubsubsection{11.7.1.}{Accessing the Arguments}

If you want to access the actual arguments yourself, you can use va\_arg() to do so. It accepts a va\_list as first argument, and the type of the argument to interpret. Unfortunately, there is no way to know what the end of the argument list is unless you provide an explicit way of doing so. For example, you can make the first parameter a count of the number of parameters. Or, in the case where you have a set of pointers, you may require the last pointer to be nullptr. There are many ways, but they are all burdensome to the programmer.

The following example demonstrates the technique where the caller specifies in the first named parameter how many arguments are provided. The function accepts any number of ints and prints them out.

\begin{cpp}
void printInts(unsigned num, ...)
{
    va_list ap;
    va_start(ap, num);
    for (unsigned i { 0 }; i < num; ++i) {
        int temp { va_arg(ap, int) };
        print("{} ", temp);
    }
    va_end(ap);
    println("");
}
\end{cpp}

You can call printInts() as follows. Note that the first parameter specifies how many integers will follow.

\begin{cpp}
printInts(5, 5, 4, 3, 2, 1);
\end{cpp}

\mySubsubsection{11.7.2.}{Why You Shouldn’t Use C-Style Variable-Length Argument Lists}

Accessing C-style variable-length argument lists is not very safe. There are several risks, as you can see from the printInts() function.

\begin{itemize}
\item
You don’t know the number of parameters. In the case of printInts(), you must trust the caller to pass the right number of arguments as the first argument. In the case of debugOut(), you must trust the caller to pass the same number of arguments after the str string as there are replacement fields in the string.

\item
You don’t know the types of the arguments. va\_arg() takes a type, which it uses to interpret the value in its current spot. However, you can tell va\_arg() to interpret the value as any type. There is no way for it to verify the correct type.
\end{itemize}

\begin{myWarning}{WARNING}
Avoid using C-style variable-length argument lists. It is preferable to pass in an std::array or vector of values, to use initializer lists described in Chapter 1, or to use variadic templates for type-safe variable-length argument lists, as described in Chapter 26.
\end{myWarning}














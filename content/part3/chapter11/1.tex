
第1章中介绍了模块，并在前面的章节中，已经编写并使用过简单模块。C++20引入模块之前，头文件（本章后面将讨论）用来提供可重用代码块的接口。然而，头文件确实存在一些问题，比如:需要避免多次包含同一个头文件，确保头文件按正确的顺序包含。此外，\#include <iostream> 就会增加数万行代码，编译器需要处理这些代码。如果几个源文件都 \#include <iostream>，那么所有这些翻译单元都会变得更大，而这还只是一个头文件的情况。如果需要 <iostream>、<vector>、<format> 等多个头文件呢？模块就是用来解决这些问题的，甚至有更多其他作用，而模块导入的顺序并不重要。

模块会编译为二进制格式，然后编译器可以在另一个源文件导入模块时使用。这与头文件形成鲜明对比，编译器遇到包含该头文件的 \#include 时都需要重新编译，所以模块可以显著提高编译速度。增量编译得性能也会有所改善，因为模块中的某些修改（例如，修改模块接口文件中导出函数的实现）不会触发模块使用者的重新编译（本章后面将详细讨论）。模块不受外部宏的影响，模块内定义的宏对模块外的代码不可见，即模块自隔离。因此，有以下建议：

\begin{myNotic}{NOTE}
考虑到所有讨论的优点，如果编译器支持模块，新编写的代码应该使用模块来将代码结构化为逻辑上独立的构建块。
\end{myNotic}

如果可能，遗留代码也可以逐渐过渡到模块。然而，世界上有很多遗留代码，而且很多第三方库还没有采用模块，因为截至本书编写时，并非所有编译器都完全支持模块，所以了解遗留头文件的工作方式仍然很重要。这就是为什么本章仍然会对头文件进行介绍的原因。

\begin{myNotic}{NOTE}
如何编译模块取决于编译器。请查阅编译器的文档，了解如何使用特定编译器处理模块。
\end{myNotic}

\begin{myNotic}{NOTE}
如前所述，截至本书编写时，并非所有编译器都完全支持模块，尽管所有主要编译器至少部分支持。本书到处使用模块。如果正在使用的编译器还不完全支持模块，可以将模块化代码转换为非模块化代码。
\end{myNotic}

\mySubsubsection{11.1.1.}{非模块化代码}

如果想使用不完全支持模块的编译器编译本书中的代码示例，可以按以下方式去模块化代码：

\begin{itemize}
\item
将.cppm模块接口文件重命名为.h头文件。

\item
在每个.h头文件顶部添加一个\#pragma once

\item
移除export module xyz声明。

\item
用\#include指令替换module xyz声明，以包含相应的头文件。

\item
用\#include指令替换import和export import声明。如果代码中使用import std;，则需要用\#include指令替换，以包含所有必要的单个头文件。请参阅附录C，了解所有标准库头文件的列表及其内容的概述。

\item
移除所有export关键字。

\item
移除所有module;的出现，其表示全局模块片段的开始。

\item
如果函数定义或变量定义出现在.h头文件中，请在它前面添加inline关键字。
\end{itemize}

\CXXTwentythreeLogo{-40}{-60}

\mySubsubsection{11.1.2.}{标准模块}

如第1章所述，可以通过导入标准命名模块 std 来访问 C++ 标准库中的所有内容。这个模块使整个标准库可用，包括所有在诸如 <cstddef> 等头文件中定义的 C 函数。然而，所有 C 函数仅通过 std 命名空间提供。对于遗留代码，可以考虑导入 std.compat 模块，会导入 std 的所有内容，可使所有 C 函数在 std 命名空间和全局命名空间中可用。在新代码中不建议使用 std.compat。

\mySubsubsection{11.1.3.}{模块接口文件}

模块接口文件定义了模块提供的功能的接口，通常是具有 .cppm 扩展名的文件。模块接口文件以声明开始，声明该文件定义了一个模块的名称，这称为模块声明。模块的名称可以是任何 C++ 标识符，可以包含点，但不能以点开始或结束，也不能连续包含多个点。有效名称的示例包括 datamodel、mycompany.datamodel、mycompany.datamodel.core、datamodel\_core 等。

\begin{myNotic}{NOTE}
目前，模块接口文件没有标准化的扩展名，而大多数编译器支持 .cppm（C++ 模块）扩展名，因此本书使用它。检查你的编译器的文档，了解应使用哪个扩展名。
\end{myNotic}

模块需要明确声明要导出什么，即客户端代码导入模块时可见的内容。模块可以导变量声明、函数声明、类型声明、using 指令和 using 声明。此外，导入声明也可以导出。从模块中导出实体使用 export 关键字完成，模块中没有导出的内容仅对模块本身可见。所有导出实体的集合称为模块接口。

下面是一个名为 Person.cppm 的模块接口文件的示例，它定义了一个 person 模块，并导出了一个 Person 类。注意，它导入了 std 提供的功能。

\begin{cpp}
export module person; // Named module declaration

import std; // Import declaration

export class Person // Export declaration
{
    public:
        Person(std::string firstName, std::string lastName)
            : m_firstName { std::move(firstName) }
            , m_lastName { std::move(lastName) } { }
        const std::string& getFirstName() const { return m_firstName; }
        const std::string& getLastName() const { return m_lastName; }
    private:
        std::string m_firstName;
        std::string m_lastName;
};
\end{cpp}

标准术语中，从命名模块声明（前一个代码片段中的第一行）开始直到文件结束的所有内容称为模块范围。

可以通过以下方式导入 person 模块使用 Person 类（test.cpp）：

\begin{cpp}
import person; // Import declaration for person module
import std;

using namespace std;

int main()
{
    Person person { "Kole", "Webb" };
    println("{}, {}", person.getLastName(), person.getFirstName());
}
\end{cpp}

只要具有名称，可以从模块中导出任何内容。例如，类定义、函数原型、类枚举类型、using 声明和指令、命名空间等。如果使用 export 关键字显式导出命名空间，那么命名空间内的所有内容也会自动导出。例如，以下代码片段导出了整个 DataModel 命名空间，所以无需显式导出单个类和类型别名：

\begin{cpp}
export module datamodel;
import std;
export namespace DataModel
{
    class Person { /* ... */ };
    class Address { /* ... */ };
    using Persons = std::vector<Person>;
}
\end{cpp}

还可以使用 export 块导出一整块声明：

\begin{cpp}
export
{
    namespace DataModel
    {
        class Person { /* ... */ };
        class Address { /* ... */ };
        using Persons = std::vector<Person>;
    }
}
\end{cpp}


\mySubsubsection{11.1.4.}{模块实现文件}

模块可以分为模块接口文件和一个或多个模块实现文件，模块实现文件通常的扩展名为.cpp。开发者可以自由决定，哪些实现移动到模块实现文件中，哪些实现留在模块接口文件中。一种选择是将所有函数和成员函数的实现移动到模块实现文件中，而只在模块接口文件中留下函数声明、类定义等。另一种选择是在接口文件中留下小型函数和成员函数的实现，而将其他函数和成员函数的实现移动到实现文件中。

模块实现文件包含一个命名模块声明，以指定实现是针对哪个模块的，但不包含 export 关键字。例如，之前的person模块，可以按以下方式拆分为接口和实现文件。这是模块接口文件：

\begin{cpp}
export module person; // Module declaration

import std;

export class Person
{
    public:
        Person(std::string firstName, std::string lastName);
        const std::string& getFirstName() const;
        const std::string& getLastName() const;
    private:
        std::string m_firstName;
        std::string m_lastName;
};
\end{cpp}

现在，实现在 Person.cpp 中：

\begin{cpp}
module person; // Module declaration, but without the export keyword

using namespace std;

Person::Person(string firstName, string lastName)
: m_firstName { move(firstName) }, m_lastName { move(lastName) }
{}

const string& Person::getFirstName() const { return m_firstName; }
const string& Person::getLastName() const { return m_lastName; }
\end{cpp}

注意，实现文件没有为 person 模块提供导入声明。模块 person 声明隐式地包括了 import person 声明，尽管在成员函数的实现中使用了 std::string，实现文件并没有为 std 提供导入声明。由于隐式导入 person，并且这个实现文件是 person 模块的一部分，所以从模块接口文件中隐式继承了 std 的导入声明。相比之下，因为 test.cpp 不是 person 模块的一部分，所以向 test.cpp 文件添加 import person 声明并不会隐式继承 std 的导入声明。关于这一点，本章后面的“可见性与可达性”部分还有更详细的解释。

\begin{myNotic}{NOTE}
模块接口文件和模块实现文件中的所有导入声明必须位于文件的顶部，位于命名模块声明之后，其他声明之前。
\end{myNotic}

\begin{myWarning}{WARNING}
模块实现文件不能导出，只有模块接口文件可以。
\end{myWarning}

\mySubsubsection{11.1.5.}{接口与实现分离}

使用头文件（本章后面讨论）时，强烈建议只在头文件（.h）中放置声明，并将所有实现移动到源文件（.cpp），这样做的原因之一是为了减少编译时间。如果将实现放在头文件中，任何修改，即使是修改注释，都需要重新编译包含该头文件的所有源文件。对于某些头文件，这可能会波及整个代码库，导致程序需要完全重新编译。相反，如果将实现放在源文件中，不触及头文件而更改这些实现，则只需要重新编译那个单独的源文件即可。

模块的工作方式不同。模块接口只包含类定义、函数声明等，但不包括函数或成员函数的实现，即使这些实现在模块接口文件中。所以，只要不触及接口部分，例如函数头（函数名称、参数列表和返回类型），更改模块接口文件中的函数或成员函数实现时，并不需要重新编译该模块。两个例外是带有inline关键字的函数和模板定义。这时，编译器需要客户端代码在使用它们时，知道其完整实现。因此，对内联函数或模板定义的更改，都可能需要重新编译客户端代码。

\begin{myNotic}{NOTE}
头文件中的类定义，如果包含成员函数的实现，那么这些成员函数为隐式内联，即使没有用inline关键字标记它们，但这在模块接口文件中的类定义中是不成立的。如果需要内联，需要明确标记为inline。
\end{myNotic}

尽管从技术上讲，不再需要将接口与实现分离，但在某些情况下，我仍然建议这样做。主要目标应该是拥有清晰易读的接口，要是实现比较简单，那么函数的实现可以留在接口中。例如，一个模块有一个相当大的公共接口，那么最好不要用实现遮掩这个接口，以便用户可以更好地了解提供了什么。不过，小的getter和setter函数可以留在接口中，它们实际上不会影响接口的可读性。

分离接口与实现可以通过几种方式完成。一种选择是将模块拆分为接口和实现文件，如前一节所述。另一种选择是在单个模块接口文件内分离接口和实现。例如，在单个模块接口文件（person.cppm）中定义的Person类，但实现与接口是分离的：

\begin{cpp}
export module person;
import std;
// Class definition
export class Person
{
    public:
        Person(std::string firstName, std::string lastName);
        const std::string& getFirstName() const;
        const std::string& getLastName() const;
    private:
        std::string m_firstName;
        std::string m_lastName;
};
// Implementations
Person::Person(std::string firstName, std::string lastName)
    : m_firstName { std::move(firstName) }, m_lastName { std::move(lastName) } { }
const std::string& Person::getFirstName() const { return m_firstName; }
const std::string& Person::getLastName() const { return m_lastName; }
\end{cpp}


\mySubsubsection{11.1.6.}{可见性与可达性}

如前所述，当在另一个不属于 person 模块的非 test.cpp 文件中导入 person 模块时，并没有从 person 模块接口文件中隐式继承 std 的导入声明。如果没有在 test.cpp 中显式导入 std ，那么 std::string是不可见的，所以以下代码行无法编译：

\begin{cpp}
import person;
int main()
{
    std::string str;
}
\end{cpp}

然而，即使没有向 test.cpp 显式导入 std ，以下代码行也能正常工作：

\begin{cpp}
Person person { "Kole", "Webb" };
const auto& lastName { person.getLastName() };
auto length { lastName.length() };
\end{cpp}

为什么这能正常工作？在 C++ 中，实体的可见性和可达性之间有区别。通过导入 person 模块，来自 std 的功能变得可达但不可见。可达类的成员函数自动变得可见。所以可以使用 std 中的某些功能，例如通过使用 auto 类型推导将 getLastName() 的结果存储在变量中，并对其调用成员函数，如 length()。

要在 test.cpp 中使 std::string 名称正确可见，需要显式导入 std 或 <string>。

\mySubsubsection{11.1.7.}{子模块}

C++标准并没有明确提到子模块；然而，允许在模块名称中使用点号，这就可以按设想的层次结构来组织模块。例如，之前的DataModel命名空间：

\begin{cpp}
export module datamodel;
import std;
export namespace DataModel
{
    class Person { /* ... */ };
    class Address { /* ... */ };
    using Persons = std::vector<Person>;
}
\end{cpp}

Person和Address类都在DataModel命名空间中，且在datamodel模块中。可以通过定义两个子模块：datamodel.person和datamodel.address来进行重构。datamodel.person子模块的模块接口文件如下所示：

\begin{cpp}
export module datamodel.person; // datamodel.person submodule
export namespace DataModel { class Person { /* ... */ }; }
\end{cpp}

这里是datamodel.address的模块接口文件：

\begin{cpp}
export module datamodel.address; // datamodel.address submodule
export namespace DataModel { class Address { /* ... */ }; }
\end{cpp}

最后，datamodel模块定义如下，导入并立即导出两个子模块。

\begin{cpp}
export module datamodel; // datamodel module
export import datamodel.person; // Import and export person submodule
export import datamodel.address; // Import and export address submodule
import std;
export namespace DataModel { using Persons = std::vector<Person>; }
\end{cpp}

当然，子模块中类的成员函数实现也可以放入模块实现文件中。例如，Address类有一个默认构造函数，只向标准输出打印一条语句。该实现就可以放在名为datamodel.address.cpp的文件中：

\begin{cpp}
module datamodel.address; // datamodel.address submodule
import std;
using namespace std;
DataModel::Address::Address() { println("Address::Address()"); }
\end{cpp}

使用子模块结构化代码的好处是，客户端可以选择一次性导入所有内容，或者只导入他们想要使用的特定部分。例如，客户端代码需要访问datamodel模块中的所有内容，那么按以下方式导入声明是最简单的：

\begin{cpp}
import datamodel;
\end{cpp}

另一方面，如果客户端代码只对使用Address类感兴趣，那么以下导入声明就足够了：

\begin{cpp}
import datamodel.address;
\end{cpp}

一次性导入所有内容，比有选择地导入所需内容更方便，尤其是对于很少更改的稳定模块。然而，通过为不太稳定的模块使用选择性导入，如果对模块进行了更改，可能会增加构建时间。例如，对datamodel.address子模块的接口进行了更改，则只需要重新编译导入该子模块的文件。

\mySubsubsection{11.1.8.}{模块分区}

另一种模块结构化的选项是将其分割成单独的分区。子模块和分区的区别在于，子模块结构对模块的用户可见，允许用户仅导入想要使用的子模块。另一方面，分区用于在模块内部进行结构化，分区对模块的用户不可见。模块接口分区文件中声明的所有分区必须最终由主模块接口文件导出，可以直接或间接导出。一个模块只有一个这样的主模块接口文件，即包含 export module name 声明的接口文件。

通过将模块名称和分区名称用冒号分隔来创建模块分区，分区名称可以是任何合法标识符。例如，上一节中的 DataModel 模块可以使用分区而不是子模块进行重构。这是 datamodel.person.cppm 模块接口分区文件中的 person 分区：

\begin{cpp}
export module datamodel:person; // datamodel:person partition
export namespace DataModel { class Person { /* ... */ }; }
\end{cpp}

这是包含默认构造函数的 address 分区：

\begin{cpp}
export module datamodel:address; // datamodel:address partition
export namespace DataModel
{
    class Address
    {
        public:
        Address();
        /* ... */
    };
}
\end{cpp}

遗憾的是，当分区结合实现文件使用时有一个注意事项：只能有一个具有特定分区名称的文件，所以以下声明的实现文件是错误的：

\begin{cpp}
module datamodel:address;
\end{cpp}

但可以将 address 分区的实现放在 datamodel 模块的实现文件中：

\begin{cpp}
module datamodel; // Not datamodel:address!
import std;
using namespace std;
DataModel::Address::Address() { println("Address::Address()"); }
\end{cpp}

\begin{myWarning}{WARNING}
多个文件不能具有相同的分区名称。具有相同分区名称的多个模块接口分区文件非法，模块接口分区文件中声明的实现与实现文件不能具有相同的分区名称。解决方法是，将这些实现放在模块的实现文件中即可。
\end{myWarning}

编写以分区结构化的模块时，需要记住的是，每个模块接口分区必须最终由主模块接口文件导出，可以直接或间接导出。要导入分区，只需指定以冒号前缀的分区名称，例如 import :person，而不能是 import datamodel:person。记住，分区对模块的用户不可见，分区仅用于在模块内部进行结构化。因此，用户不能导入特定分区，必须导入整个模块。分区只能在模块内部导入，指定模块名称前的冒号是多余的（并且非法）。这是 datamodel 模块的主模块接口文件：

\begin{cpp}
export module datamodel; // datamodel module (primary module interface file)
export import :person; // Import and export person partition
export import :address; // Import and export address partition
import std;
export namespace DataModel { using Persons = std::vector<Person>; }
\end{cpp}

可以这样使用这个分区结构化的 datamodel 模块：

\begin{cpp}
import datamodel;
int main() { DataModel::Address a; }
\end{cpp}

\begin{myNotic}{NOTE}
分区用于在模块内部进行结构化，并且对模块外部不可见。因此，模块的用户不能导入特定分区，必须导入整个模块。如果希望允许用户选择性地导入模块的部分，可以使用子模块。
\end{myNotic}

前面已经解释过，模块名称声明隐式地包括一个导入名称声明。但对于分区来说，情况并非如此。

例如，datamodel:person 分区没有隐式的导入 datamodel 声明。这个例子中，甚至不允许在 datamodel:person 接口分区文件中添加显式的导入 datamodel。这样做会导致循环依赖：datamodel 接口文件包含一个 import :person 声明，而 datamodel:person 接口分区文件将包含一个导入 datamodel 声明。

为了打破循环依赖，可以将 datamodel:person 分区从 datamodel 接口文件中的功能移动到另一个分区，该分区随后可以从 datamodel:person 接口分区文件和 datamodel 接口文件导入。

\mySamllsection{实现分区}

分区不需要在模块接口分区文件中声明，可以在模块实现分区文件中声明、一个.cpp 扩展名的普通源代码文件，是一个实现分区，有时称为内部分区。与必须由主模块接口文件导出的模块接口分区不同，不能导出实现分区。

例如，有一个名为 math 的主模块接口文件（math.cppm）：

\begin{cpp}
export module math; // math module declaration
export namespace Math
{
    double superLog(double z, double b);
    double lerchZeta(double lambda, double alpha, double s);
}
\end{cpp}

假设数学函数的实现需要一些不能导出的辅助函数，实现分区是放置此类辅助函数的完美位置。以下在名为 math\_helpers.cpp 的文件中定义了这样的实现分区：

\begin{cpp}
module math:details; // math:details implementation partition
double someHelperFunction(double a) { return /* ... */ ; }
\end{cpp}

其他 math 模块实现文件可以通过导入这个实现分区来获取这些辅助函数的访问权限。例如，一个 math 模块实现文件（math.cpp）可能看起来像这样：

\begin{cpp}
module math;
import :details;
double Math::superLog(double z, double b) { return /* ... */; }
double Math::lerchZeta(double lambda, double alpha, double s) { return /* ... */; }
\end{cpp}

通过 import :details; 声明，superLog() 和 lerchZeta() 函数可以调用 someHelperFunction()。

当然，使用这样的实现分区与辅助函数，只在多个其他源文件使用这些辅助函数时才有意义。

\mySubsubsection{11.1.9.}{私有模块段}

主模块接口可以包含一个私有模块段。这个私有模块片起始与下面这行代码：

\begin{cpp}
module :private;
\end{cpp}

此行之后的所有内容都是私有模块段的一部分，私有模块片段中定义的内容都不会导出，因此对模块的使用者不可见。

第9章演示了pimpl习惯用法，也称为私有实现习惯用法，隐藏了类使用者所有的实现细节。第9章中的解决方案需要两个文件：主模块接口文件和模块实现文件。使用私有模块段，可以使用单个文件实现这种分离。下面是一个简洁的示例：

\begin{cpp}
export module adder;
import std;
export class Adder
{
    public:
    Adder();
    virtual ˜Adder();
    int add(int a, int b) const;
    private:
    class Impl;
    std::unique_ptr<Impl> m_impl;
};

module :private;

class Adder::Impl
{
    public:
    ~Impl() { std::println("Destructor of Adder::Impl"); }
    int add(int a, int b) const { return a + b;}
};

Adder::Adder() : m_impl { std::make_unique<Impl>() } { }
Adder::~Adder() {}
int Adder::add(int a, int b) const { return m_impl->add(a, b); }
\end{cpp}

这个类可以按以下方式测试：

\begin{cpp}
Adder adder;
println("Value: {}", adder.add(20, 22));
\end{cpp}

现在，为了证明私有模块段中的所有内容确实已隐藏，我们在Adder类的末尾添加一个公共成员函数getImplementation()：

\begin{cpp}
export class Adder
{
    /* ... as before, omitted for brevity ... */
    private:
        class Impl;
        std::unique_ptr<Impl> m_impl;
    public:
        Impl* getImplementation() { return m_impl.get(); }
};
\end{cpp}

以下代码编译运行正常：

\begin{cpp}
Adder adder;
auto impl { adder.getImplementation() };
\end{cpp}

从Adder模块的使用者角度来看，getImplementation()返回一个指向不完整类型的指针，代码段将该指针存储在一个名为impl的变量中。只要使用auto类型推导，可以存储指向不完整类型的指针。然而，不能对该指针执行操作，使用该不完整指针的add()会导致错误：

\begin{cpp}
auto result { impl->add(20, 22) }; // Error!
\end{cpp}

错误信息类似于：使用未定义的类型Adder::Impl。原因是Adder::Impl类是私有模块段的一部分，因此无法从Adder模块的使用者那里访问。

如果从模块接口文件中删除module :private;行，则之前的代码片段将编译运行正常。读者们可能会对此感到惊讶；毕竟，Adder::Impl类没有明确导出。的确——它没有明确导出，但因导出了Adder类被且Impl类在Adder类中声明，所以隐式导出了Adder::Impl类。

\mySubsubsection{11.1.10.}{Header Units}

When importing a module, you use an import declaration such as the following:

\begin{cpp}
import person;
\end{cpp}

If you have legacy code, such as a person.h header file defining a Person class, then you can modularize it by converting it to a proper module, person.cppm, and use import declarations to make it available to client code. However, sometimes you cannot modularize such headers. Maybe your Person class should remain usable by compilers that do not yet have support for modules. Or maybe the person.h header is part of a third-party library that you cannot modify. In such cases, you can import your header file directly, as follows:

\begin{cpp}
import "person.h";
\end{cpp}

With such a declaration, everything in the person.h header file becomes implicitly exported. Additionally, macros defined in the header become visible to client code, which is not the case for real modules, neither for your own modules nor for the named std and std.compat modules.

Such an import declaration can include relative or absolute paths to header files, and you can use < > instead of "" to search in the system include directories:

\begin{cpp}
import "include/person.h"; // Can include a relative or absolute path.
import <person.h>; // Search in system include directories.
\end{cpp}

Compared to using \#include to add a header file, using import will improve build throughput, as the person.h header will implicitly be converted to a module and hence be compiled only once, instead of every time when the header is included in a source file. As such, it can be used as a standardized way to support precompiled header files, instead of using compiler-dependent precompiled header file support.

For each import declaration naming a header file, the compiler creates a module with an exported interface similar to what the header file defines, i.e., it implicitly exports everything from the header file. This is called a header unit. The procedure for this is compiler dependent, so check the documentation of your compiler to learn how to work with header units.

\begin{myNotic}{NOTE}
By importing a header unit, the preprocessor definitions from that header unit become available to you. However, if you export import a header unit, its preprocessor definitions are not exported further. Any code that needs access to those preprocessor definitions needs to explicitly import the header unit.
\end{myNotic}

\mySubsubsection{11.1.11.}{Importable Standard Library Headers}

All C++ headers, such as <iostream>, <vector>, <string>, and so on, are importable headers that can be imported with an import declaration. That means you can, for example, write the following:

\begin{cpp}
import <vector>;
\end{cpp}

Of course, starting with C++23, it’s more convenient to simply import the named module called std, instead of manually importing those importable headers that you need. For example, the following makes everything in the Standard Library available for your use:

\begin{cpp}
import std;
\end{cpp}

As you know by now, importable C++ Standard Library headers don’t have any .h extension, e.g., <vector>, and they define everything in the std namespace or a subnamespace of std.

In C, the names of Standard Library header files end with .h, such as <stdio.h>, and namespaces are not used.

Most of the Standard Library functionality from C is available in C++ but is provided through two different headers:

\begin{itemize}
\item
The recommended versions without the .h extension but with a c prefix, for example, <cstdio>. These put everything in the std namespace.

\item
The C-style versions with the .h extension, for example, <stdio.h>. These do not use namespaces. Their use is discouraged, except when you are writing code that needs to be both valid C++ and valid C at the same time. This use case is not further discussed in this C++ book.
\end{itemize}

\CXXTwentythreeLogo{-40}{-60}

\begin{myNotic}{NOTE}
Up until C++23, the use of <name.h> C Standard Library headers was deprecated. Starting with C++23, their use is no longer deprecated, but discouraged.
\end{myNotic}

Technically, the old versions are allowed to put things in the std namespace as well, and the new versions are allowed to additionally put things in the global namespace. This behavior is not standardized, so you should not rely on it.

As mentioned earlier, when using import std; you automatically get access to C-style functions, such as the mathematical functions defined in <cmath>. They will be in the std namespace, e.g., std::sqrt(). If you import std.compat; these C-style functions will additionally be available in the global namespace, e.g., ::sqrt().

However, if you cannot use the std or std.compat named modules, then keep in mind that the C Standard Library headers are not guaranteed to be importable with an import declaration. In that case, to be safe, use \#include <cxyz> instead of import <cxyz>;.

Additionally, as mentioned in the previous section, importing a proper module, e.g., std or std .compat, won’t make any C-style macros defined in the module available to the importing code. This is especially important to remember when you want to use C-style macros from the C Standard Library. Luckily, there aren’t many! One of them is <cassert>, a C Standard Library header that defines the assert() macro, which is explained in more detail in Chapter 31, “Conquering Debugging.” Since the named std and std.compat modules won’t make the assert() macro available to importing code, and since <cassert> is a C Standard Library header and thus not guaranteed to be importable, you must use \#include <cassert> to get access to assert().

\begin{myNotic}{NOTE}
If you can import a header file, it’s recommended to do so. Only \#include a header file if it’s not importable, for instance, because the content of the header file is dependent on some preprocessor \#defines (see the next section).
\end{myNotic}

If you do need to \#include a header in a module interface or module implementation file, the \#include directives should be placed in the global module fragment, which must come before any named module declaration and starts with a nameless module declaration. A global module fragment can only contain preprocessing directives such as \#includes, \#defines, and so on. Such a global module fragment and comments are the only things that are allowed to appear before a named module declaration. For example, if you need to use functionality from the <cassert> C header file, you can make that available as follows:

\begin{cpp}
module; // Start of the global module fragment
#include <cassert> // Include legacy header files

export module person; // Named module declaration
import std;
export class Person { /* ... */ };
\end{cpp}

\begin{myWarning}{WARNING}
Place all \#include directives in a module interface or module implementation file in the global module fragment.
\end{myWarning}












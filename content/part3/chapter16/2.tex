
本节从设计的角度介绍了标准库的各种组件。

将了解到可用的各种工具，但不会有太多编码细节。这些细节在其他章节中进行介绍。

\mySubsubsection{16.2.1.}{字符串}

C++提供了一个内置的字符串类，定义在<string>中。这个C++字符串类在几乎所有方面都比C风格的字符数组字符串更优秀。它处理内存管理；提供了边界检查、赋值语义和比较；并支持连接、提取子字符串和替换子字符串或字符等操作。

\begin{myNotic}{NOTE}
从技术上讲，std::string是std::basic\_string类模板的char实例化的类型别名。不必担心这些细节，可以像使用非模板类一样使用string。
\end{myNotic}

标准库还提供了一个string\_view类，定义在<string\_view>中，对任何类型的字符串表示的只读视图，可以用作const string\&的平替，并且无开销，因为它不复制字符串！

C++支持Unicode和本地化。Unicode编写能够在不同语言中处理文本的程序，如阿拉伯语、中文、日语等。本地化，定义在<locale>中，根据某个国家或地区的规则格式化数据，如数字和日期。

C++包括一个强大的类型安全的字符串格式化库，可以通过std::format()使用，定义在<format>中。这个库可扩展，允许添加对自己自定义类型的支持。C++23增加了辅助函数std::print()和println()，以简化向控制台打印格式化文本的操作。

\mySubsubsection{16.2.2.}{正则表达式}

正则表达式通过<regex>提供的功能实现，使得执行模式匹配变得简单，常用于文本处理中。模式匹配允许在字符串中搜索特殊模式，并可以选择用新模式替换。正则表达式在第21章中进行介绍。

\mySubsubsection{16.2.3.}{I/O 流}

C++包括一个用于输入和输出的模型，称为流。C++库提供了用于从文件、控制台/键盘和字符串读取和写入内置类型的例程。C++还提供了编写自己的例程以读取和写入自己的对象的设施。大部分I/O功能定义在<fstream>, <iomanip>, <ios>, <iosfwd>, <iostream>, <istream>, <ostream>, <sstream>, <streambuf>和<strstream>中。C++23引入了基于span的流，定义在<spanstream>中。第1章回顾了I/O流的基础知识，而第13章中详细介绍了流。

\mySubsubsection{16.2.4.}{智能指针}

健壮编程中面临的问题是，在何时删除一个对象(可能会有几种失败的情况)。第一个问题是不删除对象（未能释放存储空间），这称为\textbf{内存泄漏}，对象累积并占用空间，但未使用。另一个问题是，一块代码删除了存储空间，而另一块代码仍在指向该存储空间，导致指针指向不再使用，或已为其他目的重新分配的存储空间，这称为\textbf{悬空指针}。还有一个问题是，一块代码释放了存储空间，另一块代码尝试再次释放相同的存储空间，这称为\textbf{双重删除}。

所有这些问题会导致程序失败。有些失败容易发现并可能导致应用程序崩溃；其他则会导致程序产生错误结果，这些错误大多数难以发现和修复。

C++通过智能指针解决了所有这些问题：unique\_ptr, shared\_ptr和weak\_ptr，都定义在<memory>中。这些智能指针在第7章中进行了介绍。

\mySubsubsection{16.2.5.}{异常}

C++语言支持异常，允许函数将各种类型的错误传递给调用函数。C++标准库提供了一个异常类层次结构，可以在代码中使用，也可以从中派生以创建自己的异常类型。大部分异常支持定义在<exception>, <stdexcept>和<system\_error>中。第14章涵盖了异常和标准异常类的细节。

\mySubsubsection{16.2.6.}{标准整数类型}

<stdint.h>头文件定义了许多标准整数类型，如intx\_t和uintx\_t，其中x等于8、16、32或64，还包括指定那些类型的最小和最大值的宏。这些整数类型在第34章中会进行介绍。

\mySubsubsection{16.2.7.}{数值库}

C++标准库提供了一系列数学实用类和函数的集合。

一系列常见的数学函数可用，如abs(), remainder(), fma(), exp(), log(), pow(), sqrt(), sin(), atan2(), sinh(), erf(), tgamma(), ceil(), floor()等。库还支持许多数学特殊函数，用于处理勒让德多项式、贝塔函数、椭圆积分、贝塞尔函数、圆柱诺伊曼函数等。这些特殊函数具有确定的名称和符号，常用于数学分析、泛函分析、几何、物理和其他应用。lerp()函数计算线性插值或外推：lerp(a,b,t)计算a+t(b-a)。线性插值计算给定数据点之间的某个值，而外推计算低于或高于最小或最大数据点的值。这些函数大多定义在<cmath>中，一些在<cstdlib>中。

<numeric>定义了gcd()和lcm()，分别计算两个整数类型的最大公约数和最小公倍数。midpoint()函数计算两个值（整数、浮点数或指针）的中点。

从C++23起，其中许多函数就标记为constexpr（参见第9章），可以用于执行编译时计算。咨询标准库手册，了解哪些函数是constexpr。

有一个复数类叫做complex，定义在<complex>中，提供了一个抽象类，用于处理包含实部和虚部的数字。

编译时分数算术库提供了一个ratio类模板，定义在<ratio>中。这个ratio类模板可以精确表示由分子和分母定义的任何有限有理数。这个库在第22章中进行介绍。

标准库还包含一个名为valarray的类，定义在<valarray>中，类似于vector，但对于高性能数值应用进行了更多优化。库提供了几个类，来表示向量切片的概念。从这些构建块中，可以构建执行矩阵数学的类。虽然没有内置的矩阵类，但是像Boost这样的第三方库支持矩阵。valarray类在本书中不会进一步的进行介绍。

std::numbers命名空间中定义了一系列常用的数学常数，都在<numbers>中定义。这里只列出其中几个常用的：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{常量} & \textbf{描述} & \textbf{近似值} \\ \hline
\endfirsthead
%
\endhead
%
pi                & pi (π)的值  & 3.141592653589793      \\ \hline
inv\_pi           & pi的倒数    & 0.3183098861837907     \\ \hline
sqrt2             & 2的平方根 & 1.4142135623730951     \\ \hline
e                 & 欧拉数e     & 2.718281828459045      \\ \hline
phi               & 黄金分割比     & 1.618033988749895      \\ \hline
\end{longtable}

\mySubsubsection{16.2.8.}{整数比较}

以下是比较函数可用：std::cmp\_equal(), cmp\_not\_equal(), cmp\_less(), cmp\_less\_equal(), cmp\_greater(), 和 cmp\_greater\_equal()，都定义在<utility>中。这些函数执行两个整数的比较，并且可以安全地用于混合有符号和无符号的比较。

例如，以下代码使用operator>比较有符号值-1和无符号值0u。输出是1(= true)，因为-1首先被转换为无符号整数，因此会变成了一个很大的数字，如4,294,967,295，这肯定大于0：

\begin{cpp}
println("{}", (-1 > 0u)); // true
\end{cpp}

使用cmp\_greater()来获得正确的输出：

\begin{cpp}
println("{}", cmp_greater(-1, 0u)); // false
\end{cpp}

\mySubsubsection{16.2.9.}{位操作}

标准库支持以下函数来处理位，都定义在<bit>中。所有这些函数都需要一个无符号整数类型作为第一个参数：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{函数}  & \textbf{描述}                                                                                                                      \\ \hline
\endfirsthead
%
\endhead
%
has\_single\_bit() & \begin{tabular}[c]{@{}l@{}}给定值只包含单个位，即是一个整数的2的幂，则返回true。
\end{tabular} \\ \hline
bit\_ceil()        & \begin{tabular}[c]{@{}l@{}}返回大于或等于给定值的最小的2的整数幂。
\end{tabular}              \\ \hline
bit\_floor()       & \begin{tabular}[c]{@{}l@{}}返回小于或等于给定值的最大的2的整数幂。
\end{tabular}               \\ \hline
bit\_width()       & 返回存储给定值所需的位数。
                                                                                 \\ \hline
\begin{tabular}[c]{@{}l@{}}rotl()\\ rotr()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}将给定值的位向左或向右旋转。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}countl\_zero()\\ countl\_one()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}返回从左边开始，即从最高有效位开始的给定值中连续0或1比特的数量。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}countr\_zero()\\ countr\_one()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}返回从右边开始，即从最低有效位开始的给定值中连续0或1比特的数量。
\end{tabular} \\ \hline
popcount()         & 返回给定值中1比特的数量。
                                                                                          \\ \hline
byteswap()(C++23)  & 反转整数类型的各个字节。
                                                                                          \\ \hline
\end{longtable}

以下是一些例子：

\begin{cpp}
println("{}", popcount(0b10101010u)); // 4

uint8_t value { 0b11101011u };
println("{}", countl_one(value)); // 3
println("{}", countr_one(value)); // 2

value = 0b10001000u;
println("{:08b}", rotl(value, 2)); // 00100010

value = 0b00001011u;
println("bit_ceil({0:08b} = {0}) = {1:08b} = {1}",
    value, bit_ceil(value)); // bit_ceil(00001011 = 11) = 00010000 = 16
println("bit_floor({0:08b} = {0}) = {1:08b} = {1}",
    value, bit_floor(value)); // bit_floor(00001011 = 11) = 00001000 = 8

uint32_t before { 0x12345678u };
println("{:x}", before); // 12345678
uint32_t after { byteswap(before) }; // C++23 std::byteswap().
println("{:x}", after); // 78563412
\end{cpp}

\mySubsubsection{16.2.10.}{时间和日期工具}

标准库包括chrono库，定义在<chrono>中。这个库使得处理日期和时间变得简单，可以计算特定的时间长度等。库支持日历来处理日期，以及时区，包括在不同时区之间转换时间的功能。<ctime>头文件提供了一些C风格的时间和日期工具。

第22章详细介绍了时间和日期工具。

\mySubsubsection{16.2.11.}{随机数}

C++长期以来一直支持使用srand()和rand()函数生成伪随机数，但这些函数只提供低质量的随机数。例如，不能改变生成的随机数的分布。

自从C++11以来，一个强大的随机数生成库已经可用。这个库定义在<random>中，并带有随机数引擎、随机数引擎适配器和随机数分布。这些可以用来生成高质量的随机数，并支持不同的分布，如正态分布、负指数分布等。

有关这个库的详细信息，请参阅第23章。

\mySubsubsection{16.2.12.}{初始化列表}

初始化列表定义在<initializer\_list>中，使得编写可以接受可变数量参数的函数变得简单，并在第1章中有所讨论。

\mySubsubsection{16.2.13.}{pair和tuple}

<utility>定义了pair类模板，可以存储两个可能不同类型的元素，这称为存储异构元素。本章后面讨论的所有标准库容器都存储同构元素，所以容器中的所有元素必须具有相同的类型。pair类模板允许将两个完全无关类型的元素存储在一个对象中，这在第1章中有过介绍。

tuple，定义在<tuple>中，是pair的泛化，是一个具有固定大小且可以拥有异构元素的序列。tuple的元素数量和类型在编译时固定，tuple将在第24章中进行介绍。

\mySubsubsection{16.2.14.}{词汇类型}

词汇类型是会频繁使用的类型，就像整数和双精度类型这样的基本类型一样。使用词汇类型可使代码更安全、更高效，也更易于编写、阅读和维护。本书中讨论的词汇类型示例包括vector、optional、string、unique\_ptr、shared\_ptr等。

第24章讨论了以下词汇类型：

\begin{itemize}
\item
variant，定义在<variant>中，可以存储一组给定类型中的单个值。

\item
any，定义在<any>中，可以存储任何类型的单个值。

\item
元组，定义在<tuple>中，是对的泛化。可以存储任意数量的值，每个值都有其特定的类型。

\item
optional，定义在<optional>中，持有特定类型的值或无值。可以用于类数据成员、函数参数、函数的返回类型等。在第1章中介绍过，第24章解释了optional支持单调操作，允许在optional上进行链式操作，而无需担心在应用另一个操作之前，optional是否为空。

\item
expected，定义在<expected>中，持有特定类型的值，或一个可能不同的错误类型的值。这可以作为函数的返回类型，因为函数允许将请求的数据返回给调用者，或者返回出错的原因。
\end{itemize}

\CXXTwentythreeLogo{-40}{30}

\mySubsubsection{16.2.15.}{函数对象}

实现函数调用运算符的类称为函数对象。函数对象可以用于某些标准库算法的谓词，<functional>定义了一些预定义的函数对象，并支持基于现有对象创建新的函数对象。

函数对象在第19章中会详细介绍。

\mySubsubsection{16.2.16.}{文件系统}

文件系统支持库的所有内容都定义在<filesystem>中，位于std::filesystem命名空间中。允许编写可移植的代码来处理文件系统，可以使用它来查询某物是否是目录或文件，遍历目录的内容，操作路径，以及获取关于文件的信息，如其大小、扩展名、创建时间和等等。文件系统支持库在第13章中介绍过。

\mySubsubsection{16.2.17.}{多线程}

所有主要的CPU供应商都在销售具有多个核心的处理器，用于从服务器到消费类计算机甚至智能手机的各个方面。如果想让你的软件利用所有这些核心，就需要编写多线程代码。标准库为编写此类代码提供了几个基本构建块，可以使用<thread>中的thread类创建单个线程。库还定义了jthread，一个可以取消的线程，当它销毁时会自动执行join操作。

多线程代码中需要小心，以确保几个线程不会同时读写同一块数据，因为这会导致数据竞争。为防止这种情况，可以使用<atomic>中定义的原子变量，它们提供了对数据的线程安全原子访问。其他线程同步机制由<condition\_variable>和<mutex>提供。还有支持以下同步原语：信号量（<semaphore>）、门闩（<latch>）和栅栏（<barrier>）。

如果只需要计算一些东西，可能在不同的线程上，并带有适当的异常处理得到结果，可以使用async和future，这些都定义在<future>中，比直接使用thread或jthread更容易使用。

多线程编程在第27章中会详细介绍。

\mySubsubsection{16.2.18.}{类型特征}

类型特征定义在<type\_traits>中，并在编译时提供有关类型的信息。在编写高级模板时非常有用，会在第26章中进行介绍。

\mySubsubsection{16.2.19.}{标准库特性测试宏}

标准库特性测试宏可用于标准库特性。这些与核心语言特性（在第11章中介绍过）的特性测试宏类似，并允许验证标准库实现是否支持某个特定特性。所有这些宏都以\_\_cpp\_lib\_开头。以下列出了一些示例。请参阅标准库手册，以获取所有可能的标准库特性测试宏的完整列表。

\begin{itemize}
\item
\_\_cpp\_lib\_concepts

\item
\_\_cpp\_lib\_ranges

\item
\_\_cpp\_lib\_scoped\_lock

\item
\_\_cpp\_lib\_atomic\_float

\item
\_\_cpp\_lib\_constexpr\_vector

\item
\_\_cpp\_lib\_constexpr\_tuple

\item
\_\_cpp\_lib\_filesystem

\item
\_\_cpp\_lib\_three\_way\_comparison

\item
. . .
\end{itemize}

此类宏的值是一个数字，代表特定功能添加或更新的月份和年份。日期格式为YYYYMM。例如，\_\_cpp\_lib\_filesystem的值为201703，即2017年3月。

如第11章所述，核心语言功能测试宏始终可用，无需包含任何头文件。然而，标准库功能测试宏定义在<version>中。由于所有功能测试宏都是宏，从第11章可知，导入命名模块std或std.compat不会使这些宏。第11章还解释了所有C++头文件，如<version>，都是可导入的；因此，有两种方法来获取<version>中定义宏的访问权限：

\begin{cpp}
import <version>;
\end{cpp}

或

\begin{cpp}
#include <version>
\end{cpp}

以下是一个完整示例：

\begin{cpp}
import std;
import <version>; // Important to get access to the feature-test macros!
using namespace std;

int main()
{
#ifdef __cpp_lib_constexpr_vector
    println("std::vector is constexpr!");
#else
    println("Bummer! std::vector is NOT constexpr!");
#endif
}
\end{cpp}

\begin{myNotic}{NOTE}
除非正在编写跨平台和跨编译器的代码，否则通常不需要这些功能测试宏。这种情况下，可能需要知道给定的标准库实现是否支持某些功能，以便在缺少功能时提供后备代码。第34章介绍了跨平台开发。
\end{myNotic}

\mySubsubsection{16.2.20.}{<version>}

<version>可用于查询有关正在使用的C++标准库的实现相关信息，<version>提供的确切内容取决于库实现。可能的内容包括版本号、发布日期和版权声明。

另外，如前一节所述，<version>公开了所有标准库功能测试宏。

\mySubsubsection{16.2.21.}{源位置}

<std::source\_location>，定义在<source\_location>中，可用于查询有关源代码的信息，如文件名、函数名、行号和列号，并替换旧的C样式宏\_\_FILE\_\_和\_\_LINE\_\_。示例用例包括在记录消息或抛出异常时提供源代码信息，第14章给出了这两种用例的示例。

\mySubsubsection{16.2.22.}{堆栈跟踪}

\CXXTwentythreeLogo{-40}{15}

<stacktrace>定义了std::stacktrace和std::stacktrace\_entry类。这些类可用于在相应的时间内获取堆栈并跟踪，遍历和检查每个单独的条目，这些条目称为帧。请参阅第14章的示例。

\mySubsubsection{16.2.23.}{容器}

标准库提供了常用数据结构（如链表和队列）的实现。使用C++时，不应需要再次编写这些数据结构。这些数据结构使用一种容器的概念实现，这些容器以适当的方式存储称为元素的信息（链表、队列等）。不同的数据结构具有不同的插入、删除和访问行为以及性能特征。熟悉可用的数据结构很重要，这样就可以为给定的任务选择最合适的容器。

标准库中的所有容器都是类模板，因此可以使用它们存储任何类型，从内置类型（如int和double）到自己的类型。每个容器实例只存储一种类型的对象，它们是同质集合。如果需要非固定大小的异构集合，可以将每个元素包装在std::any实例中，并将这些any实例存储在容器中。或者，可以在容器中存储std::variant实例。如果所需类型的不同数量有限且在编译时已知，则可以使用variant。或者，可以创建一个具有多个派生类的类，每个派生类可以包装所需类型的对象。any和variant都会在第24章中介绍。

\begin{myNotic}{NOTE}
C++标准库容器是同质的：每个容器只允许一种类型的元素。
\end{myNotic}

C++标准规定了每个容器和算法的接口，但没有规定其实现。因此，不同的供应商可以提供不同的实现。然而，标准还将性能要求作为接口的一部分，实现必须满足这些要求。

本节提供了标准库中各种容器的概述。

\mySamllsection{顺序容器}

标准库提供了五种顺序容器：vector、list、forward\_list、deque和array。

\mySamllsection{vector}

vector定义在<vector>中，存储一系列元素，同时提供对这些元素的随机访问。可以将vector视为一个动态数组：一个元素，它在插入元素时会动态增长，并提供一些边界检查。与数组一样，vector的元素存储在连续的内存中。

\begin{myNotic}{NOTE}
C++中的vector是动态数组的同义词：根据其存储的元素数量自动增长和收缩的数组。
\end{myNotic}

vector在vector末尾提供快速元素插入和删除（常数时间），常数时间插入意味着大多数插入操作都是常量时间O(1)（第4章解释了big-O符号）。然而，有时vector需要增长大小以容纳新元素，这具有O(N)的复杂度。平均而言，这导致O(1)复杂度或常数时间。细节会在第18章中解释。vector在其他地方的插入和删除速度较慢（线性时间），因为操作必须将所有元素“上”或“下”移动一个位置，以为新元素腾出空间或填充被删除元素留下的空间。与数组一样，vector提供对任何元素的快速（常数时间）访问。

尽管在vector中间插入和删除元素需要移动其他元素，但vector应该是首选容器！通常，vector甚至比链表更快，即使在中间插入和删除元素也是如此。原因是vector在内存中连续存储，而链表在内存中分散。计算机非常有效地处理连续数据，这使得vector操作变得快速。只有当性能分析器（在第29章中介绍）告诉它比vector性能更好时，才应该使用链表之类的容器。

\begin{myNotic}{NOTE}
vector容器应该是首选容器。
\end{myNotic}

vector<bool>有一个模板特化，用于在vector中存储布尔值。

此特化优化了布尔元素的空间分配；然而，标准并没有规定vector<bool>的实现应该如何优化空间。vector<bool>特化与本章后面讨论的bitset容器的区别在于，bitset容器大小固定，而vector<bool>在需要时会自动增长或收缩。

\mySamllsection{list}

list是一个双向链表结构，定义在<list>中。与数组或vector一样，存储一系列元素。然而，与数组或vector不同，list的元素在内存中不一定是连续的。相反，list中的每个元素都指定了在list中找到下一个和上一个元素的位置（通常通过指针），这就是为什么它称为双向链表。

list的性能特征与vector完全相反，提供慢速（线性时间）元素查找和访问，但找到相关位置后，就快速（常数时间）插入和删除元素。然而，如前一节所述，vector通常比list更快。

\mySamllsection{forward\_list}

forward\_list定义在<forward\_list>中，是一个单向链表，与双向链表的list容器相比。forward\_list只支持前向迭代，并且比list占用更少的内存。与list一样，找到相关位置后，forward\_list可以以常数时间插入和删除元素，但没有对元素的快速随机访问。

\mySamllsection{deque}

deque是双端队列的缩写。deque定义在<deque>中，提供快速（常数时间）的元素访问。还允许在序列的两端以快速（常数时间）插入和删除元素，但在序列中间插入和删除元素则较慢（线性时间）。deque的元素在内存中不是连续存储的，因此deque可能比vector慢。

当需要从序列的两端插入或删除元素但仍需要快速访问所有元素时，以使用deque代替vector。然而，这种要求并不适用于常规编程问题；大多数情况下，推荐使用vector。

\mySamllsection{array}

array定义在<array>中，是标准C风格数组的替代品。有时事先知道容器中元素的确切数量，并且不需要vector或list这样的动态增长能力以适应新元素。对于这种固定大小的集合，array是完美的选择，并且与vector相比具有较少的开销；基本上是标准C风格数组的薄包装。使用array而不是标准C风格数组有许多优点：总是知道自己的大小，并且不会自动转换为指针，以避免某些类型的错误。此外，array不提供插入或删除操作；具有固定大小。固定大小的优点是，这允许array在栈上分配，而不是像vector那样总是要求访问自由存储。访问元素非常快（常数时间），就像vector一样。

\begin{myNotic}{NOTE}
因为存储元素的序列，vector、list、forward\_list、deque和array容器称为顺序容器。
\end{myNotic}

\mySamllsection{顺序视图}

标准库提供了两个顺序视图：span和mdspan。

\mySamllsection{span}

span定义在<span>中，表示对连续数据序列的视图。可以是只读视图，也可以是对基础元素具有读写访问权限的视图。span允许存在单一函数，处理来自vector、array、C风格数组等的数据。第18章详细介绍了span。

\begin{myNotic}{NOTE}
编写一个接受例如const vector<T>\&的函数时，考虑接受span<const T>代替，这样函数可以处理来自vector、array、C风格数组等的数据序列的视图和子视图。
\end{myNotic}

\mySamllsection{mdspan}

\CXXTwentythreeLogo{-40}{5}

mdspan定义在<mdspan>中，与span类似，但它表示对连续数据序列的多维视图。与span一样，可以是只读视图，也可以是对基础元素具有读写访问权限的视图。第18章详细介绍了mdspan。

\mySamllsection{容器适配器}

标准库提供了三个非关联容器适配器：queue、priority\_queue和stack。

\mySamllsection{queue}

queue的名字直接来源于英文单词queue，意为人员或物体的队列。queue容器定义在<queue>中，提供标准的先进先出（FIFO）语义。queue是一种容器，可以在一端插入元素，从另一端取出元素。元素的插入（摊销常数时间）和删除（常数时间）都很快。

想要模拟现实生活中的“先来先服务”语义时，应该使用queue结构。例如，考虑一个银行。顾客到达银行时，他们会排队。当出纳员空闲时，他们会服务队列前面的下一个顾客，从而提供“先来先服务”的行为。可以通过在queue中存储顾客对象来实现银行模拟。当顾客到达银行时，他们添加到队列的末尾。当出纳员服务顾客时，从队列的前面开始服务。

\mySamllsection{priority\_queue}

priority\_queue也在<queue>中定义，提供具有优先级的队列功能。元素按优先级从队列中移除。优先级相同的情况下，元素移除的顺序是不确定的。priority\_queue的插入和删除通常比简单queue的插入和删除慢，因为必须重新排序以支持优先级顺序。可以使用priority\_queues来模拟“带有例外的队列”。例如，在前面提到的银行模拟中，假设商业账户的顾客优先于普通顾客。

许多现实生活中的银行通过两个独立的队列实现这种行为：一个用于商业客户，另一个用于其他所有人，商业队列中的客户都会在其他人之前服务。然而，银行也可以通过一个队列实现这种行为，其中商业客户会跳到队列前面，优先于非商业客户。在程序中，可以使用一个priority\_queue，其中顾客具有两个优先级之一：商业或普通客户。所有商业客户都会在所有普通客户之前接受服务。

\mySamllsection{stack}

<stack>定义了stack类，提供标准的先进后出（FILO）语义，也称为后进先出（LIFO）。与queue一样，元素可插入和移除。但在stack中，最后插入的元素是第一个移除的。stack的名字来源于将这种结构可视化为一个堆叠的对象，其中只有顶部的对象是可见的。当向stack中添加一个对象时，会隐藏它下面的所有对象。

stack容器提供快速（常数时间）的元素插入和删除。当需要FILO语义时，应该使用stack结构。例如，一个错误处理工具可能希望将错误存储在stack上，以便最 recent的错误是第一个可供人类管理员阅读的。以FILO顺序处理错误通常很有用，因为较新的错误有时会使较旧的错误变得无关紧要。

\begin{myNotic}{NOTE}
queue、priority\_queue和stack是容器适配器，是建立在标准顺序容器vector、list或deque上的简单接口。
\end{myNotic}

\mySamllsection{有序关联容器}

标准库提供了四个有序关联容器：set、multiset、map和multimap。它们被称为排序或有序关联容器，因为它们对元素进行排序。

\mySamllsection{set}

set类模板定义在<set>中，它是一组元素，松散地类似于数学集合的概念：每个元素都是唯一的，集合中至多有一个该元素的实例。数学集合概念中的set与标准库中实现的set之间的一个区别在于，标准库中的元素保持顺序。保持顺序的原因是，顺序可以大大加快验证某个元素是否已存在于set中的速度。当客户端枚举元素时，将按照类型操作符operator<或用户定义的比较器所施加的顺序出现。set提供对数插入、删除和查找。所以，从理论上讲，插入和删除比vector快，但比list慢；而查找比list快，但比vector慢。与往常一样，可以使用分析器来确定哪个容器更快。

当需要元素保持顺序，插入/删除和查找的数量相等，并且希望尽可能优化两者的性能时，可以使用set。例如，繁忙书店中的库存跟踪程序可能希望使用set来存储书籍。库存中的书籍列表必须在书籍到达或售出时更新，因此插入和删除应该很快。客户还需要能够查找特定书籍，因此程序应该提供快速查找。

set中的元素不能被修改，因为这可能会使元素的顺序无效。如果需要更改一个元素，首先删除该元素，然后插入一个具有新值的元素。

\begin{myNotic}{NOTE}
如果需要顺序，并且希望在插入、删除和查找方面具有相同的性能，set可以作为vector或list的候选。需要强制不包含重复元素的话，set也是可以选择使用的。
\end{myNotic}

set不允许重复元素，set中的每个元素必须唯一。

\mySamllsection{multiset}

multiset类模板也在<set>中定义，除了可以存储重复元素外，几乎与set相同。

\mySamllsection{map}

<map>定义了map类模板，是一个关联数组。可以使用它作为一个数组，其索引可以是任何类型，例如字符串。map存储键/值对，并保持其元素按键排序，而不是按值排序。它还提供了一个operator[](set不提供)。其他方面，map与set几乎相同。当想要关联键和值时，可以使用map。例如，在之前提到的书店示例中，可能希望将书籍存储在map中，其中键是书籍的ISBN号，值是一个包含特定书籍详细信息的Book对象。

\mySamllsection{multimap}

<map>还定义了multimap类模板，它与map几乎相同，只是multimap可以存储具有重复键的元素。

\begin{myNotic}{NOTE}
set、multiset、map和multimap容器称为关联容器，它们关联键和值。当应用于set和multiset时，这个术语可能有些令人困惑，对于这些容器，键本身就是值。
\end{myNotic}

\mySamllsection{无序关联容器/哈希表}

标准库支持哈希表，也称为无序关联容器。有四种无序关联容器：

\begin{itemize}
\item
unordered\_map 和 unordered\_multimap

\item
unordered\_set 和 unordered\_multiset
\end{itemize}

前两个容器定义在<unordered\_map>中，而后两个定义在<unordered\_set>中。更好的名字可能是hash\_map、hash\_set等。但在C++11之前，哈希表不是C++标准库的一部分，所以许多第三方库自己实现了带有“hash”前缀的名称，如hash\_map。因此，C++标准委员会决定使用“unordered”，而不是“hash”作为前缀，以避免名称冲突。

这些无序关联容器的行为与它们的有序对应物类似。unordered\_map类似于标准map，只是标准map对其元素进行排序，而unordered\_map不对其元素进行排序。

这些无序关联容器的插入、删除和查找平均可以在常数时间内完成。最坏的情况下，是线性时间。在无序容器中查找元素可以比在普通map或set中快得多，尤其是当容器中有许多元素时。

第18章介绍了这些无序关联容器的工作原理，以及为什么它们称为哈希表。

\mySamllsection{平面关联容器适配器}

\CXXTwentythreeLogo{-40}{5}

C++23引入了四个平面关联容器适配器：

\begin{itemize}
\item
flat\_map和flat\_multimap定义在<flat\_map>中

\item
flat\_set和flat\_multiset定义在<flat\_set>中
\end{itemize}

这些是建立在顺序容器之上的适配器，提供关联容器接口。适配的顺序容器必须支持随机访问迭代器，如vector和deque。flat\_map和flat\_multimap适配器需要两个底层顺序容器，一个存储键，另一个存储值。flat\_set和flat\_multiset只需要一个底层顺序容器来存储它们的键。

这些适配器提供的接口，几乎与它们的有序对应关联容器的接口相同。唯一的区别是，flat适配器不提供与节点相关的成员函数，因为flat适配器不是基于节点的数据结构。除此之外，它们可以立即替换它们的有序对应物。

第18章提供了关于这些平面关联容器适配器的更多细节。

\mySamllsection{bitset}

C和C++开发者通常使用单个int或long来存储一组标志，每个标志使用一个位。位是通过位运算符：\&、|、\^{}、~、<{}<和>{}>进行设置和访问的。C++标准库提供了一个bitset类，其抽象了这种位字段操作，因此不需要再使用位操作符来处理此类情况。

定义了bitset容器，但这不是传统意义上的容器，因为它不实现一个特定的数据结构，可以在其中插入和删除元素。bitset具有固定大小，可以将其视为一个布尔值的序列，可以读取和写入。然而，与C风格处理位的方式不同，bitset不受int或其他基本数据类型的大小限制。因此，可以有一个40位的bitset或一个213位的bitset。当声明bitset<N>时，实现将使用所需存储来实现N位。

\mySamllsection{标准库容器的总结}

以下表格总结了标准库提供的容器，使用第4章中介绍的大O记号来展示对N个元素的容器的性能特征。表格中的N/A表示该操作不是容器语义的一部分：

% Please add the following required packages to your document preamble:
% \usepackage{multirow}
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|llll|}
\hline
\textbf{名称} &
\multicolumn{1}{l|}{\textbf{类型}} &
\multicolumn{1}{l|}{\textbf{\begin{tabular}[c]{@{}l@{}}插入时间\end{tabular}}} &
\multicolumn{1}{l|}{\textbf{\begin{tabular}[c]{@{}l@{}}删除时间\end{tabular}}} &
\textbf{\begin{tabular}[c]{@{}l@{}}查找时间\end{tabular}} \\ \hline
\endfirsthead
%
\endhead
%
\multirow{2}{*}{vector} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Amortized O(1)\\ at the end; O(N)\\ otherwise.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the end;\\ O(N) otherwise.\end{tabular}} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: This should be your default container. Only use another\\ container after using a profiler to confirm it is faster than a vector.\end{tabular}} \\ \hline
\multirow{2}{*}{list} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the beginning\\ and the end, and\\ once you are at the\\ position where you\\ want to insert the\\ element.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning and\\ the end, and\\ once you are\\ at the position\\ where you want\\ to delete the\\ element.\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}O(1) to\\ access the\\ first or last\\ element; O(N)\\ otherwise.\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: Rarely. You should use a vector, unless a profiler tells you a\\ list is faster for your use case.\end{tabular}} \\ \hline
\multirow{2}{*}{forward\_list} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning, and\\ once you are at the\\ position where you\\ want to insert the\\ element.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning, and\\ once you are\\ at the position\\ where you want\\ to delete the\\ element.\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}O(1) to access\\ the first\\ element; O(N)\\ otherwise.\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: Rarely. You should use a vector, unless a profiler tells you a\\ forward\_list is faster for your use case.\end{tabular}} \\ \hline
\multirow{2}{*}{deque} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning or end;\\ O(N) otherwise.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning or end;\\ O(N) otherwise.\end{tabular}} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: Not usually needed; use a vector instead.} \\ \hline
\multirow{2}{*}{array} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{N/A} &
\multicolumn{1}{l|}{N/A} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you need a fixed-size array to replace a standard C-style\\ array.\end{tabular}} \\ \hline
\multirow{2}{*}{queue} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on the\\ underlying container;\\ O(1) for list and\\ deque.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on\\ the underlying\\ container; O(1)\\ for list and\\ deque.\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a FIFO structure.} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}priority\_\\ queue\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on the\\ underlying container;\\ amortized O(log(N))\\ for vector,\\ O(log(N)) for deque.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on\\ the underlying\\ container;\\ O(log(N)) for\\ vector and\\ deque.\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a queue with priority.} \\ \hline
\multirow{2}{*}{stack} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on the\\ underlying container;\\ O(1) for list and\\ deque, amortized\\ O(1) for vector.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on\\ the underlying\\ container; O(1)\\ for list, vector,\\ and deque.\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a FILO/LIFO structure.} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}set\\ multiset\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Sorted\\ associative\end{tabular}} &
\multicolumn{1}{l|}{O(log(N))} &
\multicolumn{1}{l|}{O(log(N))} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection of elements with equal\\ lookup, insertion, and deletion times. Use a set when you want a collection of\\ elements without duplicates.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}map\\ multimap\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Sorted\\ associative\end{tabular}} &
\multicolumn{1}{l|}{O(log(N))} &
\multicolumn{1}{l|}{O(log(N))} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection to associate keys with\\ values, that is, an associative array, with equal lookup, insertion, and deletion\\ times.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}unordered\_map\\ unordered\_\\ multimap\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Unordered\\ associative /\\ hash table\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case O(1);\\ worst case O(N).\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst case\\ O(N).\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst\\ case O(N).\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want to associate keys with values with equal\\ lookup, insertion, and deletion times, and you don’t require the elements\\ to be sorted. Performance can be better than with a normal map, but that\\ depends on the elements.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}unordered\_set\\ unordered\_\\ multiset\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Unordered\\ associative/\\ hash table\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case O(1);\\ worst case O(N).\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst case\\ O(N).\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst\\ case O(N).\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a collection of elements with equal lookup,\\ insertion, and deletion times, and you don’t require the elements to be\\ sorted. Performance can be better than with a normal set, but that depends\\ on the elements.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}flat\_set\\ flat\_multiset\\ (C++23)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Flat set\\ associative\\ container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{O(N)} &
\multicolumn{1}{l|}{O(N)} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection of elements. Because the\\ adapters use underlying sequential containers that have very cache-friendly\\ memory layout, the performance is often better than the corresponding\\ ordered container.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}flat\_map\\ flat\_multimap\\ (C++23)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Flat map\\ associative\\ container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{O(N)} &
\multicolumn{1}{l|}{O(N)} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection to associate keys with\\ values. Because the adapters use underlying sequential containers that have\\ very cache-friendly memory layout, the performance is often better than the\\ corresponding ordered container.\end{tabular}} \\ \hline
\multirow{2}{*}{bitset} &
\multicolumn{1}{l|}{Special} &
\multicolumn{1}{l|}{N/A} &
\multicolumn{1}{l|}{N/A} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a collection of flags.} \\ \hline
\end{longtable}

Note that strings are technically containers as well. Thus, some of the algorithms described in the material that follows also work on strings.

\begin{myNotic}{NOTE}
vector should be your default container! In practice, insertion and deletion in a vector are often faster than in a list or forward\_list. This is because of how memory and caches work on modern CPUs and because of the fact that for a list or forward\_list, you first need to iterate to the position where you want to insert or delete an element. Memory for a list or forward\_list might be fragmented, so iteration is much slower than for a vector.
\end{myNotic}

\mySubsubsection{16.2.25.}{Algorithms}

In addition to containers, the Standard Library provides implementations of many generic algorithms. An algorithm is a strategy for performing a particular task, such as sorting or searching. These algorithms are implemented as function templates, so they work on most of the different container types. Note that the algorithms are not generally part of the containers. The Standard Library takes the approach of separating the data (containers) from the functionality (algorithms). Although this approach seems counter to the spirit of object-oriented programming, it is necessary in order to support generic programming in the Standard Library. The guiding principle of orthogonality maintains that algorithms and containers are independent, with (almost) any algorithm working with (almost) any container.

\begin{myNotic}{NOTE}
Although the algorithms and containers are theoretically independent, some containers provide certain algorithms in the form of class member functions because the generic algorithms do not perform well on those particular containers. For example, set provides its own find() algorithm that is faster than the generic find() algorithm. You should use the container-specific member function form of an algorithm, if provided, because it is generally more efficient or appropriate for the container at hand.
\end{myNotic}

Note that the generic algorithms do not work directly on containers; instead, they either use iterators or work on ranges, both discussed in detail in Chapter 17, “Understanding Iterators and the Ranges Library.”

This section gives an overview of what kinds of algorithms are available in the Standard Library without going into detail. Chapter 20, “Mastering Standard Library Algorithms,” discusses a selection of algorithms with coding examples. For the exact prototypes of all the available algorithms, consult your favorite Standard Library reference.

There are more than 100 algorithms in the Standard Library. The following sections divide these algorithms into different categories. The algorithms are defined in <algorithm> unless otherwise noted. Note that whenever the following algorithms are specified as working on a “sequence” of elements, that sequence is presented to the algorithm via iterators.

\begin{myNotic}{NOTE}
When examining the list of algorithms, remember that the Standard Library is designed with generality in mind, so it adds generality that might never be used but that, if required, would be essential. You may not need every algorithm or need to worry about the more obscure parameters that are there for anticipated generality. It is important only to be aware of what’s available in case you ever find it useful.
\end{myNotic}

\mySamllsection{Non-modifying Sequence Algorithms}

The non-modifying algorithms are those that look at a sequence of elements and return some information about the elements. As “non-modifying” algorithms, they cannot change the values of elements or the order of elements within the sequence. This category contains three types of algorithms: searching, comparing, and counting. The following sections briefly summarize the various nonmodifying algorithms. With these algorithms, you should rarely need to write a for loop to iterate over a sequence of values.

\mySamllsection{Searching Algorithms}

These algorithms do not require the sequence to be sorted. N is the size of the sequence to search in, and M is the size of the pattern to find:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME}     & \textbf{SYNOPSIS}                                                                                               & \textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
adjacent\_find() &
\begin{tabular}[c]{@{}l@{}}Finds the first instance of two consecutive elements that\\ are equal to each other or are equivalent to each other as\\ specified by a predicate.\end{tabular} &
O(N) \\ \hline
\begin{tabular}[c]{@{}l@{}}find()\\ find\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Finds the first element that matches a value or causes a\\ predicate to return true.\end{tabular} &
O(N) \\ \hline
find\_first\_of() & \begin{tabular}[c]{@{}l@{}}Like find, but searches for one of several elements at the\\ same time.\end{tabular} & O(N*M)              \\ \hline
find\_if\_not()   & \begin{tabular}[c]{@{}l@{}}Finds the first element that causes a predicate to return\\ false.\end{tabular}      & O(N)                \\ \hline
find\_end() &
\begin{tabular}[c]{@{}l@{}}Finds the last subsequence in a sequence that matches\\ another sequence or whose elements are equivalent, as\\ specified by a predicate.\end{tabular} &
O(M*(N-M)) \\ \hline
search() &
\begin{tabular}[c]{@{}l@{}}Finds the first subsequence in a sequence that matches\\ another sequence or whose elements are equivalent, as\\ specified by a predicate$^{1}$.\end{tabular} &
O(N*M)$^{1}$ \\ \hline
search\_n() &
\begin{tabular}[c]{@{}l@{}}Finds the first instance of n consecutive elements that are\\ equal to a given value or relate to that value according to\\ a predicate.\end{tabular} &
O(N) \\ \hline
\end{longtable}

$^{1}$search() accepts an optional extra parameter to specify the searching algorithm to use (default\_searcher, boyer\_moore\_searcher, or boyer\_moore\_horspool\_searcher). With the Boyer–Moore searchers, the worst-case complexity is O(N+M) when the pattern is not found, and O(N*M) when the pattern is found.

\mySamllsection{Comparison Algorithms}

The following comparison algorithms are provided. None of them requires the source sequences to be ordered. All of them have a linear worst-case complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
equal() &
\begin{tabular}[c]{@{}l@{}}Determines whether two sequences are equal by\\ checking whether parallel elements are equal or\\ match a predicate.\end{tabular} \\ \hline
mismatch() &
\begin{tabular}[c]{@{}l@{}}Returns the first element in each sequence that\\ does not match the element in the same location\\ in the other sequence.\end{tabular} \\ \hline
lexicographical\_compare() &
\begin{tabular}[c]{@{}l@{}}Compares two sequences to determine their\\ “lexicographical” ordering. This algorithm\\ compares each element of the first sequence\\ with its equivalent element in the second. If one\\ element is less than the other, that sequence is\\ lexicographically first. If the elements are equal, it\\ compares the next elements in order.\end{tabular} \\ \hline
lexicographical\_compare\_three\_way() &
\begin{tabular}[c]{@{}l@{}}Compares two sequences to determine their\\ “lexicographical” ordering using three-way\\ comparisons and returns a comparison category\\ type (strong\_ordering, weak\_ordering, or\\ partial\_ordering).\end{tabular} \\ \hline
all\_of() &
\begin{tabular}[c]{@{}l@{}}Returns true if a given predicate returns true\\ for all the elements in the sequence or if the\\ sequence is empty; false otherwise.\end{tabular} \\ \hline
any\_of() &
\begin{tabular}[c]{@{}l@{}}Returns true if a given predicate returns true\\ for at least one element in the sequence; false\\ otherwise.\end{tabular} \\ \hline
none\_of() &
\begin{tabular}[c]{@{}l@{}}Returns true if a given predicate returns false\\ for all the elements in the sequence or if the\\ sequence is empty; false otherwise.\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Counting Algorithms}

The following counting algorithms are available. None of them requires the source sequences to be ordered. All of them have a linear worst-case complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}count()\\ count\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Counts the number of elements matching a value or that cause a predicate to\\ return true.\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Modifying Sequence Algorithms}

The modifying algorithms modify some or all of the elements in a sequence. Some of them modify elements in place so that the original sequence changes. Others copy the results to a different sequence so that the original sequence remains unchanged. All of them have a linear worst-case complexity. The following table summarizes the modifying algorithms:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}copy()\\ copy\_backward()\end{tabular} &
Copies elements from one sequence to another. \\ \hline
copy\_if() &
\begin{tabular}[c]{@{}l@{}}Copies elements for which a predicate returns true from one sequence\\ to another\end{tabular} \\ \hline
copy\_n() &
Copies n elements from one sequence to another. \\ \hline
fill() &
Sets all elements in the sequence to a new value. \\ \hline
fill\_n() &
Sets the first n elements in the sequence to a new value. \\ \hline
generate() &
\begin{tabular}[c]{@{}l@{}}Calls a given function to generate a new value for each element in the\\ sequence.\end{tabular} \\ \hline
generate\_n() &
\begin{tabular}[c]{@{}l@{}}Calls a given function to generate a new value for the first n elements in\\ the sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}move()\\ move\_backward()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Moves elements from one sequence to another using efficient move\\ semantics (see Chapter 9).\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}remove()\\ remove\_if()\\ remove\_copy()\\ remove\_copy\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Removes all elements that match a given value or that cause a predicate\\ to return true, either in place or by copying the results to a different\\ sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}replace()\\ replace\_if()\\ replace\_copy()\\ replace\_copy\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Replaces all elements matching a value or that cause a predicate to\\ return true with a new element, either in place or by copying the results\\ to a different sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}reverse()\\ reverse\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Reverses the order of the elements in the sequence, either in place or by\\ copying the results to a different sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}rotate()\\ rotate\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Swaps the first and second “halves” of the sequence, either in place or\\ by copying the results to a different sequence. The two subsequences to\\ be swapped need not be equal in size.\end{tabular} \\ \hline
sample() &
Selects n random elements from the sequence. \\ \hline
\begin{tabular}[c]{@{}l@{}}shift\_left()\\ shift\_right()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Shifts the elements in a sequence left or right by a given number of\\ positions. Elements are moved to their new position. Elements that fall\\ of either end of the sequence are removed. shift\_left() returns an\\ iterator to the end of the new sequence; shift\_right() returns an\\ iterator to the beginning of the new sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}shuffle()\\ random\_shuffle()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Shuffles the sequence by randomly reordering the elements. It is\\ possible to specify the properties of the random number generator used\\ for shuffling. random\_shuffle() is deprecated since C++14, and is\\ removed starting with C++17.\end{tabular} \\ \hline
transform() &
\begin{tabular}[c]{@{}l@{}}Calls a unary function on each element of a sequence or a binary function\\ on parallel elements of two sequences, and stores the results in a\\ destination sequence. If the source and destination sequences are the\\ same, the transformation happens in-place.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}unique()\\ unique\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Removes consecutive duplicates from the sequence, either in place or by\\ copying results to a different sequence.\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Operational Algorithms}

Operational algorithms execute a function on individual elements of a sequence. There are two operational algorithms provided. Both have a linear complexity and do not require the source sequence to be ordered:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
for\_each() &
\begin{tabular}[c]{@{}l@{}}Executes a function on each element in the sequence. The sequence is\\ specified with a begin and end iterator.\end{tabular} \\ \hline
for\_each\_n() &
\begin{tabular}[c]{@{}l@{}}Similar to for\_each() but only processes the first n elements in the sequence.\\ The sequence is specified by a begin iterator and a number of elements (n).\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Swap Algorithms}

The C++ Standard Library provides the following swap algorithms:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME}                                                         & \textbf{SYNOPSIS}                            \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}iter\_swap()\\ swap\_ranges()\end{tabular} & Swaps two elements or sequences of elements. \\ \hline
\end{longtable}

\mySamllsection{Partitioning Algorithms}

A sequence is partitioned on a certain predicate, if all elements for which the predicate returns true are before all elements for which it returns false. The first element in the sequence that does not satisfy the predicate is called the partition point. The Standard Library provides the following partition algorithms:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_partitioned() &
\begin{tabular}[c]{@{}l@{}}Returns true if all elements for which a predicate\\ returns true are before all elements for which it\\ returns false.\end{tabular} &
Linear \\ \hline
partition() &
\begin{tabular}[c]{@{}l@{}}Sorts the sequence such that all elements for which\\ a predicate returns true are before all elements for\\ which it returns false, without preserving the original\\ order of the elements within each partition.\end{tabular} &
Linear \\ \hline
stable\_partition() &
\begin{tabular}[c]{@{}l@{}}Sorts the sequence such that all elements for which\\ a predicate returns true are before all elements for\\ which it returns false, while preserving the original\\ order of the elements within each partition.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
partition\_copy() &
\begin{tabular}[c]{@{}l@{}}Copies elements from one sequence to two different\\ sequences. The target sequence is selected based on\\ the result of a predicate, either true or false.\end{tabular} &
Linear \\ \hline
partition\_point() &
\begin{tabular}[c]{@{}l@{}}Returns an iterator such that all elements before this\\ iterator return true for a predicate and all elements\\ after this iterator return false for that predicate.\end{tabular} &
Logarithmic \\ \hline
\end{longtable}

\mySamllsection{Sorting Algorithms}

The Standard Library provides several different sorting algorithms with varying performance guarantees:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_sorted() &
\begin{tabular}[c]{@{}l@{}}Returns true if a sequence is sorted, false\\ otherwise.\end{tabular} &
Linear \\ \hline
is\_sorted\_until() &
\begin{tabular}[c]{@{}l@{}}Finds the largest sorted subrange starting at the\\ beginning of the given range of elements.\end{tabular} &
Linear \\ \hline
nth\_element() &
\begin{tabular}[c]{@{}l@{}}Relocates the $n^{th}$ element of the sequence such that\\ the element in the position pointed to by $n^{th}$  is the\\ element that would be in that position if the whole\\ range were sorted, and it rearranges all elements\\ such that all elements preceding the $n^{th}$  element are\\ less than the new $n^{th}$  element, and the ones following\\ it are greater than the new $n^{th}$  element.\end{tabular} &
Linear \\ \hline
\begin{tabular}[c]{@{}l@{}}partial\_sort()\\ partial\_sort\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Partially sorts the sequence: the first n elements\\ (specified by iterators) are sorted; the rest are not.\\ They are sorted either in place or by copying them to\\ a new sequence.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}stable\_sort()\\ sort()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Sorts elements in place, either preserving the order\\ of duplicate elements (stable) or not.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Binary Search Algorithms}

The following binary search algorithms are normally used on sorted sequences. Technically, they only require the sequence to be at least partitioned on the element that is searched for. This could, for example, be achieved by applying std::partition(). A sorted sequence also meets this requirement. All these algorithms have logarithmic complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME}    & \textbf{SYNOPSIS}                                                      \\ \hline
\endfirsthead
%
\endhead
%
lower\_bound() & \begin{tabular}[c]{@{}l@{}}Finds the first element in a sequence not less than (that is, greater or equal\\ to) a given value.\end{tabular} \\ \hline
upper\_bound()   & Finds the first element in a sequence greater than a given value.      \\ \hline
equal\_range() & \begin{tabular}[c]{@{}l@{}}Returns a pair containing the result of both lower\_bound() and\\ upper\_bound().\end{tabular}                   \\ \hline
binary\_search() & Returns true if a given value is found in a sequence; false otherwise. \\ \hline
\end{longtable}

\mySamllsection{Set Algorithms on Sorted Sequences}

Set algorithms are special modifying algorithms that perform set operations on sequences. They are most appropriate on sequences from set containers, but work on sorted sequences from most containers:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
includes() &
\begin{tabular}[c]{@{}l@{}}Determines whether every element from\\ one sorted sequence is in another sorted\\ sequence.\end{tabular} &
Linear \\ \hline
\begin{tabular}[c]{@{}l@{}}set\_union()\\ set\_intersection()\\ set\_difference()\\ set\_symmetric\_difference()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Performs the specified set operation on\\ two sorted sequences, copying results to a\\ third sorted sequence.\end{tabular} &
Linear \\ \hline
\end{longtable}

\mySamllsection{Other Algorithms on Sorted Sequences}

The Standard Library provides the following additional algorithms that work on sorted sequences:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
inplace\_merge() &
Merges two sorted sequences in place. &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
merge() &
\begin{tabular}[c]{@{}l@{}}Merges two sorted sequences by copying them to a new\\ sequence.\end{tabular} &
Linear \\ \hline
\end{longtable}

\mySamllsection{Heap Algorithms}

A heap is a standard data structure in which the elements of an array or sequence are ordered in a semi-sorted fashion so that finding the “top” element is quick. For example, a heap data structure is typically used to implement a priority\_queue. Six algorithms allow you to work with heaps:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_heap() &
\begin{tabular}[c]{@{}l@{}}Returns true if a range of elements is a heap, false\\ otherwise.\end{tabular} &
Linear \\ \hline
is\_heap\_until() &
\begin{tabular}[c]{@{}l@{}}Finds the largest subrange that is a heap, starting at the\\ beginning of the given range of elements.\end{tabular} &
Linear \\ \hline
make\_heap() &
Creates a heap from a range of elements. &
Linear \\ \hline
\begin{tabular}[c]{@{}l@{}}push\_heap()\\ pop\_heap()\end{tabular} &
Adds an element to, or removes an element from, a heap. &
Logarithmic \\ \hline
sort\_heap() &
\begin{tabular}[c]{@{}l@{}}Converts a heap into a range of ascending sorted\\ elements.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Minimum/Maximum Algorithms}

The following algorithms are provided to find minimum and maximum elements and to clamp values:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME}                                                           & \textbf{SYNOPSIS}                                                \\ \hline
\endfirsthead
%
\endhead
%
clamp() &
\begin{tabular}[c]{@{}l@{}}Makes sure a value (v) is between a given minimum (lo) and maximum\\ (hi). Returns a reference to lo if v \textless lo; returns a reference to hi if v \textgreater hi;\\ otherwise returns a reference to v.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}min()\\ max()\end{tabular}                   & Returns the minimum or maximum of two or more values.            \\ \hline
minmax()                                                                & Returns the minimum and maximum of two or more values as a pair. \\ \hline
\begin{tabular}[c]{@{}l@{}}min\_element()\\ max\_element()\end{tabular} & Returns the minimum or maximum element in a sequence.            \\ \hline
minmax\_element()                                                       & Returns the minimum and maximum element in a sequence as a pair. \\ \hline
\end{longtable}


\mySamllsection{Numerical Processing Algorithms}

The following numerical processing algorithms are defined in <numeric>. None of them require the source sequences to be ordered. All of them have a linear complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
iota() &
\begin{tabular}[c]{@{}l@{}}Fills a sequence with successively incrementing values starting\\ with a given value.\end{tabular} \\ \hline
adjacent\_difference() &
\begin{tabular}[c]{@{}l@{}}Generates a new sequence in which each element is the\\ difference (or other binary operation) of the second and first\\ of each adjacent pair of elements in the source sequence.\end{tabular} \\ \hline
partial\_sum() &
\begin{tabular}[c]{@{}l@{}}Generates a new sequence in which each element is the sum\\ (or other binary operation) of an element and all its preceding\\ elements in the source sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}exclusive\_scan()\\ inclusive\_scan()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}These are similar to partial\_sum(). An inclusive scan is\\ identical to a partial sum if the given summation operation\\ is associative. However, inclusive\_scan() sums in a\\ nondeterministic order, while partial\_sum() left to right,\\ so for nonassociative summation operations the result of\\ the former is nondeterministic. The exclusive\_scan()\\ algorithm also sums in a nondeterministic order.\\ For inclusive\_scan(), the $i^{th}$ element is included in the $i^{th}$\\ sum, just as for partial\_sum(). For exclusive\_scan(), the\\ $i^{th}$ element is not included in the ith sum.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}transform\_exclusive\_scan()\\ transform\_inclusive\_scan()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Applies a transformation to each element in a sequence, then\\ performs an exclusive/inclusive scan.\end{tabular} \\ \hline
accumulate() &
\begin{tabular}[c]{@{}l@{}}“Accumulates” the values of all the elements in a sequence.\\ The default behavior is to sum the elements, but the caller\\ can supply a different binary function instead.\end{tabular} \\ \hline
inner\_product() &
\begin{tabular}[c]{@{}l@{}}Similar to accumulate(), but works on two sequences. This\\ algorithm calls a binary function (multiplication by default) on\\ parallel elements in the sequences, accumulating the result\\ using another binary function (addition by default). If the\\ sequences represent mathematical vectors, the algorithm\\ calculates the dot product of the vectors.\end{tabular} \\ \hline
reduce() &
\begin{tabular}[c]{@{}l@{}}Similar to accumulate(), but supports parallel execution.\\ The order of evaluation for reduce() is nondeterministic,\\ while it’s from left to right for accumulate(). This means that\\ the behavior of the former is nondeterministic if the given\\ binary operation is not associative or not commutative.\end{tabular} \\ \hline
transform\_reduce() &
\begin{tabular}[c]{@{}l@{}}Applies a transformation to each element in a sequence, then\\ performs a reduce().\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Permutation Algorithms}

A permutation of a sequence contains the same elements but in a different order. The following algorithms are provided to work with permutations:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_permutation() &
\begin{tabular}[c]{@{}l@{}}Returns true if the elements in one range are a\\ permutation of the elements in another range.\end{tabular} &
Quadratic \\ \hline
\begin{tabular}[c]{@{}l@{}}next\_permutation()\\ prev\_permutation()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Modifies the sequence by transforming it into its “next”\\ or “previous” lexicographical permutation. Successive\\ calls to one or the other will permute the sequence into\\ all possible permutations of its elements, if you start\\ with a properly sorted sequence. This algorithm returns\\ false if no more permutations exist.\end{tabular} &
Linear \\ \hline
\end{longtable}

\mySamllsection{Choosing an Algorithm}

The number and capabilities of the algorithms might overwhelm you at first. It can be difficult to see how to apply them in the beginning. However, now that you have an idea of the available options, you are better able to tackle your program designs. The following chapters cover the details of how to use these algorithms in your code.



\mySubsubsection{16.2.26.}{Ranges Library}

The ranges library makes it easier and more elegant to work with sequences of elements. Ranges provide nicer and easier-to-read syntax and eliminate the possibility of mismatching begin/end iterators. Additionally, range adapters allow you to lazily transform and filter underlying sequences, and range factories are provided to build up ranges.

Most algorithms discussed in the previous sections have variants that work with ranges in addition to iterators. Those variants are often called range-based algorithms or constrained algorithms because they have proper template type parameter constraints in the form of concepts. This allows the compiler to issue better error messages if such a constrained algorithm is used wrongly.

Additionally, C++23 introduces the following algorithms that are available only in a constrained variant. All of them have a linear complexity.

\CXXTwentythreeLogo{-40}{-50}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}contains()\\ contains\_subrange()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Returns true if a given range contains a given value,\\ respectively, a given subrange, false otherwise.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}starts\_with()\\ ends\_with()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Returns true if a given range starts, respectively, ends with\\ another given range, false otherwise.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}find\_last()\\ find\_last\_if()\\ find\_last\_if\_not()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Finds the last element in a given range that either matches\\ a given value, or for which a given predicate returns true,\\ or for which a given predicate returns false. The result is a\\ subrange starting at the found element until the end of the\\ range.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}fold\_left()\\ fold\_left\_first()\\ fold\_right()\\ fold\_right\_last()\\ fold\_left\_with\_iter()\\ fold\_left\_first\_with\_iter()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Folds the elements of a given range left or right. fold\_\\ left() and fold\_right() accept an initial value as one of\\ their arguments, and return the result of the fold operation.\\ fold\_left\_first() uses the first element in a given range\\ as the starting value, while fold\_right\_last() uses the\\ last element in a given range as the starting value. Both\\ of these return an optional containing the result, or an\\ empty optional if applied to an empty range. The last two\\ variants return an instance of fold\_left\_with\_iter\_\\ result, respectively, fold\_left\_first\_with\_iter\_\\ result that you can use to inspect the result of the fold\\ operation.\end{tabular} \\ \hline
\end{longtable}

The ranges library is defined in <ranges> and lives in the std::ranges namespace. Chapter 17 discusses the ranges library, while Chapter 20 discusses unconstrained and constrained algorithms with coding examples.

\mySubsubsection{16.2.27.}{What’s Missing from the Standard Library}

The Standard Library is powerful, but it’s not perfect. Here are two examples of missing functionality:

\begin{itemize}
\item
The Standard Library does not guarantee any thread safety for accessing containers simultaneously from multiple threads.

\item
The Standard Library does not provide any generic tree or graph structures. Although map and set are generally implemented as balanced binary trees, the Standard Library does not expose this implementation in the interface. If you need a tree or graph structure for something like writing a parser, you need to implement your own or find an implementation in another library.
\end{itemize}

It is important to keep in mind that the Standard Library is extensible. You can write your own containers and algorithms that work with existing algorithms and containers. So, if the Standard Library doesn’t provide exactly what you need, consider writing your desired code such that it works with the Standard Library. Chapter 25 covers the topic of customizing and extending the Standard Library with custom algorithms and custom containers. Alternatively, you can consider buying or licensing a Standard Library-compliant third-party library that provides the required functionality. See Chapter 4, “Designing Professional C++ Programs,” for a discussion on using third-party libraries and licensing options.







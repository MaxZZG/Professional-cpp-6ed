
This section introduces the various components of the Standard Library from a design perspective.
You will learn what facilities are available for you to use, but you will not learn many coding details. Those details are covered in other chapters.

\mySubsubsection{16.2.1.}{Strings}

C++ provides a built-in string class, defined in <string>. This C++ string class is superior in almost every way compared to C-style strings of character arrays. It handles the memory management; provides some bounds checking, assignment semantics, and comparisons; and supports manipulations such as concatenation, substring extraction, and substring or character replacement.

\begin{myNotic}{NOTE}
Technically, std::string is a type alias for a char instantiation of the std::basic\_string class template. However, you need not worry about these details; you can use string as if it were a bona fide nontemplate class.
\end{myNotic}

The Standard Library also provides a string\_view class, defined in <string\_view>. It is a read-only view of any kind of string representation and can be used as a drop-in replacement for const string\&, but without the overhead. It never copies strings!

C++ provides support for Unicode and localization. Unicode allows you to write programs that work with text in different languages, such as Arabic, Chinese, Japanese, and so on. Locales, defined in <locale>, allow you to format data such as numbers and dates according to the rules of a certain country or region.

C++ includes a powerful type-safe string formatting library, accessed through std::format() and defined in <format>. The library is extensible and allows you to add support for your own custom types. C++23 adds helper functions std::print() and println() to make it easier to print formatted text to the console.

In case you missed it, Chapter 2, “Working with Strings and String Views,” provides all the details of the string and string\_view classes and the string formatting library, while Chapter 21, “String Localization and Regular Expressions,” discusses Unicode and localization.

\mySubsubsection{16.2.2.}{Regular Expressions}

Regular expressions are available through functionality provided by <regex>. They make it easy to perform pattern-matching, often used in text processing. Pattern-matching allows you to search for special patterns in strings and optionally to replace them with a new pattern. Regular expressions are discussed in Chapter 21.

\mySubsubsection{16.2.3.}{I/O Streams}

C++ includes a model for input and output called streams. The C++ library provides routines for reading and writing built-in types from and to files, console/keyboard, and strings. C++ also provides the facilities for coding your own routines for reading and writing your own objects. Most of the I/O functionality is defined in <fstream>, <iomanip>, <ios>, <iosfwd>, <iostream>, <istream>, <ostream>, <sstream>, <streambuf>, and <strstream>. C++23 introduces span-based streams, defined in <spanstream>. Chapter 1, “A Crash Course in C++ and the Standard Library,” reviews the basics of I/O streams, and Chapter 13, “Demystifying C++ I/O,” discusses streams in detail.

\mySubsubsection{16.2.4.}{Smart Pointers}

One of the problems faced in robust programming is knowing when to delete an object. There are several failures that can happen. A first problem is not deleting the object at all (failing to free the storage). These are known as memory leaks, where objects accumulate and take up space but are not used. Another problem is where a piece of code deletes the storage while another piece of code is still pointing to that storage, resulting in pointers to storage that either is no longer in use or has been reallocated for another purpose. These are known as dangling pointers. Yet another problem is when one piece of code frees the storage and another piece of code attempts to free the same storage again.
This is known as double deletion.

All of these problems tend to result in program failures of some sort. Some failures are readily detected and might crash your application; others cause the program to produce erroneous results.
Most of these errors are difficult to discover and repair.

C++ addresses all these problems with smart pointers: unique\_ptr, shared\_ptr, and weak\_ptr, all defined in <memory>. These smart pointers are discussed in Chapter 7, “Memory Management.”

\mySubsubsection{16.2.5.}{Exceptions}

The C++ language supports exceptions, which allow functions to pass errors of various types up to calling functions. The C++ Standard Library provides a class hierarchy of exceptions that you can use in your code as is, or that you can derive from to create your own exception types. Most of the exception support is defined in <exception>, <stdexcept>, and <system\_error>. Chapter 14, “Handling Errors,” covers the details of exceptions and the standard exception classes.

\mySubsubsection{16.2.6.}{Standard Integer Types}

The <cstdint> header file defines a number of standard integer types such as intx\_t and uintx\_t with x equal to 8, 16, 32, or 64. It also includes macros specifying minimum and maximum values of those types. These integer types are discussed in the context of writing cross-platform code in Chapter 34, “Developing Cross-Platform and Cross-Language Applications.”

\mySubsubsection{16.2.7.}{Numerics Library}

The C++ Standard Library provides a collection of mathematical utility classes and functions.

A whole range of common mathematical functions is available, such as abs(), remainder(), fma(), exp(), log(), pow(), sqrt(), sin(), atan2(), sinh(), erf(), tgamma(), ceil(), floor(), and more. The library also supports a number of mathematical special functions to work with Legendre polynomials, beta functions, elliptic integrals, Bessel functions, cylindrical Neumann functions, and so on. These special functions have established names and notations and are often used in mathematical analysis, functional analysis, geometry, physics, and other applications. The lerp() function calculates a linear interpolation or extrapolation: lerp(a,b,t) calculates a+t(b-a). Linear interpolation calculates a certain value between given data points, while extrapolation calculates values that are either lower or higher than the minimum or maximum data point. Most of these functions are defined in <cmath>, some in <cstdlib>.

<numeric> defines gcd() and lcm() that calculate the greatest common divisor and least common multiple of two integer types, respectively. The midpoint() function calculates the midpoint of two values (integers, floating-point numbers, or pointers).

Starting with C++23, quite a few of these functions are marked as constexpr (see Chapter 9), so they can be used to perform compile-time computations. Consult your favorite Standard Library reference to learn exactly which functions are constexpr.

There is a complex number class called complex, defined in <complex>, which provides an abstraction for working with numbers that contain both real and imaginary components.

The compile-time rational arithmetic library provides a ratio class template, defined in <ratio>.
This ratio class template can exactly represent any finite rational number defined by a numerator and denominator. This library is discussed in Chapter 22, “Date and Time Utilities.”

The Standard Library also contains a class called valarray, defined in <valarray>, which is similar to vector but is more optimized for high-performance numerical applications. The library provides several related classes to represent the concept of vector slices. From these building blocks, it is possible to build classes to perform matrix mathematics. There is no built-in matrix class; however, there are third-party libraries like Boost that include matrix support. The valarray class is not further discussed in this book.

A selection of often-used mathematical constants is available, all defined in <numbers> in the std::numbers namespace. Here are just a few of the available constants:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{CONSTANT} & \textbf{DESCRIPTION} & \textbf{APPROXIMATION} \\ \hline
\endfirsthead
%
\endhead
%
pi                & The value of pi (π)  & 3.141592653589793      \\ \hline
inv\_pi           & The inverse of pi    & 0.3183098861837907     \\ \hline
sqrt2             & The square root of 2 & 1.4142135623730951     \\ \hline
e                 & Euler’s number e     & 2.718281828459045      \\ \hline
phi               & The golden ratio     & 1.618033988749895      \\ \hline
\end{longtable}

\mySubsubsection{16.2.8.}{Integer Comparisons}



The following comparison functions are available: std::cmp\_equal(), cmp\_not\_equal(), cmp\_less(), cmp\_less\_equal(), cmp\_greater(), and cmp\_greater\_equal(), all defined in <utility>. These perform comparisons of two integers and are safe to use on mixed signed and unsigned comparisons.

For example, the following code compares the signed value -1 and the unsigned value 0u using operator>. The output is 1 (= true), because the -1 is first converted to an unsigned integer and hence becomes a big number such as 4,294,967,295, which is definitely greater than 0:

\begin{cpp}
println("{}", (-1 > 0u)); // true
\end{cpp}

Use cmp\_greater() to get the correct output:

\begin{cpp}
println("{}", cmp_greater(-1, 0u)); // false
\end{cpp}



\mySubsubsection{16.2.9.}{Bit Manipulation}

The Standard Library supports the following functions to work with bits, all defined in <bit>. All of these functions require an unsigned integral type as first argument:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{FUNCTION}  & \textbf{DESCRIPTION}                                                                                                                      \\ \hline
\endfirsthead
%
\endhead
%
has\_single\_bit() & \begin{tabular}[c]{@{}l@{}}Returns true if a given value contains only a single bit, that is, is an\\ integral power of two.\end{tabular} \\ \hline
bit\_ceil()        & \begin{tabular}[c]{@{}l@{}}Returns the smallest integral power of two greater than or equal to a\\ given value.\end{tabular}              \\ \hline
bit\_floor()       & \begin{tabular}[c]{@{}l@{}}Returns the largest integral power of two smaller than or equal to a given\\ value.\end{tabular}               \\ \hline
bit\_width()       & Returns the number of bits needed to store a given value.                                                                                 \\ \hline
\begin{tabular}[c]{@{}l@{}}rotl()\\ rotr()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Rotates the bits of a given value to the left or right respectively over a\\ given number of positions.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}countl\_zero()\\ countl\_one()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Returns the number of consecutive zero or one bits respectively in a given\\ value starting from the left, that is, starting with the most-significant bit.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}countr\_zero()\\ countr\_one()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Returns the number of consecutive zero or one bits, respectively, in\\ a given value starting from the right, that is, starting with the least\\ significant bit.\end{tabular} \\ \hline
popcount()         & Returns the number of one bits in a given value.                                                                                          \\ \hline
byteswap()(C++23)  & Reverses the individual bytes of integral types.                                                                                          \\ \hline
\end{longtable}

Here are a few examples:

\begin{cpp}
println("{}", popcount(0b10101010u)); // 4

uint8_t value { 0b11101011u };
println("{}", countl_one(value)); // 3
println("{}", countr_one(value)); // 2

value = 0b10001000u;
println("{:08b}", rotl(value, 2)); // 00100010

value = 0b00001011u;
println("bit_ceil({0:08b} = {0}) = {1:08b} = {1}",
    value, bit_ceil(value)); // bit_ceil(00001011 = 11) = 00010000 = 16
println("bit_floor({0:08b} = {0}) = {1:08b} = {1}",
    value, bit_floor(value)); // bit_floor(00001011 = 11) = 00001000 = 8

uint32_t before { 0x12345678u };
println("{:x}", before); // 12345678
uint32_t after { byteswap(before) }; // C++23 std::byteswap().
println("{:x}", after); // 78563412
\end{cpp}

\mySubsubsection{16.2.10.}{Time and Date Utilities}

The Standard Library includes the chrono library, defined in <chrono>. This library makes it easy to work with dates and time, to time certain durations, and more. The library supports calendars to work with dates, and time zones, including functionality to convert times between different time zones. The <ctime> header provides a number of C-style time and date utilities.

Chapter 22 discusses the time and date utilities in detail.

\mySubsubsection{16.2.11.}{Random Numbers}

C++ already has support for generating pseudo-random numbers for a long time with the srand() and rand() functions. However, those functions provide only low-quality basic random numbers. For example, you cannot change the distribution of the generated random numbers.

Since C++11, a powerful random number generation library is available. This library is defined in <random> and comes with random number engines, random number engine adapters, and random number distributions. These can be used to generate high-quality random numbers and support different distributions, such as normal distributions, negative exponential distributions, and so on.

Consult Chapter 23, “Random Number Facilities,” for details on this library.

\mySubsubsection{16.2.12.}{Initializer Lists}

Initializer lists are defined in <initializer\_list>. They make it easy to write functions that can accept a variable number of arguments and are discussed in Chapter 1.

\mySubsubsection{16.2.13.}{Pair and Tuple}

<utility> defines the pair class template, which can store two elements of possibly different types. This is known as storing heterogeneous elements. All Standard Library containers discussed further in this chapter store homogeneous elements, meaning that all the elements in the container must have the same type. A pair allows you to store exactly two elements of completely unrelated types in one object. The pair class template is introduced in Chapter 1.

tuple, defined in <tuple>, is a generalization of pair. It is a sequence with a fixed size that can have heterogeneous elements. The number and type of elements for a tuple instantiation is fixed at compile time. Tuples are discussed in Chapter 24, “Additional Vocabulary Types.”

\mySubsubsection{16.2.14.}{Vocabulary Types}

Vocabulary types are types that you will use all the time, just as much as primitive types such as int and double. Using vocabulary types makes your code safer, more efficient, and easier to write, read, and maintain. Examples of vocabulary types discussed earlier in this book are vector, optional, string, unique\_ptr, shared\_ptr, and so on.

Chapter 24 discusses the following additional vocabulary types:

\begin{itemize}
\item
variant, defined in <variant>, can hold a single value of one of a given set of types.

\item
any, defined in <any>, can hold a single value of any type.

\item
tuple, defined in <tuple>, is a generalization of pair. It can store any number of values, each with its own specific type.

\item
optional, defined in <optional>, holds a value of a specific type or nothing. It can be used for class data members, function parameters, return types of a function, and so on, if you want to allow for values to be optional. It is introduced in Chapter 1. Chapter 24 explains that optionals support monadic operations, allowing you to easily chain operations on optionals without having to worry whether an optional is empty before applying another operation to it.

\item
expected, defined in <expected>, holds a value of a specific type, or an error value of a, possibly different, type. This can be useful as the return type of a function because it allows the function to return either the requested data back to the caller or the reason why something went wrong.
\end{itemize}

\CXXTwentythreeLogo{-40}{30}

\mySubsubsection{16.2.15.}{Function Objects}

A class that implements a function call operator is called a function object. Function objects can, for example, be used as predicates for certain Standard Library algorithms. <functional> defines a number of predefined function objects and supports creating new function objects based on existing ones.

Function objects are discussed in detail in Chapter 19, “Function Pointers, Function Objects, and Lambda Expressions.”

\mySubsubsection{16.2.16.}{Filesystem}

Everything for the filesystem support library is defined in <filesystem> and lives in the std::filesystem namespace. It allows you to write portable code to work with a filesystem. You can use it for querying whether something is a directory or a file, iterating over the contents of a directory, manipulating paths, and retrieving information about files such as their size, extension, creation time, and so on. The filesystem support library is discussed in Chapter 13.

\mySubsubsection{16.2.17.}{Multithreading}

All major CPU vendors are selling processors with multiple cores. They are being used for everything from servers to consumer computers and even smartphones. If you want your software to take advantage of all these cores, then you need to write multithreaded code. The Standard Library provides a couple of basic building blocks for writing such code. Individual threads can be created using the thread class from <thread>. The library also defines jthread, a thread that can be cancelled and that automatically performs a join operation when it is destructed.

In multithreaded code you need to take care that several threads are not reading and writing to the same piece of data at the same time, because that will cause data races. To prevent this, you can use atomics, defined in <atomic>, which give you thread-safe atomic access to a piece of data. Other thread synchronization mechanisms are provided by <condition\_variable> and <mutex>. There is also support for the following synchronization primitives: semaphores (<semaphore>), latches (<latch>), and barriers (<barrier>).

If you just need to calculate something, possibly on a different thread, and get the result back with proper exception handling, you can use async and future. These are defined in <future> and are easier to use than directly using thread or jthread.

Writing multithreaded code is discussed in detail in Chapter 27, “Multithreaded Programming with C++.”

\mySubsubsection{16.2.18.}{Type Traits}

Type traits are defined in <type\_traits> and provide information about types at compile time. They are useful when writing advanced templates and are discussed in Chapter 26, “Advanced Templates.”

\mySubsubsection{16.2.19.}{Standard Library Feature-Test Macros}

Feature-test macros are available for Standard Library features. These are similar to the featuretest macros for core language features (discussed in Chapter 11, “Modules, Header Files, and Miscellaneous Topics”) and allow you to verify whether a certain feature is supported by your Standard Library implementation. All these macros start with \_\_cpp\_lib\_. The following lists a few examples. Consult your favorite Standard Library Reference for a complete list of all possible Standard Library feature-test macros.

\begin{itemize}
\item
\_\_cpp\_lib\_concepts

\item
\_\_cpp\_lib\_ranges

\item
\_\_cpp\_lib\_scoped\_lock


\item
\_\_cpp\_lib\_atomic\_float

\item
\_\_cpp\_lib\_constexpr\_vector


\item
\_\_cpp\_lib\_constexpr\_tuple

\item
\_\_cpp\_lib\_filesystem

\item
\_\_cpp\_lib\_three\_way\_comparison

\item
. . .
\end{itemize}

The value of such a macro is a number representing the month and year when a specific feature was added or updated. The date is formatted as YYYYMM. For example, the value of \_\_cpp\_lib\_ filesystem is 201703, i.e., March 2017.

As Chapter 11 explains, the core language feature-test macros are always available for you to use, without having to include any header. However, the Standard Library feature-test macros are defined in <version>. As all feature-test macros are macros, you know from Chapter 11 that importing the named module std or std.compat will not make those macros available to your code. Chapter 11 also explains that all C++ headers, such as <version>, are importable; thus, you have two options to get access to the macros defined in <version>:

\begin{cpp}
import <version>;
\end{cpp}

or

\begin{cpp}
#include <version>
\end{cpp}

Here is a full example:

\begin{cpp}
import std;
import <version>; // Important to get access to the feature-test macros!
using namespace std;

int main()
{
#ifdef __cpp_lib_constexpr_vector
    println("std::vector is constexpr!");
#else
    println("Bummer! std::vector is NOT constexpr!");
#endif
}
\end{cpp}

\begin{myNotic}{NOTE}
You will rarely need these feature-test macros, unless you are writing crossplatform and cross-compiler code. In that case, you might want to know if certain functionality is supported by a given Standard Library implementation so that you can provide fallback code in case a feature is missing. Chapter 34, “Developing Cross-Platform and Cross-Language Applications,” discusses cross-platform development.
\end{myNotic}

\mySubsubsection{16.2.20.}{<version>}

<version> can be used to query for implementation-dependent information about the C++ Standard Library that you are using. What exactly your <version> provides depends on your library implementation. The following could possibly be exposed: version number, release date, and copyright notice.

Additionally, as explained in the previous section, <version> exposes all Standard Library featuretest macros.

\mySubsubsection{16.2.21.}{Source Location}

std::source\_location, defined in <source\_location>, can be used to query information about your source code, such as filename, function name, line number, and column number, and replaces the old C-style macros \_\_FILE\_\_ and \_\_LINE\_\_. Example use cases are to provide source code information when logging messages or when throwing exceptions. Chapter 14 gives an example of both these use cases.

\mySubsubsection{16.2.22.}{Stack Trace}

\CXXTwentythreeLogo{-40}{15}

<stacktrace> defines the std::stacktrace and std::stacktrace\_entry classes. These can be used to get a stack trace at any given moment in time and to iterate and inspect each individual entry, known as a frame. See Chapter 14 for an example.

\mySubsubsection{16.2.23.}{Containers}

The Standard Library provides implementations of commonly used data structures such as linked lists and queues. When you use C++, you should not need to write such data structures again. The data structures are implemented using a concept called containers, which store information called elements, in a way that implements the data structure (linked list, queue, and so on) appropriately. Different data structures have different insertion, deletion, and access behavior and performance characteristics. It is important to be familiar with the available data structures so that you can choose the most appropriate one for any given task.

All the containers in the Standard Library are class templates, so you can use them to store any type, from built-in types such as int and double to your own classes. Each container instance stores objects of only one type; that is, they are homogeneous collections. If you need non-fixed-sized heterogeneous collections, you can wrap each element in an std::any instance and store those any instances in a container. Alternatively, you can store std::variant instances in a container. A variant can be used if the number of different required types is limited and known at compile time. Or you can create a class that has multiple derived classes, and each derived class can wrap an object of your required type. Both any and variant are discussed in Chapter 24.

\begin{myNotic}{NOTE}
The C++ Standard Library containers are homogeneous: they allow elements of only one type in each container
\end{myNotic}

The C++ standard specifies the interface, but not the implementation, of each container and algorithm. Thus, different vendors are free to provide different implementations. However, the standard also specifies performance requirements as part of the interface, which the implementations must meet.

This section provides an overview of the various containers available in the Standard Library.

\mySamllsection{Sequential Containers}

The Standard Library provides five sequential containers: vector, list, forward\_list, deque, and array.

\mySamllsection{vector}

vector is defined in <vector> and stores a sequence of elements while providing random access to these elements. You can think of a vector as an array of elements that grows dynamically as you insert elements and additionally provides some bounds checking. Like an array, the elements of a vector are stored in contiguous memory.

\begin{myNotic}{NOTE}
A vector in C++ is a synonym for a dynamic array: an array that grows and shrinks automatically in response to the number of elements it stores.
\end{myNotic}

vector provides fast element insertion and deletion (amortized constant time) at the end of the vector. Amortized constant time insertion means that most of the time insertions are done in constant time O(1) (Chapter 4, “Designing Professional C++ Programs,” explains big-O notation). However, sometimes the vector needs to grow in size to accommodate new elements, which has a complexity of O(N). On average, this results in O(1) complexity or amortized constant time. Details are explained in Chapter 18, “Standard Library Containers.” A vector has slower (linear time) insertion and deletion anywhere else, because the operation must move all the elements “up” or “down” by one to make room for the new element or to fill the space left by the deleted element. Like arrays, vectors provide fast (constant time) access to any of their elements.

Even though inserting and removing elements in the middle of a vector requires moving other elements up or down, a vector should be your default container! Often, a vector will be faster than, for example, a linked list, even for inserting and removing elements in the middle. The reason is that a vector is stored contiguously in memory, while a linked list is scattered around in memory. Computers are extremely efficient to work with contiguous data, which makes vector operations fast. You should only use something like a linked list if a performance profiler (discussed in Chapter 29, “Writing Efficient C++”) tells you that it performs better than a vector.

\begin{myNotic}{NOTE}
The vector container should be your default container.
\end{myNotic}

There is a template specialization available for vector<bool> to store Boolean values in a vector.
This specialization optimizes space allocation for the Boolean elements; however, the standard does not specify how an implementation of vector<bool> should optimize space. The difference between the vector<bool> specialization and the bitset discussed later in this chapter is that the bitset container is of fixed size, while vector<bool> automatically grows or shrinks when needed.

\mySamllsection{list}

list is a doubly linked list structure and is defined in <list>. Like an array or vector, it stores a sequence of elements. However, unlike an array or vector, the elements of a list are not necessarily contiguous in memory. Instead, each element in the list specifies where to find the next and previous elements in the list (usually via pointers), which is why it’s called a doubly linked list.

The performance characteristics of a list are the exact opposite of a vector. They provide slow (linear time) element lookup and access, but quick (constant time) insertion and deletion of elements once the relevant position has been found. Still, as discussed in the previous section, a vector is usually faster than a list. Use a profiler (discussed in Chapter 29) to be sure.

\mySamllsection{forward\_list}

forward\_list, defined in <forward\_list>, is a singly linked list, compared to the list container, which is doubly linked. forward\_list supports forward iteration only and requires a bit less memory than a list. Like list, forward\_list allows constant-time insertion and deletion anywhere once the relevant position has been found, and there is no fast random access to elements.

\mySamllsection{deque}

The name deque is an abbreviation for a double-ended queue. A deque, defined in <deque>, provides quick (constant time) element access. It also provides fast (constant time) insertion and deletion at both ends of the sequence, but it provides slow (linear time) insertion and deletion in the middle of the sequence. The elements of a deque are not stored contiguously in memory, and thus a deque might be slower than a vector.

You could use a deque instead of a vector when you need to insert or remove elements from either end of the sequence but still need fast access to all elements. However, this requirement does not apply to many programming problems; in most cases, a vector is recommended.

\mySamllsection{array}

array, defined in <array>, is a replacement for standard C-style arrays. Sometimes you know the exact number of elements in your container up front, and you don’t need the flexibility of a vector or a list, which are able to grow dynamically to accommodate new elements. An array is perfect for such fixed-sized collections, and it has a bit less overhead compared to a vector; it’s basically a thin wrapper around standard C-style arrays. There are a number of advantages in using arrays instead of standard C-style arrays: they always know their own size and do not automatically get cast to a pointer to avoid certain types of bugs. Also, arrays do not provide insertion or deletion; they have a fixed size. The advantage of having a fixed size is that this allows an array to be allocated on the stack, rather than always demanding access to the free store as vector does. Access to elements is very fast (constant time), just as with vectors.

\begin{myNotic}{NOTE}
The vector, list, forward\_list, deque, and array containers are called sequential containers because they store a sequence of elements.
\end{myNotic}

\mySamllsection{Sequential Views}

The Standard Library provides two sequential views: span and mdspan.

\mySamllsection{span}

A span, defined in <span>, represents a view on a contiguous sequence of data. It can be either a read-only view or a view with read/write access to the underlying elements. A span allows you to write a single function that can work with data coming from, for example, vectors, arrays, C-style arrays, and so on. Chapter 18 discusses span in more detail.

\begin{myNotic}{NOTE}
When writing a function accepting, for example, a const vector<T>\&, consider accepting a span<const T> instead, so the function can work with views and subviews of data sequences coming from vectors, arrays, C-style arrays, and more.
\end{myNotic}

\mySamllsection{mdspan}

\CXXTwentythreeLogo{-40}{5}

An mdspan, defined in <mdspan>, is similar to a span but represents a multidimensional view on a contiguous sequence of data. Just as a span, it can be a read-only view or a view with read/write access to the underlying elements. Chapter 18 discusses mdspan in more detail.


\mySamllsection{Container Adapters}

The Standard Library provides three nonassociative container adapters: queue, priority\_queue, and stack.

\mySamllsection{queue}

The name queue comes directly from the definition of the English word queue, which means a line of people or objects. The queue container is defined in <queue> and provides standard first in, first out (or FIFO) semantics. A queue is a container in which you insert elements at one end and take them out at the other end. Both insertion (amortized constant time) and removal (constant time) of elements are quick.

You should use a queue structure when you want to model real-life “first-come, first-served” semantics. For example, consider a bank. As customers arrive at the bank, they get in line. As tellers become available, they serve the next customer in line, thus providing “first-come, first-served” behavior. You could implement a bank simulation by storing customer objects in a queue. As customers arrive at the bank, they are added to the end of the queue. As tellers serve customers, they start with customers at the front of the queue.

\mySamllsection{priority\_queue}

A priority\_queue, also defined in <queue>, provides queue functionality in which each element has a priority. Elements are removed from the queue in priority order. In the case of priority ties, the order in which elements are removed is undefined. priority\_queue insertion and deletion are generally slower than simple queue insertion and deletion, because the elements must be reordered to support the priority ordering. You can use priority\_queues to model “queues with exceptions.” For example, in the earlier bank simulation, suppose that customers with business accounts take priority over regular customers.

Many real-life banks implement this behavior with two separate lines: one for business customers and one for everyone else. Any customers in the business queue are taken before customers in the other line. However, banks could also provide this behavior with a single line in which business customers move to the front of the line ahead of any non-business customers. In your program, you could use a priority\_queue in which customers have one of two priorities: business or regular. All business customers would be serviced before all regular customers.

\mySamllsection{stack}

<stack> defines the stack class, which provides standard first-in, last-out (FILO) semantics, also known as last-in, first-out (LIFO). Like a queue, elements are inserted and removed from the container. However, in a stack, the most recent element inserted is the first one removed. The name stack derives from a visualization of this structure as a stack of objects in which only the top object is visible. When you add an object to the stack, you hide all the objects underneath it.

The stack container provides fast (constant time) insertion and removal of elements. You should use the stack structure when you want FILO semantics. For example, an error-processing tool might want to store errors on a stack so that the most recent error is the first one available for a human administrator to read. Processing errors in a FILO order is often useful because newer errors sometimes obviate older ones.

\begin{myNotic}{NOTE}
Technically, the queue, priority\_queue, and stack containers are container adapters. They are simple interfaces built on top of one of the standard sequential containers vector, list, or deque.
\end{myNotic}

\mySamllsection{Ordered Associative Containers}

The Standard Library provides four ordered associative containers: set, multiset, map, and multimap. They are called sorted or ordered associative containers because they sort their elements.

\mySamllsection{set}

The set class template is defined in <set>, and, as the name suggests, it is a set of elements, loosely analogous to the notion of a mathematical set: each element is unique, and there is at most one instance of the element in the set. One difference between the mathematical concept of set and set as implemented in the Standard Library is that in the Standard Library the elements are kept in an order. The reason for the order is that an order makes it much faster to verify whether a certain element is already in a set. When a client enumerates the elements, they’ll come out in the ordering imposed by the type’s operator< or a user-defined comparator. The set provides logarithmic insertion, deletion, and lookup. This means that, in theory, insertions and deletions are faster than for a vector but slower than for a list; while lookups are faster than for a list, but slower than for a vector. As always, use a profiler to make sure which container is faster for your use case.

You could use a set when you need the elements to be in an order, to have equal amounts of insertion/deletion and lookups, and you want to optimize performance for both as much as possible. For example, an inventory-tracking program in a busy bookstore might want to use a set to store the books. The list of books in stock must be updated whenever books arrive or are sold, so insertion and deletion should be quick. Customers also need the ability to look for a specific book, so the program should provide fast lookup as well.

Elements in a set cannot be modified, because this could invalidate the order of the elements. If you need to change an element, remove that element first and insert a new one with the new value.

\begin{myNotic}{NOTE}
A set could be an option instead of a vector or list if you need order and want equal performance for insertion, deletion, and lookup. It could also be an option if you want to enforce that there are no duplicate elements.
\end{myNotic}

A set does not allow duplicate elements. That is, each element in a set must be unique.

\mySamllsection{multiset}

The multiset class template, also defined in <set>, is almost identical to set, except that a multiset can store duplicate elements.

\mySamllsection{map}

<map> defines the map class template, which is an associative array. You can use it as an array in which the index can be any type, for example, a string. A map stores key/value pairs and keeps its elements in sorted order, based on the keys, not the values. It also provides an operator[], which a set does not provide. In most other respects, it is identical to a set. You could use a map when you want to associate keys and values. For example, in the earlier bookstore example, you might want to store the books in a map where the key is the ISBN number of the book and the value is a Book object containing detailed information for that specific book.

\mySamllsection{multimap}

<map> also defines the multimap class template, which is virtually identical to map, except that a multimap can store elements with duplicate keys.

\begin{myNotic}{NOTE}
The set, multiset, map, and multimap containers are called associative containers because they associate keys and values. This term might be slightly confusing when applied to sets and multisets, because for these the keys are themselves the values.
\end{myNotic}

\mySamllsection{Unordered Associative Containers/Hash Tables}

The Standard Library supports hash tables, also called unordered associative containers. There are four unordered associative containers:

\begin{itemize}
\item
unordered\_map and unordered\_multimap

\item
unordered\_set and unordered\_multiset
\end{itemize}

The first two containers are defined in <unordered\_map>, while the latter two are defined in <unordered\_set>. Better names would have been hash\_map, hash\_set, and so on. Unfortunately, hash tables were not part of the C++ Standard Library before C++11, which means a lot of thirdparty libraries implemented hash tables themselves by using names with “hash” as a prefix, like hash\_map. Because of this, the C++ standard committee decided to use the prefix “unordered” instead of “hash” to avoid name clashes.

These unordered associative containers behave similar to their ordered counterparts. An unordered\_map is similar to a standard map except that the standard map sorts its elements, while the unordered\_map doesn’t sort its elements.

Insertion, deletion, and lookup with these unordered associative containers can be done on average in constant time. In a worst-case scenario, it will be in linear time. Lookup of elements in an unordered container can be much faster than with a normal map or set, especially when there are a lot of elements in the container.

Chapter 18 explains how these unordered associative containers work and why they are called hash tables.

\mySamllsection{Flat Associative Container Adapters}

\CXXTwentythreeLogo{-40}{5}

C++23 introduces four flat associative container adapters:

\begin{itemize}
\item
flat\_map and flat\_multimap defined in <flat\_map>

\item
flat\_set and flat\_multiset defined in <flat\_set>
\end{itemize}

These are adapters on top of sequential containers and provide an associative container interface. The adapted sequential containers must support random-access iterators, such as vector and deque. The flat\_map and flat\_multimap adapters require two underlying sequential containers, one to store the keys and another one to store the values. flat\_set and flat\_multiset require only one underlying sequential container to store their keys.

The interface provided by these adapters is almost identical to their ordered counterpart associative container. The only difference is that the flat adapters don’t provide any of the node-related member functions, as the flat adapters are not node-based data structures. Besides that, they are almost an immediate drop-in replacement for their ordered counterparts.

Chapter 18 gives more details about these flat associative container adapters.

\mySamllsection{bitset}

C and C++ programmers commonly store a set of flags in a single int or long, using one bit for each flag. Bits are set and accessed with the bitwise operators: \&, |, \^{}, ~, <{}<, and >{}>. The C++ Standard Library provides a bitset class that abstracts this bit field manipulation, so you shouldn’t need to use the bit manipulation operators anymore for such use cases.

<bitset> defines the bitset container, but this is not a container in the normal sense, in that it does not implement a specific data structure in which you insert and remove elements. A bitset has a fixed size. You can think of them as a sequence of Boolean values that you can read and write. However, unlike the C-style way of handling bits, the bitset is not limited to the size of an int or other elementary data types. Thus, you can have a 40-bit bitset or a 213-bit bitset. The implementation will use as much storage as it needs to implement N bits when you declare your bitset with bitset<N>.

\mySamllsection{Summary of Standard Library Containers}

The following table summarizes the containers provided by the Standard Library. It uses the big-O notation introduced in Chapter 4 to present the performance characteristics on a container of N elements. An N/A entry in the table means that the operation is not part of the container semantics:

% Please add the following required packages to your document preamble:
% \usepackage{multirow}
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|llll|}
\hline
\textbf{NAME} &
\multicolumn{1}{l|}{\textbf{TYPE}} &
\multicolumn{1}{l|}{\textbf{\begin{tabular}[c]{@{}l@{}}INSERT\\ PERFORMANCE\end{tabular}}} &
\multicolumn{1}{l|}{\textbf{\begin{tabular}[c]{@{}l@{}}DELETE\\ PERFORMANCE\end{tabular}}} &
\textbf{\begin{tabular}[c]{@{}l@{}}LOOKUP\\ PERFORMANCE\end{tabular}} \\ \hline
\endfirsthead
%
\endhead
%
\multirow{2}{*}{vector} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Amortized O(1)\\ at the end; O(N)\\ otherwise.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the end;\\ O(N) otherwise.\end{tabular}} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: This should be your default container. Only use another\\ container after using a profiler to confirm it is faster than a vector.\end{tabular}} \\ \hline
\multirow{2}{*}{list} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the beginning\\ and the end, and\\ once you are at the\\ position where you\\ want to insert the\\ element.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning and\\ the end, and\\ once you are\\ at the position\\ where you want\\ to delete the\\ element.\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}O(1) to\\ access the\\ first or last\\ element; O(N)\\ otherwise.\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: Rarely. You should use a vector, unless a profiler tells you a\\ list is faster for your use case.\end{tabular}} \\ \hline
\multirow{2}{*}{forward\_list} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning, and\\ once you are at the\\ position where you\\ want to insert the\\ element.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning, and\\ once you are\\ at the position\\ where you want\\ to delete the\\ element.\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}O(1) to access\\ the first\\ element; O(N)\\ otherwise.\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: Rarely. You should use a vector, unless a profiler tells you a\\ forward\_list is faster for your use case.\end{tabular}} \\ \hline
\multirow{2}{*}{deque} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning or end;\\ O(N) otherwise.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}O(1) at the\\ beginning or end;\\ O(N) otherwise.\end{tabular}} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: Not usually needed; use a vector instead.} \\ \hline
\multirow{2}{*}{array} &
\multicolumn{1}{l|}{Sequential} &
\multicolumn{1}{l|}{N/A} &
\multicolumn{1}{l|}{N/A} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you need a fixed-size array to replace a standard C-style\\ array.\end{tabular}} \\ \hline
\multirow{2}{*}{queue} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on the\\ underlying container;\\ O(1) for list and\\ deque.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on\\ the underlying\\ container; O(1)\\ for list and\\ deque.\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a FIFO structure.} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}priority\_\\ queue\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on the\\ underlying container;\\ amortized O(log(N))\\ for vector,\\ O(log(N)) for deque.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on\\ the underlying\\ container;\\ O(log(N)) for\\ vector and\\ deque.\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a queue with priority.} \\ \hline
\multirow{2}{*}{stack} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on the\\ underlying container;\\ O(1) for list and\\ deque, amortized\\ O(1) for vector.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Depends on\\ the underlying\\ container; O(1)\\ for list, vector,\\ and deque.\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a FILO/LIFO structure.} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}set\\ multiset\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Sorted\\ associative\end{tabular}} &
\multicolumn{1}{l|}{O(log(N))} &
\multicolumn{1}{l|}{O(log(N))} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection of elements with equal\\ lookup, insertion, and deletion times. Use a set when you want a collection of\\ elements without duplicates.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}map\\ multimap\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Sorted\\ associative\end{tabular}} &
\multicolumn{1}{l|}{O(log(N))} &
\multicolumn{1}{l|}{O(log(N))} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection to associate keys with\\ values, that is, an associative array, with equal lookup, insertion, and deletion\\ times.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}unordered\_map\\ unordered\_\\ multimap\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Unordered\\ associative /\\ hash table\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case O(1);\\ worst case O(N).\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst case\\ O(N).\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst\\ case O(N).\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want to associate keys with values with equal\\ lookup, insertion, and deletion times, and you don’t require the elements\\ to be sorted. Performance can be better than with a normal map, but that\\ depends on the elements.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}unordered\_set\\ unordered\_\\ multiset\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Unordered\\ associative/\\ hash table\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case O(1);\\ worst case O(N).\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst case\\ O(N).\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}Average case\\ O(1); worst\\ case O(N).\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a collection of elements with equal lookup,\\ insertion, and deletion times, and you don’t require the elements to be\\ sorted. Performance can be better than with a normal set, but that depends\\ on the elements.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}flat\_set\\ flat\_multiset\\ (C++23)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Flat set\\ associative\\ container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{O(N)} &
\multicolumn{1}{l|}{O(N)} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection of elements. Because the\\ adapters use underlying sequential containers that have very cache-friendly\\ memory layout, the performance is often better than the corresponding\\ ordered container.\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}flat\_map\\ flat\_multimap\\ (C++23)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Flat map\\ associative\\ container\\ adapter\end{tabular}} &
\multicolumn{1}{l|}{O(N)} &
\multicolumn{1}{l|}{O(N)} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}When to Use: When you want a sorted collection to associate keys with\\ values. Because the adapters use underlying sequential containers that have\\ very cache-friendly memory layout, the performance is often better than the\\ corresponding ordered container.\end{tabular}} \\ \hline
\multirow{2}{*}{bitset} &
\multicolumn{1}{l|}{Special} &
\multicolumn{1}{l|}{N/A} &
\multicolumn{1}{l|}{N/A} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{When to Use: When you want a collection of flags.} \\ \hline
\end{longtable}

Note that strings are technically containers as well. Thus, some of the algorithms described in the material that follows also work on strings.

\begin{myNotic}{NOTE}
vector should be your default container! In practice, insertion and deletion in a vector are often faster than in a list or forward\_list. This is because of how memory and caches work on modern CPUs and because of the fact that for a list or forward\_list, you first need to iterate to the position where you want to insert or delete an element. Memory for a list or forward\_list might be fragmented, so iteration is much slower than for a vector.
\end{myNotic}

\mySubsubsection{16.2.25.}{Algorithms}

In addition to containers, the Standard Library provides implementations of many generic algorithms. An algorithm is a strategy for performing a particular task, such as sorting or searching. These algorithms are implemented as function templates, so they work on most of the different container types. Note that the algorithms are not generally part of the containers. The Standard Library takes the approach of separating the data (containers) from the functionality (algorithms). Although this approach seems counter to the spirit of object-oriented programming, it is necessary in order to support generic programming in the Standard Library. The guiding principle of orthogonality maintains that algorithms and containers are independent, with (almost) any algorithm working with (almost) any container.

\begin{myNotic}{NOTE}
Although the algorithms and containers are theoretically independent, some containers provide certain algorithms in the form of class member functions because the generic algorithms do not perform well on those particular containers. For example, set provides its own find() algorithm that is faster than the generic find() algorithm. You should use the container-specific member function form of an algorithm, if provided, because it is generally more efficient or appropriate for the container at hand.
\end{myNotic}

Note that the generic algorithms do not work directly on containers; instead, they either use iterators or work on ranges, both discussed in detail in Chapter 17, “Understanding Iterators and the Ranges Library.”

This section gives an overview of what kinds of algorithms are available in the Standard Library without going into detail. Chapter 20, “Mastering Standard Library Algorithms,” discusses a selection of algorithms with coding examples. For the exact prototypes of all the available algorithms, consult your favorite Standard Library reference.

There are more than 100 algorithms in the Standard Library. The following sections divide these algorithms into different categories. The algorithms are defined in <algorithm> unless otherwise noted. Note that whenever the following algorithms are specified as working on a “sequence” of elements, that sequence is presented to the algorithm via iterators.

\begin{myNotic}{NOTE}
When examining the list of algorithms, remember that the Standard Library is designed with generality in mind, so it adds generality that might never be used but that, if required, would be essential. You may not need every algorithm or need to worry about the more obscure parameters that are there for anticipated generality. It is important only to be aware of what’s available in case you ever find it useful.
\end{myNotic}

\mySamllsection{Non-modifying Sequence Algorithms}

The non-modifying algorithms are those that look at a sequence of elements and return some information about the elements. As “non-modifying” algorithms, they cannot change the values of elements or the order of elements within the sequence. This category contains three types of algorithms: searching, comparing, and counting. The following sections briefly summarize the various nonmodifying algorithms. With these algorithms, you should rarely need to write a for loop to iterate over a sequence of values.

\mySamllsection{Searching Algorithms}

These algorithms do not require the sequence to be sorted. N is the size of the sequence to search in, and M is the size of the pattern to find:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME}     & \textbf{SYNOPSIS}                                                                                               & \textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
adjacent\_find() &
\begin{tabular}[c]{@{}l@{}}Finds the first instance of two consecutive elements that\\ are equal to each other or are equivalent to each other as\\ specified by a predicate.\end{tabular} &
O(N) \\ \hline
\begin{tabular}[c]{@{}l@{}}find()\\ find\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Finds the first element that matches a value or causes a\\ predicate to return true.\end{tabular} &
O(N) \\ \hline
find\_first\_of() & \begin{tabular}[c]{@{}l@{}}Like find, but searches for one of several elements at the\\ same time.\end{tabular} & O(N*M)              \\ \hline
find\_if\_not()   & \begin{tabular}[c]{@{}l@{}}Finds the first element that causes a predicate to return\\ false.\end{tabular}      & O(N)                \\ \hline
find\_end() &
\begin{tabular}[c]{@{}l@{}}Finds the last subsequence in a sequence that matches\\ another sequence or whose elements are equivalent, as\\ specified by a predicate.\end{tabular} &
O(M*(N-M)) \\ \hline
search() &
\begin{tabular}[c]{@{}l@{}}Finds the first subsequence in a sequence that matches\\ another sequence or whose elements are equivalent, as\\ specified by a predicate$^{1}$.\end{tabular} &
O(N*M)$^{1}$ \\ \hline
search\_n() &
\begin{tabular}[c]{@{}l@{}}Finds the first instance of n consecutive elements that are\\ equal to a given value or relate to that value according to\\ a predicate.\end{tabular} &
O(N) \\ \hline
\end{longtable}

$^{1}$search() accepts an optional extra parameter to specify the searching algorithm to use (default\_searcher, boyer\_moore\_searcher, or boyer\_moore\_horspool\_searcher). With the Boyer–Moore searchers, the worst-case complexity is O(N+M) when the pattern is not found, and O(N*M) when the pattern is found.

\mySamllsection{Comparison Algorithms}

The following comparison algorithms are provided. None of them requires the source sequences to be ordered. All of them have a linear worst-case complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
equal() &
\begin{tabular}[c]{@{}l@{}}Determines whether two sequences are equal by\\ checking whether parallel elements are equal or\\ match a predicate.\end{tabular} \\ \hline
mismatch() &
\begin{tabular}[c]{@{}l@{}}Returns the first element in each sequence that\\ does not match the element in the same location\\ in the other sequence.\end{tabular} \\ \hline
lexicographical\_compare() &
\begin{tabular}[c]{@{}l@{}}Compares two sequences to determine their\\ “lexicographical” ordering. This algorithm\\ compares each element of the first sequence\\ with its equivalent element in the second. If one\\ element is less than the other, that sequence is\\ lexicographically first. If the elements are equal, it\\ compares the next elements in order.\end{tabular} \\ \hline
lexicographical\_compare\_three\_way() &
\begin{tabular}[c]{@{}l@{}}Compares two sequences to determine their\\ “lexicographical” ordering using three-way\\ comparisons and returns a comparison category\\ type (strong\_ordering, weak\_ordering, or\\ partial\_ordering).\end{tabular} \\ \hline
all\_of() &
\begin{tabular}[c]{@{}l@{}}Returns true if a given predicate returns true\\ for all the elements in the sequence or if the\\ sequence is empty; false otherwise.\end{tabular} \\ \hline
any\_of() &
\begin{tabular}[c]{@{}l@{}}Returns true if a given predicate returns true\\ for at least one element in the sequence; false\\ otherwise.\end{tabular} \\ \hline
none\_of() &
\begin{tabular}[c]{@{}l@{}}Returns true if a given predicate returns false\\ for all the elements in the sequence or if the\\ sequence is empty; false otherwise.\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Counting Algorithms}

The following counting algorithms are available. None of them requires the source sequences to be ordered. All of them have a linear worst-case complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}count()\\ count\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Counts the number of elements matching a value or that cause a predicate to\\ return true.\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Modifying Sequence Algorithms}

The modifying algorithms modify some or all of the elements in a sequence. Some of them modify elements in place so that the original sequence changes. Others copy the results to a different sequence so that the original sequence remains unchanged. All of them have a linear worst-case complexity. The following table summarizes the modifying algorithms:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}copy()\\ copy\_backward()\end{tabular} &
Copies elements from one sequence to another. \\ \hline
copy\_if() &
\begin{tabular}[c]{@{}l@{}}Copies elements for which a predicate returns true from one sequence\\ to another\end{tabular} \\ \hline
copy\_n() &
Copies n elements from one sequence to another. \\ \hline
fill() &
Sets all elements in the sequence to a new value. \\ \hline
fill\_n() &
Sets the first n elements in the sequence to a new value. \\ \hline
generate() &
\begin{tabular}[c]{@{}l@{}}Calls a given function to generate a new value for each element in the\\ sequence.\end{tabular} \\ \hline
generate\_n() &
\begin{tabular}[c]{@{}l@{}}Calls a given function to generate a new value for the first n elements in\\ the sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}move()\\ move\_backward()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Moves elements from one sequence to another using efficient move\\ semantics (see Chapter 9).\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}remove()\\ remove\_if()\\ remove\_copy()\\ remove\_copy\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Removes all elements that match a given value or that cause a predicate\\ to return true, either in place or by copying the results to a different\\ sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}replace()\\ replace\_if()\\ replace\_copy()\\ replace\_copy\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Replaces all elements matching a value or that cause a predicate to\\ return true with a new element, either in place or by copying the results\\ to a different sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}reverse()\\ reverse\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Reverses the order of the elements in the sequence, either in place or by\\ copying the results to a different sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}rotate()\\ rotate\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Swaps the first and second “halves” of the sequence, either in place or\\ by copying the results to a different sequence. The two subsequences to\\ be swapped need not be equal in size.\end{tabular} \\ \hline
sample() &
Selects n random elements from the sequence. \\ \hline
\begin{tabular}[c]{@{}l@{}}shift\_left()\\ shift\_right()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Shifts the elements in a sequence left or right by a given number of\\ positions. Elements are moved to their new position. Elements that fall\\ of either end of the sequence are removed. shift\_left() returns an\\ iterator to the end of the new sequence; shift\_right() returns an\\ iterator to the beginning of the new sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}shuffle()\\ random\_shuffle()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Shuffles the sequence by randomly reordering the elements. It is\\ possible to specify the properties of the random number generator used\\ for shuffling. random\_shuffle() is deprecated since C++14, and is\\ removed starting with C++17.\end{tabular} \\ \hline
transform() &
\begin{tabular}[c]{@{}l@{}}Calls a unary function on each element of a sequence or a binary function\\ on parallel elements of two sequences, and stores the results in a\\ destination sequence. If the source and destination sequences are the\\ same, the transformation happens in-place.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}unique()\\ unique\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Removes consecutive duplicates from the sequence, either in place or by\\ copying results to a different sequence.\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Operational Algorithms}

Operational algorithms execute a function on individual elements of a sequence. There are two operational algorithms provided. Both have a linear complexity and do not require the source sequence to be ordered:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
for\_each() &
\begin{tabular}[c]{@{}l@{}}Executes a function on each element in the sequence. The sequence is\\ specified with a begin and end iterator.\end{tabular} \\ \hline
for\_each\_n() &
\begin{tabular}[c]{@{}l@{}}Similar to for\_each() but only processes the first n elements in the sequence.\\ The sequence is specified by a begin iterator and a number of elements (n).\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Swap Algorithms}

The C++ Standard Library provides the following swap algorithms:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME}                                                         & \textbf{SYNOPSIS}                            \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}iter\_swap()\\ swap\_ranges()\end{tabular} & Swaps two elements or sequences of elements. \\ \hline
\end{longtable}

\mySamllsection{Partitioning Algorithms}

A sequence is partitioned on a certain predicate, if all elements for which the predicate returns true are before all elements for which it returns false. The first element in the sequence that does not satisfy the predicate is called the partition point. The Standard Library provides the following partition algorithms:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_partitioned() &
\begin{tabular}[c]{@{}l@{}}Returns true if all elements for which a predicate\\ returns true are before all elements for which it\\ returns false.\end{tabular} &
Linear \\ \hline
partition() &
\begin{tabular}[c]{@{}l@{}}Sorts the sequence such that all elements for which\\ a predicate returns true are before all elements for\\ which it returns false, without preserving the original\\ order of the elements within each partition.\end{tabular} &
Linear \\ \hline
stable\_partition() &
\begin{tabular}[c]{@{}l@{}}Sorts the sequence such that all elements for which\\ a predicate returns true are before all elements for\\ which it returns false, while preserving the original\\ order of the elements within each partition.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
partition\_copy() &
\begin{tabular}[c]{@{}l@{}}Copies elements from one sequence to two different\\ sequences. The target sequence is selected based on\\ the result of a predicate, either true or false.\end{tabular} &
Linear \\ \hline
partition\_point() &
\begin{tabular}[c]{@{}l@{}}Returns an iterator such that all elements before this\\ iterator return true for a predicate and all elements\\ after this iterator return false for that predicate.\end{tabular} &
Logarithmic \\ \hline
\end{longtable}

\mySamllsection{Sorting Algorithms}

The Standard Library provides several different sorting algorithms with varying performance guarantees:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_sorted() &
\begin{tabular}[c]{@{}l@{}}Returns true if a sequence is sorted, false\\ otherwise.\end{tabular} &
Linear \\ \hline
is\_sorted\_until() &
\begin{tabular}[c]{@{}l@{}}Finds the largest sorted subrange starting at the\\ beginning of the given range of elements.\end{tabular} &
Linear \\ \hline
nth\_element() &
\begin{tabular}[c]{@{}l@{}}Relocates the $n^{th}$ element of the sequence such that\\ the element in the position pointed to by $n^{th}$  is the\\ element that would be in that position if the whole\\ range were sorted, and it rearranges all elements\\ such that all elements preceding the $n^{th}$  element are\\ less than the new $n^{th}$  element, and the ones following\\ it are greater than the new $n^{th}$  element.\end{tabular} &
Linear \\ \hline
\begin{tabular}[c]{@{}l@{}}partial\_sort()\\ partial\_sort\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Partially sorts the sequence: the first n elements\\ (specified by iterators) are sorted; the rest are not.\\ They are sorted either in place or by copying them to\\ a new sequence.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}stable\_sort()\\ sort()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Sorts elements in place, either preserving the order\\ of duplicate elements (stable) or not.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Binary Search Algorithms}

The following binary search algorithms are normally used on sorted sequences. Technically, they only require the sequence to be at least partitioned on the element that is searched for. This could, for example, be achieved by applying std::partition(). A sorted sequence also meets this requirement. All these algorithms have logarithmic complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME}    & \textbf{SYNOPSIS}                                                      \\ \hline
\endfirsthead
%
\endhead
%
lower\_bound() & \begin{tabular}[c]{@{}l@{}}Finds the first element in a sequence not less than (that is, greater or equal\\ to) a given value.\end{tabular} \\ \hline
upper\_bound()   & Finds the first element in a sequence greater than a given value.      \\ \hline
equal\_range() & \begin{tabular}[c]{@{}l@{}}Returns a pair containing the result of both lower\_bound() and\\ upper\_bound().\end{tabular}                   \\ \hline
binary\_search() & Returns true if a given value is found in a sequence; false otherwise. \\ \hline
\end{longtable}

\mySamllsection{Set Algorithms on Sorted Sequences}

Set algorithms are special modifying algorithms that perform set operations on sequences. They are most appropriate on sequences from set containers, but work on sorted sequences from most containers:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
includes() &
\begin{tabular}[c]{@{}l@{}}Determines whether every element from\\ one sorted sequence is in another sorted\\ sequence.\end{tabular} &
Linear \\ \hline
\begin{tabular}[c]{@{}l@{}}set\_union()\\ set\_intersection()\\ set\_difference()\\ set\_symmetric\_difference()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Performs the specified set operation on\\ two sorted sequences, copying results to a\\ third sorted sequence.\end{tabular} &
Linear \\ \hline
\end{longtable}

\mySamllsection{Other Algorithms on Sorted Sequences}

The Standard Library provides the following additional algorithms that work on sorted sequences:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
inplace\_merge() &
Merges two sorted sequences in place. &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
merge() &
\begin{tabular}[c]{@{}l@{}}Merges two sorted sequences by copying them to a new\\ sequence.\end{tabular} &
Linear \\ \hline
\end{longtable}

\mySamllsection{Heap Algorithms}

A heap is a standard data structure in which the elements of an array or sequence are ordered in a semi-sorted fashion so that finding the “top” element is quick. For example, a heap data structure is typically used to implement a priority\_queue. Six algorithms allow you to work with heaps:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_heap() &
\begin{tabular}[c]{@{}l@{}}Returns true if a range of elements is a heap, false\\ otherwise.\end{tabular} &
Linear \\ \hline
is\_heap\_until() &
\begin{tabular}[c]{@{}l@{}}Finds the largest subrange that is a heap, starting at the\\ beginning of the given range of elements.\end{tabular} &
Linear \\ \hline
make\_heap() &
Creates a heap from a range of elements. &
Linear \\ \hline
\begin{tabular}[c]{@{}l@{}}push\_heap()\\ pop\_heap()\end{tabular} &
Adds an element to, or removes an element from, a heap. &
Logarithmic \\ \hline
sort\_heap() &
\begin{tabular}[c]{@{}l@{}}Converts a heap into a range of ascending sorted\\ elements.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Linear\\ logarithmic\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Minimum/Maximum Algorithms}

The following algorithms are provided to find minimum and maximum elements and to clamp values:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME}                                                           & \textbf{SYNOPSIS}                                                \\ \hline
\endfirsthead
%
\endhead
%
clamp() &
\begin{tabular}[c]{@{}l@{}}Makes sure a value (v) is between a given minimum (lo) and maximum\\ (hi). Returns a reference to lo if v \textless lo; returns a reference to hi if v \textgreater hi;\\ otherwise returns a reference to v.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}min()\\ max()\end{tabular}                   & Returns the minimum or maximum of two or more values.            \\ \hline
minmax()                                                                & Returns the minimum and maximum of two or more values as a pair. \\ \hline
\begin{tabular}[c]{@{}l@{}}min\_element()\\ max\_element()\end{tabular} & Returns the minimum or maximum element in a sequence.            \\ \hline
minmax\_element()                                                       & Returns the minimum and maximum element in a sequence as a pair. \\ \hline
\end{longtable}


\mySamllsection{Numerical Processing Algorithms}

The following numerical processing algorithms are defined in <numeric>. None of them require the source sequences to be ordered. All of them have a linear complexity:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
iota() &
\begin{tabular}[c]{@{}l@{}}Fills a sequence with successively incrementing values starting\\ with a given value.\end{tabular} \\ \hline
adjacent\_difference() &
\begin{tabular}[c]{@{}l@{}}Generates a new sequence in which each element is the\\ difference (or other binary operation) of the second and first\\ of each adjacent pair of elements in the source sequence.\end{tabular} \\ \hline
partial\_sum() &
\begin{tabular}[c]{@{}l@{}}Generates a new sequence in which each element is the sum\\ (or other binary operation) of an element and all its preceding\\ elements in the source sequence.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}exclusive\_scan()\\ inclusive\_scan()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}These are similar to partial\_sum(). An inclusive scan is\\ identical to a partial sum if the given summation operation\\ is associative. However, inclusive\_scan() sums in a\\ nondeterministic order, while partial\_sum() left to right,\\ so for nonassociative summation operations the result of\\ the former is nondeterministic. The exclusive\_scan()\\ algorithm also sums in a nondeterministic order.\\ For inclusive\_scan(), the $i^{th}$ element is included in the $i^{th}$\\ sum, just as for partial\_sum(). For exclusive\_scan(), the\\ $i^{th}$ element is not included in the ith sum.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}transform\_exclusive\_scan()\\ transform\_inclusive\_scan()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Applies a transformation to each element in a sequence, then\\ performs an exclusive/inclusive scan.\end{tabular} \\ \hline
accumulate() &
\begin{tabular}[c]{@{}l@{}}“Accumulates” the values of all the elements in a sequence.\\ The default behavior is to sum the elements, but the caller\\ can supply a different binary function instead.\end{tabular} \\ \hline
inner\_product() &
\begin{tabular}[c]{@{}l@{}}Similar to accumulate(), but works on two sequences. This\\ algorithm calls a binary function (multiplication by default) on\\ parallel elements in the sequences, accumulating the result\\ using another binary function (addition by default). If the\\ sequences represent mathematical vectors, the algorithm\\ calculates the dot product of the vectors.\end{tabular} \\ \hline
reduce() &
\begin{tabular}[c]{@{}l@{}}Similar to accumulate(), but supports parallel execution.\\ The order of evaluation for reduce() is nondeterministic,\\ while it’s from left to right for accumulate(). This means that\\ the behavior of the former is nondeterministic if the given\\ binary operation is not associative or not commutative.\end{tabular} \\ \hline
transform\_reduce() &
\begin{tabular}[c]{@{}l@{}}Applies a transformation to each element in a sequence, then\\ performs a reduce().\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{Permutation Algorithms}

A permutation of a sequence contains the same elements but in a different order. The following algorithms are provided to work with permutations:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} &
\textbf{COMPLEXITY} \\ \hline
\endfirsthead
%
\endhead
%
is\_permutation() &
\begin{tabular}[c]{@{}l@{}}Returns true if the elements in one range are a\\ permutation of the elements in another range.\end{tabular} &
Quadratic \\ \hline
\begin{tabular}[c]{@{}l@{}}next\_permutation()\\ prev\_permutation()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Modifies the sequence by transforming it into its “next”\\ or “previous” lexicographical permutation. Successive\\ calls to one or the other will permute the sequence into\\ all possible permutations of its elements, if you start\\ with a properly sorted sequence. This algorithm returns\\ false if no more permutations exist.\end{tabular} &
Linear \\ \hline
\end{longtable}

\mySamllsection{Choosing an Algorithm}

The number and capabilities of the algorithms might overwhelm you at first. It can be difficult to see how to apply them in the beginning. However, now that you have an idea of the available options, you are better able to tackle your program designs. The following chapters cover the details of how to use these algorithms in your code.



\mySubsubsection{16.2.26.}{Ranges Library}

The ranges library makes it easier and more elegant to work with sequences of elements. Ranges provide nicer and easier-to-read syntax and eliminate the possibility of mismatching begin/end iterators. Additionally, range adapters allow you to lazily transform and filter underlying sequences, and range factories are provided to build up ranges.

Most algorithms discussed in the previous sections have variants that work with ranges in addition to iterators. Those variants are often called range-based algorithms or constrained algorithms because they have proper template type parameter constraints in the form of concepts. This allows the compiler to issue better error messages if such a constrained algorithm is used wrongly.

Additionally, C++23 introduces the following algorithms that are available only in a constrained variant. All of them have a linear complexity.

\CXXTwentythreeLogo{-40}{-50}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{NAME} &
\textbf{SYNOPSIS} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}contains()\\ contains\_subrange()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Returns true if a given range contains a given value,\\ respectively, a given subrange, false otherwise.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}starts\_with()\\ ends\_with()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Returns true if a given range starts, respectively, ends with\\ another given range, false otherwise.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}find\_last()\\ find\_last\_if()\\ find\_last\_if\_not()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Finds the last element in a given range that either matches\\ a given value, or for which a given predicate returns true,\\ or for which a given predicate returns false. The result is a\\ subrange starting at the found element until the end of the\\ range.\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}fold\_left()\\ fold\_left\_first()\\ fold\_right()\\ fold\_right\_last()\\ fold\_left\_with\_iter()\\ fold\_left\_first\_with\_iter()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Folds the elements of a given range left or right. fold\_\\ left() and fold\_right() accept an initial value as one of\\ their arguments, and return the result of the fold operation.\\ fold\_left\_first() uses the first element in a given range\\ as the starting value, while fold\_right\_last() uses the\\ last element in a given range as the starting value. Both\\ of these return an optional containing the result, or an\\ empty optional if applied to an empty range. The last two\\ variants return an instance of fold\_left\_with\_iter\_\\ result, respectively, fold\_left\_first\_with\_iter\_\\ result that you can use to inspect the result of the fold\\ operation.\end{tabular} \\ \hline
\end{longtable}

The ranges library is defined in <ranges> and lives in the std::ranges namespace. Chapter 17 discusses the ranges library, while Chapter 20 discusses unconstrained and constrained algorithms with coding examples.

\mySubsubsection{16.2.27.}{What’s Missing from the Standard Library}

The Standard Library is powerful, but it’s not perfect. Here are two examples of missing functionality:

\begin{itemize}
\item
The Standard Library does not guarantee any thread safety for accessing containers simultaneously from multiple threads.

\item
The Standard Library does not provide any generic tree or graph structures. Although map and set are generally implemented as balanced binary trees, the Standard Library does not expose this implementation in the interface. If you need a tree or graph structure for something like writing a parser, you need to implement your own or find an implementation in another library.
\end{itemize}

It is important to keep in mind that the Standard Library is extensible. You can write your own containers and algorithms that work with existing algorithms and containers. So, if the Standard Library doesn’t provide exactly what you need, consider writing your desired code such that it works with the Standard Library. Chapter 25 covers the topic of customizing and extending the Standard Library with custom algorithms and custom containers. Alternatively, you can consider buying or licensing a Standard Library-compliant third-party library that provides the required functionality. See Chapter 4, “Designing Professional C++ Programs,” for a discussion on using third-party libraries and licensing options.







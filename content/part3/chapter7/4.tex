
处理动态内存使用 new/delete/new[]/delete[] 以及其他底层内存操作，这些操作非常容易出错。很难准确指出哪些情况会导致与内存相关的错误，每个内存泄漏或错误指针都有差别，解决内存问题没有万能的方法。本节讨论了一些常见的问题类别以及一些可用于检测和解决问题的工具。

\mySubsubsection{7.4.1.}{数据缓冲区分配不足和越界内存访问}

分配不足是C字符串中的一个常见问题，发生在开发者未能为尾部的 '\verb|\|0' 终止符分配额外的字符时。当开发者假设一个固定的最大大小时，字符串的分配不足也会发生。基本的内置C字符串函数并不遵循固定大小——它们会愉快地将字符串写入未知的内存区域。

以下代码演示了分配不足，从网络连接读取数据并将其放入C字符串中。这是在一个循环中完成的，网络连接一次只能接收少量数据。每次循环中，调用 getMoreData()，返回指向动态分配内存的指针。当 getMoreData() 返回 nullptr 时，表示所有数据都已接收完毕。strcat() 是一个C函数，将第二个参数给定的C字符串连接到第一个参数给定的C字符串的末尾，并期望目标缓冲区足够大。

\begin{cpp}
char buffer[1024] { 0 }; // Allocate a whole bunch of memory.
while (true) {
    char* nextChunk { getMoreData() };
    if (nextChunk == nullptr) {
        break;
    } else {
        strcat(buffer, nextChunk); // BUG! No guarantees against buffer overrun!
        delete [] nextChunk;
    }
}
\end{cpp}

解决这个示例中可能出现的分配不足问题的三种方法，按优先级递减：

\begin{enumerate}
\item
使用C++字符串，会在你进行连接时自动处理与连接相关的内存。

\item
将缓冲区分配作为全局变量或栈上的变量，改为在堆上分配。当剩余空间不足时，分配一个新的足够大的缓冲区来至少容纳当前内容加上新的一块，将原始缓冲区复制到新缓冲区，添加新内容，然后删除原始缓冲区。

\item
创建一个版本的 getMoreData()，它接受一个最大计数（包括 '\verb|\|0' 字符）并返回不超过该计数字符的数量；然后，跟踪缓冲区中剩余的空间和当前位置。
\end{enumerate}
数据缓冲区分配不足通常会导致越界内存访问。例如，如果您正在用数据填充内存缓冲区，当您假设缓冲区比实际大时，您可能会开始在缓冲区之外写入。这只是时间问题，直到重要的内存部分被覆盖，程序崩溃。考虑如果程序中的对象关联的内存突然被覆盖会发生什么。那可不好看！

越界内存访问还发生在处理丢失了 '\verb|\|0' 终止字符的C风格字符串时。例如，一个不正确终止的字符串传递给以下函数，将用 ‘m’ 字符填充字符串，并愉快地继续用 ‘m’ 填充字符串后面的内存内容，覆盖字符串范围外的内存。

\begin{cpp}
void fillWithM(char* text)
{
    int i { 0 };
    while (text[i] != '\0') {
        text[i] = 'm';
        ++i;
    }
}
\end{cpp}

导致在数组末尾之外写入内存的错误，通常称为缓冲区溢出错误。这些错误已被多种高知名度的恶意软件程序（如病毒和蠕虫）利用，狡猾的黑客可以利用覆盖内存部分的能力将代码注入正在运行的程序。

\begin{myWarning}{WARNING}
避免使用旧的C风格字符串和数组，这些字符串和数组完全不提供任何保护。相反，使用现代安全的构造，如C++字符串和vector，可管理所有内存。
\end{myWarning}

\mySubsubsection{7.4.2.}{内存泄漏}

现代C++中，没有内存泄漏。所有的内存管理都由更高级的类，如 std::vector、string 等处理。只有手动内存分配和释放时，才会出现内存泄漏。

找到并修复这样的内存泄漏可能会让人感到沮丧。程序终于运行良好，看起来给出了正确的结果。然后，开始注意到，随着程序的运行，程序会吞噬越来越多的内存——程序有内存泄漏。

内存泄漏发生在分配内存之后，忘记释放。起初，这听起来像是由于粗心编程的结果。如果每个新类都有一个对应的 delete，应该就不会有内存泄漏，对吗？实际上，这并不总是正确的。例如，在以下代码中，Simple 类正确地编写以释放它分配的内存。但当调用 doSomething() 时，outSimplePtr 指针改变为另一个 Simple 对象，而没有删除旧的 Simple 对象，出现内存泄漏。当失去了对一个对象的引用，则不可能删除它。

\begin{cpp}
class Simple
{
    public:
    Simple() { m_intPtr = new int{}; }
    ˜Simple() { delete m_intPtr; }
    void setValue(int value) { *m_intPtr = value; }
    private:
    int* m_intPtr;
};

void doSomething(Simple*& outSimplePtr)
{
    outSimplePtr = new Simple{}; // BUG! Doesn't delete the original.
}

int main()
{
    Simple* simplePtr { new Simple{} }; // Allocate a Simple object.
    doSomething(simplePtr);
    delete simplePtr; // Only cleans up the second object.
}
\end{cpp}

\begin{myWarning}{WARNING}
这段代码仅用于演示目的！生产质量的代码中，m\_intPtr 和 simplePtr 都不应该使用原始指针，而应该使用智能指针。
\end{myWarning}

在前一个示例的情况下，内存泄漏可能源于开发者之间的沟通不畅或代码文档不足。doSomething() 的调用者可能没有意识到变量通过引用传递，因此没有理由期望指针会重新分配。如果注意到参数是一个指向非常量指针的引用，可能会怀疑有什么奇怪的事情发生，但是 doSomething() 附近没有任何注释来解释这种行为。

\mySamllsection{Finding and Fixing Memory Leaks in Windows with Visual C++}

Memory leaks are hard to track down because you can’t easily look at memory and see what objects are not in use and where they were originally allocated. However, there are programs that can do this for you. Memory leak detection tools range from expensive professional software packages to free downloadable tools. If you work with Microsoft Visual C++, its debug library has built-in support for memory leak detection. This memory leak detection is not enabled by default, unless you create an MFC project. To enable it in other projects, you need to start by including the following three lines at the beginning of your code. These use the \#define preprocessor macro, explained in Chapter 11, “Modules, Header Files, and Miscellaneous Topics.” However, for now, just use the three lines verbatim as they are.

\begin{cpp}
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>
\end{cpp}

These lines should be in the exact order as shown. Next, you need to redefine the new operator as follows. This uses a few other preprocessor macros, all explained in Chapter 11. Again, just use them as is for now.

\begin{cpp}
#ifdef _DEBUG
    #ifndef DBG_NEW
        #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
        #define new DBG_NEW
    #endif
#endif // _DEBUG
\end{cpp}

The \#ifdef \_DEBUG statement makes sure that the redefinition of new is done only when compiling a debug version of your application. This is what you normally want. Release builds usually do not do any memory leak detection, because of the performance penalty.

The last thing you need to do is to add the following line as the first line in your main() function:

\begin{cpp}
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
\end{cpp}

This tells the Visual C++ CRT (C RunTime) library to write all detected memory leaks to the debug output console when the application exits. For the earlier leaky program, the debug console will contain lines similar to the following:

\begin{shell}
Detected memory leaks!
Dumping objects ->
c:\leaky\leaky.cpp(15) : {147} normal block at 0x014FABF8, 4 bytes long.
 Data: < > 00 00 00 00
c:\leaky\leaky.cpp(33) : {146} normal block at 0x014F5048, 4 bytes long.
 Data: <Pa > 50 61 20 01
Object dump complete.
\end{shell}

The output clearly shows in which file and on which line memory was allocated but never deallocated. The line number is between parentheses immediately behind the filename. The number between the curly braces is a counter for the memory allocations. For example, {147} means the 147th allocation in your program since it started. You can use the VC++ \_CrtSetBreakAlloc() function to tell the VC++ debug runtime to break into the debugger when a certain allocation is performed. For example, you can add the following line to the beginning of your main() function to instruct the debugger to break on the 147th allocation:

\begin{cpp}
_CrtSetBreakAlloc(147);
\end{cpp}

In this leaky program, there are two leaks: the first Simple object that is never deleted (line 33) and the integer on the free store that it creates (line 15). In the Visual C++ debugger output window, you can simply double-click one of the memory leaks, and it will automatically jump to that line in your code.

Of course, programs like Microsoft Visual C++ (discussed in this section) and Valgrind (discussed in the next section) can’t actually fix the leak for you—what fun would that be? These tools provide information that you can use to find the actual problem. Normally, that involves stepping through the code to find out where the pointer to an object was overwritten without the original object being released. Most debuggers provide “watch point” functionality that can break execution of the program when this occurs.

\mySamllsection{Finding and Fixing Memory Leaks in Linux with Valgrind}

Valgrind is an example of a free open-source tool for Linux that, among other things, pinpoints the exact line in your code where a leaked object was allocated.

The following output, generated by running Valgrind on the earlier leaky program, pinpoints the exact locations where memory was allocated but never released. Valgrind finds the same two memory leaks—the first Simple object never deleted and the integer on the free store that it creates:

\begin{shell}
==15606== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==15606== malloc/free: in use at exit: 8 bytes in 2 blocks.
==15606== malloc/free: 4 allocs, 2 frees, 16 bytes allocated.
==15606== For counts of detected errors, rerun with: -v
==15606== searching for pointers to 2 not-freed blocks.
==15606== checked 4455600 bytes.
==15606==
==15606== 4 bytes in 1 blocks are still reachable in loss record 1 of 2
==15606==    at 0x4002978F: __builtin_new (vg_replace_malloc.c:172)
==15606==    by 0x400297E6: operator new(unsigned) (vg_replace_malloc.c:185)
==15606==    by 0x804875B: Simple::Simple() (leaky.cpp:4)
==15606==    by 0x8048648: main (leaky.cpp:24)
==15606==
==15606==
==15606== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2
==15606==    at 0x4002978F: __builtin_new (vg_replace_malloc.c:172)
==15606==    by 0x400297E6: operator new(unsigned) (vg_replace_malloc.c:185)
==15606==    by 0x8048633: main (leaky.cpp:20)
==15606==    by 0x4031FA46: __libc_start_main (in /lib/libc-2.3.2.so)
==15606==
==15606== LEAK SUMMARY:
==15606==     definitely lost: 4 bytes in 1 blocks.
==15606==     possibly lost:   0 bytes in 0 blocks.
==15606==     still reachable: 4 bytes in 1 blocks.
==15606==          suppressed: 0 bytes in 0 blocks.
\end{shell}

\begin{myWarning}{WARNING}
It is strongly recommended to use std::vector, array, string, smart pointers (discussed later in this chapter), and other modern C++ constructs to avoid memory leaks.
\end{myWarning}

\mySubsubsection{7.4.3.}{Double-Deletion and Invalid Pointers}

Once you release memory associated with a pointer using delete, the memory is available for use by other parts of your program. Nothing stops you, however, from attempting to continue to use the pointer, which is now a dangling pointer. Double deletion is also a problem. If you use delete a second time on a pointer, the program could be releasing memory that has since been assigned to another object.

Double deletion and use of already released memory are both difficult problems to track down because the symptoms may not show up immediately. If two deletions occur within a relatively short amount of time, the program potentially could work indefinitely because the associated memory might not have been reused that quickly. Similarly, if a deleted object is used immediately after being deleted, most likely it will still be intact.

Of course, there is no guarantee that such behavior will work or continue to work. The memory allocator is under no obligation to preserve any object once it has been deleted. Even if it does work, it is extremely poor programming style to use objects that have been deleted.

To avoid double deletion and use of already released memory, you should set your pointers to nullptr after deallocating their memory.

Many memory leak-detection programs are also capable of detecting double deletion and use of released objects.













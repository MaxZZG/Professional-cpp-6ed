通过解决下面的练习，可以练习本章讨论的内容。所有练习的解决方案都可以在本书的网站\url{www.wiley.com/go/proc++6e}下载到源码。若在练习中卡住了，可以考虑先重读本章的部分内容，试着自己找到答案，再在从网站上寻找解决方案。

\begin{itemize}
\item
\textbf{练习 7-1}: 分析下面的代码段。能列出其中发现的问题吗？这个练习中，不需要修复这些问题，这将是练习 7-2 的任务。

\begin{cpp}
const size_t numberOfElements { 10 };
int* values { new int[numberOfElements] };
// Set values to their index value.
for (int index { 0 }; index < numberOfElements; ++index) {
    values[index] = index;
}
// Set last value to 99.
values[10] = 99;
// Print all values.
for (int index { 0 }; index <= numberOfElements; ++index) {
    print("{} ", values[index]);
}
\end{cpp}

\item
\textbf{练习 7-2}: 使用现代安全的 C++ 构造重写练习 7-1 中的代码片段。

\item
\textbf{练习 7-3}: 编写一个基本的类来存储一个具有 x、y 和 z 坐标的 3D 点,包括一个接受 x、y 和 z 参数的构造函数，还有一个函数，它接受一个 3D 点并使用 std::print() 打印出其坐标。在main()函数中，动态分配类的实例，然后调用函数。

\item
\textbf{练习 7-4}: 本章中展示了以下函数，用于处理越界内存访问。能用安全的 C++ 替代方案现代化这个函数吗？在 main() 函数中测试你的解决方案。

\begin{cpp}
void fillWithM(char* text)
{
    int i { 0 };
    while (text[i] != '\0') {
        text[i] = 'm';
        ++i;
    }
}
\end{cpp}
\end{itemize}
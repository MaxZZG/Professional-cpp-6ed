
vector, deque, list, forward\_list, and array are called sequential containers because they store a sequence of elements. The best way to learn about sequential containers is to jump in with an example of the vector container, which should be your default container anyway. The next section describes the vector container in detail, followed by briefer discussions of deque, list, forward\_list, and array. Once you become familiar with the sequential containers, it’s trivial to switch between them.

\mySubsubsection{18.2.1.}{vector}

The Standard Library vector container is similar to a standard C-style array: the elements are stored in contiguous memory, each in its own “slot.” You can index into a vector, as well as add new elements to the back or insert them anywhere else. Inserting and deleting elements into and from a vector generally takes linear time, though these operations actually run in amortized constant time at the end of a vector, as explained in the section “The vector Memory Allocation Scheme,” later in this chapter. Random access of individual elements has a constant complexity; see Chapter 4, “Designing Professional C++ Programs,” for a discussion on algorithm complexity.

\mySamllsection{vector Overview}

vector is defined in <vector> as a class template with two type parameters: the element type to store and an allocator type:

\begin{cpp}
template <typename T, typename Allocator = allocator<T>> class vector;
\end{cpp}

The Allocator parameter specifies the type for a memory allocator object that the client can set in order to use custom memory allocation. This template parameter has a default value.

\begin{myNotic}{NOTE}
The default value for the Allocator template type parameter is sufficient for most applications. This chapter always uses the default allocator. Chapter 25, “Customizing and Extending the Standard Library,” provides more details in case you are interested.
\end{myNotic}

std::vector is constexpr (see Chapter 9), just as std::string. This means that vector can be used to perform operations at compile time and that it can be used in the implementation of constexpr functions and other constexpr classes.

\mySamllsection{Fixed-Length vectors}

One way to use a vector is as a fixed-length array. vector provides a constructor that allows you to specify the number of elements and provides an overloaded operator[] to access and modify those elements. The result of operator[] is undefined when used to access an element outside the vector bounds. This means that a compiler can decide how to behave in that case. For example, the default behavior of Microsoft Visual C++ is to give a run-time error message when your program is compiled in debug mode and to disable any bounds checking in release mode for performance reasons. You can change these default behaviors.

\begin{myWarning}{WARNING}
Like “real” array indexing, operator[] on a vector does not provide bounds checking.
\end{myWarning}

In addition to using operator[], you can access vector elements via at(), front(), and back(). The at() member function is identical to operator[], except that it performs bounds checking and throws an out\_of\_range exception if the index is out of bounds. front() and back() return references to the first and last elements of a vector, respectively. Calling front() or back() on an empty container triggers undefined behavior.

\begin{myNotic}{NOTE}
All vector element accesses have constant complexity.
\end{myNotic}

Here is a small example program to “normalize” test scores so that the highest score is set to 100, and all other scores are adjusted accordingly. The program creates a vector of ten doubles, reads in ten values from the user, divides each value by the max score (times 100), and prints out the new values. To create the vector, parentheses, (10), are used and not uniform initialization, {10}, as the latter would create a vector of just one element with the value 10. For the sake of brevity, the program forsakes error checking.

\begin{cpp}
vector<double> doubleVector(10); // Create a vector of 10 doubles.

// Initialize max to smallest number.
double max { -numeric_limits<double>::infinity() };

for (size_t i { 0 }; i < doubleVector.size(); ++i) {
    print("Enter score {}: ", i + 1);
    cin >> doubleVector[i];
    if (doubleVector[i] > max) {
        max = doubleVector[i];
    }
}

max /= 100.0;
for (auto& element : doubleVector) {
    element /= max;
    print("{} ", element);
}
\end{cpp}

As you can see from this example, you can use a vector just as you would use a standard C-style array. Note that the first for loop uses the size() member function to determine the number of elements in the container. This example also demonstrates the use of a range-based for loop with a vector. Here, the range-based for loop uses auto\& and not auto because a reference is required so that the actual elements can be modified in each iteration.

\begin{myNotic}{NOTE}
operator[] on a vector normally returns a reference to the element, which can be used on the left-hand side of assignment statements. If operator[] is called on a const vector object, it returns a reference to a const element, which cannot be used as the target of an assignment. See Chapter 15, “Overloading C++ Operators,” for details on how this trick is implemented.
\end{myNotic}

\mySamllsection{Dynamic-Length vectors}

The real power of a vector lies in its ability to grow dynamically. For example, consider the test score normalization program from the previous section with the additional requirement that it should handle any number of test scores. Here is the new version:

\begin{cpp}
vector<double> doubleVector; // Create a vector with zero elements.

// Initialize max to smallest number.
double max { -numeric_limits<double>::infinity() };

for (size_t i { 1 }; true; ++i) {
    double value;
    print("Enter score {} (-1 to stop): ", i);
    cin >> value;
    if (value == -1) {
        break;
    }
    doubleVector.push_back(value);
    if (value > max) {
        max = value;
    }
}

max /= 100.0;
for (auto& element : doubleVector) {
    element /= max;
    print("{} ", element);
}
\end{cpp}

This version of the program uses the default constructor to create a vector with zero elements. As each score is read, it’s added to the end of the vector with the push\_back() member function, which takes care of allocating space for the new element. The range-based for loop doesn’t require any changes.

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{Formatting and Printing Vectors}

Starting with C++23, std::format() and the print() functions can be used to format and print entire containers with a single statement. This works for all Standard Library sequential containers, container adapters, and associative containers, and is introduced in Chapter 2, “Working with Strings and String Views.” Here is an example:

\begin{cpp}
vector values { 1.1, 2.2, 3.3 };
println("{}", values); // Prints the following: [1.1, 2.2, 3.3]
\end{cpp}

You can specify the n format specifier to omit the surrounding square brackets:

\begin{cpp}
println("{:n}", values); // Prints the following: 1.1, 2.2, 3.3
\end{cpp}

If your compiler doesn’t support this feature yet, you can use a range-based for loop to iterate over the elements of a vector and to print them, for example:

\begin{cpp}
for (const auto& value : values) { std::cout << value << ", "; }
\end{cpp}


\mySamllsection{vector Details}

Now that you’ve had a taste of vectors, it’s time to delve into their details.

\mySamllsection{Constructors and Destructors}

The default constructor creates a vector with zero elements.

\begin{cpp}
vector<int> intVector; // Creates a vector of ints with zero elements
\end{cpp}

You can specify a number of elements and, optionally, a value for those elements, like this:

\begin{cpp}
vector<int> intVector(10, 100); // Creates vector of 10 ints with value 100
\end{cpp}

If you omit the default value, the new objects are zero-initialized. Zero-initialization constructs objects with the default constructor and initializes primitive integer types (such as char, int, and so on) to zero, primitive floating-point types to 0.0, and pointer types to nullptr.

You can create vectors of built-in classes like this:

\begin{cpp}
vector<string> stringVector(10, "hello");
\end{cpp}

User-defined classes can also be used as vector elements:

\begin{cpp}
class Element { };
...
vector<Element> elementVector;
\end{cpp}

A vector can be constructed with an initializer\_list containing the initial elements:

\begin{cpp}
vector<int> intVector({ 1, 2, 3, 4, 5, 6 });
\end{cpp}

Uniform initialization, as discussed in Chapter 1, “A Crash Course in C++ and the Standard Library,” works on most Standard Library containers, including vector. Here is an example:

\begin{cpp}
vector<int> intVector = { 1, 2, 3, 4, 5, 6 };
vector<int> intVector { 1, 2, 3, 4, 5, 6 };
\end{cpp}

Thanks to class template argument deduction (CTAD), you can omit the template type parameter. Here is an example:

\begin{cpp}
vector intVector { 1, 2, 3, 4, 5, 6 };
\end{cpp}

Be cautious with uniform initialization, though; usually, when calling a constructor of an object, the uniform initialization syntax can be used. Here’s an example:

\begin{cpp}
string text { "Hello World." };
\end{cpp}

With vector you need be careful. For example, the following line of code calls a vector constructor to create a vector of 10 integers with value 100:

\begin{cpp}
vector<int> intVector(10, 100); // Creates vector of 10 ints with value 100
\end{cpp}

Using uniform initialization here instead as follows does not create a vector of 10 integers, but a vector with just two elements, initialized to 10 and 100:

\begin{cpp}
vector<int> intVector { 10, 100 }; // Creates vector with two elements: 10 and 100
\end{cpp}

You can allocate vectors on the free store as well:

\begin{cpp}
auto elementVector { make_unique<vector<Element>>(10) };
\end{cpp}

\mySamllsection{Copying and Assigning vectors}

A vector stores copies of the objects, and its destructor calls the destructor for each of the objects.
The copy constructor and assignment operator of the vector class perform deep copies of all the elements in the vector. Thus, for efficiency, you should pass vectors by reference-to-non-const or reference-to-const to functions, instead of by value.

In addition to normal copying and assignment, vector provides an assign() member function that removes all the current elements and adds any number of new elements. This member function is useful if you want to reuse a vector. Here is a trivial example. intVector is created with 10 elements having the default value 0. Then assign() is used to remove all 10 elements and replace them with 5 elements with value 100:

\begin{cpp}
vector<int> intVector(10);
println("intVector: {:n}", intVector); // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
...
intVector.assign(5, 100);
println("intVector: {:n}", intVector); // 100, 100, 100, 100, 100
\end{cpp}

assign() can also accept an initializer\_list as follows. After this statement, intVector has four elements with the given values:

\begin{cpp}
intVector.assign({ 1, 2, 3, 4 });
println("intVector: {:n}", intVector); // 1, 2, 3, 4
\end{cpp}

vector provides a swap() member function that allows you to swap the contents of two vectors in constant time. Here is a simple example:

\begin{cpp}
vector<int> vectorOne(10);
vector<int> vectorTwo(5, 100);
println("vectorOne: {:n}", vectorOne); // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
println("vectorTwo: {:n}", vectorTwo); // 100, 100, 100, 100, 100

vectorOne.swap(vectorTwo);

println("vectorOne: {:n}", vectorOne); // 100, 100, 100, 100, 100
println("vectorTwo: {:n}", vectorTwo); // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
\end{cpp}

\mySamllsection{Comparing vectors}

The Standard Library provides the usual six overloaded comparison operators for vectors: ==, !=, <, >, <=, >=. Two vectors are equal if they have the same number of elements and all the corresponding elements in the two vectors are equal to each other. Two vectors are compared lexicographically; that is, one vector is “less than” another if all elements 0 through i–1 in the first vector are equal to elements 0 through i-1 in the second vector, but element i in the first is less than element i in the second, where i must be in the range 0...n and n must be less than the size() of the smallest of the two vectors.

\begin{myNotic}{NOTE}
Comparing two vectors with operator== or != requires the individual elements to be comparable with operator==. Comparing two vectors with operator<, >, <=, or >= requires the individual elements to be comparable with operator<. If you intend to store objects of a custom class in a vector, make sure to write those operators.
\end{myNotic}

Here is an example of a program that compares vectors of ints:

\begin{cpp}
vector<int> vectorOne(10);
vector<int> vectorTwo(10);

if (vectorOne == vectorTwo) { println("equal!"); }
else { println("not equal!"); }

vectorOne[3] = 50;

if (vectorOne < vectorTwo) { println("vectorOne is less than vectorTwo"); }
else { println("vectorOne is not less than vectorTwo"); }
\end{cpp}

The output of the program is as follows:

\begin{shell}
equal!
vectorOne is not less than vectorTwo
\end{shell}

\mySamllsection{vector Iterators}

Chapter 17, “Understanding Iterators and the Ranges Library,” explains the concepts of container iterators. The discussion can get a bit abstract, so it’s helpful to jump in and look at a code example. Here is the last for loop of the test score normalization program from earlier in this chapter:

\begin{cpp}
for (auto& element : doubleVector) {
    element /= max;
    print("{} ", element);
}
\end{cpp}

This loop can be written using iterators instead of a range-based for loop as follows:

\begin{cpp}
for (vector<double>::iterator iter { begin(doubleVector) };
iter != end(doubleVector); ++iter) {
    *iter /= max;
    print("{} ", *iter);
}
\end{cpp}

First, take a look at the for loop initialization statement:

\begin{cpp}
vector<double>::iterator iter { begin(doubleVector) };
\end{cpp}

Recall that every container defines a type named iterator to represent iterators for that type of container. begin() returns an iterator of that type referring to the first element in the container. Thus, the initialization statement obtains in the variable iter an iterator referring to the first element of doubleVector. Next, look at the for loop comparison:

\begin{cpp}
iter != end(doubleVector);
\end{cpp}

This statement simply checks whether the iterator is past the end of the sequence of elements in the vector. When it reaches that point, the loop terminates. Always use operator!= in such statements and not operator< as the latter is not supported by all types of iterators; see Chapter 17 for details.

The increment statement, ++iter, increments the iterator to refer to the next element in the vector.

\begin{myNotic}{NOTE}
Use pre-increment instead of post-increment when possible because preincrement is at least as efficient and usually more efficient. iter++ must return a new iterator object, while ++iter can simply return a reference to iter. See Chapter 15, “Overloading C++ Operators,” for details on implementing both versions of operator++.
\end{myNotic}

The for loop body contains these two lines:

\begin{cpp}
*iter /= max;
print("{} ", *iter);
\end{cpp}

As you can see, your code can both access and modify the elements over which it iterates. The first line uses operator* to dereference iter to obtain the element to which it refers and assigns to that element. The second line dereferences iter again, but this time only to print the element to the standard output console.

The preceding for loop using iterators can be simplified by using the auto keyword:

\begin{cpp}
for (auto iter { begin(doubleVector) };
    iter != end(doubleVector); ++iter) {
    *iter /= max;
    print("{} ", *iter);
}
\end{cpp}

With auto, the compiler automatically deduces the type of the variable iter based on the right-hand side of the initializer, which in this case is the result of the call to begin().

vector supports the following member functions to get iterators:

\begin{itemize}
\item
begin() and end() returning iterators referring to the first and one past the last element

\item
rbegin() and rend() returning reverse iterators referring to the last and one before the first element

\item
cbegin(), cend(), crbegin(), and crend() returning const iterators
\end{itemize}

\begin{myNotic}{NOTE}
If you need to iterate over all elements in a container, it’s recommended to use a range-based for loop instead of iterators as the former is easier to read and write, as well as being less error-prone. Use iterators only when you need to iterate over a subrange or when you need an iterator in the body of the loop.
\end{myNotic}

\mySamllsection{Accessing Fields of Object Elements}

If the elements of your container are objects, you can use the -> operator on iterators to call member functions or access data members of those objects. For example, the following program creates a vector of 10 strings, then iterates over all of them appending a new string to each one:

\begin{cpp}
vector<string> stringVector(10, "hello");
for (auto it { begin(stringVector) }; it != end(stringVector); ++it) {
    it->append(" there");
}
\end{cpp}

Often, using a range-based for loop results in more elegant code, as in this example:

\begin{cpp}
for (auto& str : stringVector) {
    str.append(" there");
}
\end{cpp}

\mySamllsection{const\_iterator}

The normal iterator is read/write. However, if you call begin() or end() on a const object, or you call cbegin() or cend(), you receive a const\_iterator. A const\_iterator is read-only; you cannot modify the element it refers to. An iterator can always be converted to a const\_iterator, so it’s always safe to write something like this:

\begin{cpp}
vector<type>::const_iterator it { begin(myVector) };
\end{cpp}

However, a const\_iterator cannot be converted to an iterator. If myVector is const, the following line doesn’t compile:

\begin{cpp}
vector<type>::iterator it { begin(myVector) };
\end{cpp}

\begin{myNotic}{NOTE}
If you do not need to modify the elements of a vector, you should use a const\_iterator. This rule makes it easier to guarantee correctness of your code and helps the compiler to perform better optimizations.
\end{myNotic}

When using the auto keyword, using const\_iterators looks a bit different. Suppose you write the following code:

\begin{cpp}
vector<string> stringVector(10, "hello");
for (auto iter { begin(stringVector) }; iter != end(stringVector); ++iter) {
    println("{}", *iter);
}
\end{cpp}

Because of the auto keyword, the compiler deduces the type of the iter variable automatically and makes it a normal iterator because stringVector is not const. If you want a read-only const\_iterator in combination with using auto, then you need to use cbegin() and cend() instead of begin() and end() as follows:

\begin{cpp}
for (auto iter { cbegin(stringVector) }; iter != cend(stringVector); ++iter) {
    println("{}", *iter);
}
\end{cpp}

Now the compiler uses const\_iterator as type for the variable iter because that’s what cbegin() returns.

A range-based for loop can also be forced to use const iterators as follows:

\begin{cpp}
for (const auto& element : stringVector) {
    println("{}", element);
}
\end{cpp}

\mySamllsection{Iterator Safety}

Generally, iterators are about as safe as pointers—that is, extremely unsafe. For example, you can write code like this:

\begin{cpp}
vector<int> intVector;
auto iter { end(intVector) };
*iter = 10; // Bug! Iter doesn't refer to a valid element.
\end{cpp}

Recall that the iterator returned by end() is one element past the end of a vector, not an iterator referring to the last element! Trying to dereference it results in undefined behavior. Iterators are not required to perform any verification.

Another problem can occur if you use mismatched iterators. For example, the following for loop initializes iter with an iterator from vectorTwo and tries to compare it to the end iterator of vectorOne. Needless to say, this loop will not do what you intended and may never terminate. Dereferencing the iterator in the loop will likely produce undefined results.

\begin{cpp}
vector<int> vectorOne(10);
vector<int> vectorTwo(10);
// BUG! Possible infinite loop.
for (auto iter { begin(vectorTwo) }; iter != end(vectorOne); ++iter) { /* ... */ }
\end{cpp}

\begin{myNotic}{NOTE}
Microsoft Visual C++, by default, gives an assertion error at run time for both of the preceding problems when running a debug build of your program. By default, no verification of iterators is performed for release builds. You can enable it for release builds as well, but it has a performance penalty.
\end{myNotic}

\mySamllsection{Other Iterator Operations}

The vector iterator is random access, which means you can move it backward and forward, and jump around. For example, the following code eventually changes the fifth element (index 4) to the value 4:

\begin{cpp}
vector<int> intVector(10);
auto it { begin(intVector) };
it += 5;
--it;
*it = 4;
\end{cpp}

\mySamllsection{Iterators vs. Indexing}

Given that you can write a for loop that uses a simple index variable and the size() member function to iterate over the elements of a vector, why should you bother using iterators? That’s a valid question, for which there are three main answers:

\begin{itemize}
\item
Iterators allow you to insert and delete elements and sequences of elements at any point in the container. See the section “Adding and Removing Elements” later in this chapter.

\item
Iterators allow you to use the Standard Library algorithms, which are discussed in Chapter 20, “Mastering Standard Library Algorithms.”

\item
Using an iterator to access each element sequentially is often more efficient than indexing the container to retrieve each element individually. This generalization is not true for vectors, but applies to lists, maps, and sets.
\end{itemize}

\mySamllsection{Storing References in a vector}

As mentioned earlier in this chapter, it is possible to store references in a container, such as a vector. To do this, you store std::reference\_wrappers in the container. The std::ref() and cref() function templates are used to create non-const and const reference\_wrapper instances. The get() member function is used to get access to the object wrapped by a reference\_wrapper. All this is defined in <functional>. Here is an example:

\begin{cpp}
string str1 { "Hello" };
string str2 { "World" };

// Create a vector of references to strings.
vector<reference_wrapper<string>> vec { ref(str1) };

vec.push_back(ref(str2)); // push_back() works as well.
// Modify the string referred to by the second reference in the vector.
vec[1].get() += "!";

// The end result is that str2 is modified.
println("{} {}", str1, str2);
\end{cpp}

\mySamllsection{Adding and Removing Elements}

As you already know, you can append an element to a vector with the push\_back() member function. The vector provides a corresponding remove member function called pop\_back().

\begin{myWarning}{WARNING}
pop\_back() does not return the element that is removed. If you want that element, you must first retrieve it with back().
\end{myWarning}

You can also insert elements at any point in the vector with the insert() member function, which adds one or more elements to a position specified by an iterator, shifting all subsequent elements down to make room for the new ones. There are five different overloads of insert() that do the following:

\begin{itemize}
\item
Insert a single element.

\item
Insert n copies of a single element.

\item
Insert elements from an iterator range. Recall that the iterator range is half-open, such that it includes the element referred to by the starting iterator but not the one referred to by the ending iterator.

\item
Insert a single element by moving the given element to a vector using move semantics.

\item
Insert a list of elements into a vector where the list of elements is given as an initializer\_list.
\end{itemize}

\begin{myNotic}{NOTE}
There are overloads of push\_back() and insert() that take an lvalue or an rvalue as a parameter. Both overloads allocate memory as needed to store the new elements. The lvalue overloads store copies of the given elements, while the rvalue overloads use move semantics to move ownership of the given elements to the vector instead of copying them.
\end{myNotic}

\CXXTwentythreeLogo{-40}{-50}

C++23 adds the following member functions: assign\_range() to replace all elements in a vector with the elements of a given range, insert\_range() to insert all elements of a given range into a vector at a given position, and append\_range() to append all elements of a given range to the end of a vector. Chapter 17 discusses ranges in detail.

You can remove elements from any point in a vector with erase(), and you can remove all elements with clear(). There are two overloads of erase(): one accepting a single iterator to remove a single element, and one accepting two iterators specifying a range of elements to remove.

Let’s look at an example program that demonstrates some of the member functions for adding and removing elements. The following code snippet demonstrates clear(), push\_back(), pop\_back(), the C++23 append\_range(), the two-argument version of erase(), and the following overloads of insert():

\begin{itemize}
\item
insert(const\_iterator pos, const T\& x): The value x is inserted at position pos.

\item
insert(const\_iterator pos, size\_type n, const T\& x): The value x is inserted n times at position pos.

\item
insert(const\_iterator pos, InputIterator first, InputIterator last): The elements in the range [first, last) are inserted at position pos.
\end{itemize}

Here is the code snippet:

\begin{cpp}
vector vectorOne { 1, 2, 3, 5 };
vector<int> vectorTwo;
println("{:n}", vectorOne);

// Oops, we forgot to add 4. Insert it in the correct place.
vectorOne.insert(cbegin(vectorOne) + 3, 4);

// Add elements 6 through 10 to vectorTwo.
for (int i { 6 }; i <= 10; ++i) {
    vectorTwo.push_back(i);
}
println("{:n}", vectorOne);
println("{:n}", vectorTwo);

// Add all elements from vectorTwo to the end of vectorOne.
vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));
println("{:n}", vectorOne);

// Add all vectorTwo elements to the end of vectorOne using C++23 append_range().
// Note how much clearer this is compared to the previous call to insert().
vectorOne.append_range(vectorTwo);
println("{:n}", vectorOne);

// Now erase the numbers 2 through 5 in vectorOne.
vectorOne.erase(cbegin(vectorOne) + 1, cbegin(vectorOne) + 5);
println("{:n}", vectorOne);

// Clear vectorTwo entirely.
vectorTwo.clear();

// And add 10 copies of the value 100.
vectorTwo.insert(cbegin(vectorTwo), 10, 100);
println("{:n}", vectorTwo);

// Decide we only want 9 elements.
vectorTwo.pop_back();
println("{:n}", vectorTwo);
\end{cpp}

The output of the program is as follows:

\begin{shell}
1, 2, 3, 5
1, 2, 3, 4, 5
6, 7, 8, 9, 10
1, 2, 3, 4, 5, 6, 7, 8, 9, 10
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10
1, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10
100, 100, 100, 100, 100, 100, 100, 100, 100, 100
100, 100, 100, 100, 100, 100, 100, 100, 100
\end{shell}

Recall that iterator pairs represent half-open ranges, and insert() adds elements before the element referred to by a given iterator position. Thus, you can insert the entire contents of vectorTwo at the end of vectorOne, like this:

\begin{cpp}
vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));
\end{cpp}

\begin{myWarning}{WARNING}
Member functions such as insert() and erase() that take a common iterator range as argument assume that the beginning and ending iterators refer to elements in the same container and that the end iterator refers to an element at or past the begin iterator. The member functions will not work correctly if these preconditions are not met!
\end{myWarning}

If you want to remove all elements satisfying a condition, one solution would be to write a loop iterating over all the elements and erasing every element that matches the condition. However, this solution has quadratic complexity, which is bad for performance. This quadratic complexity can be avoided by using the remove-erase-idiom, which has a linear complexity. The remove-erase-idiom is discussed in Chapter 20.

Starting with C++20, however, there is a more elegant solution in the form of the std::erase() and std::erase\_if() non-member functions, defined for all Standard Library containers. The former is demonstrated in the following code snippet:

\begin{cpp}
vector values { 1, 2, 3, 2, 1, 2, 4, 5 };
println("{:n}", values);

erase(values, 2); // Removes all values equal to 2.
println("{:n}", values);
\end{cpp}

The output is as follows:

\begin{shell}
1, 2, 3, 2, 1, 2, 4, 5
1, 3, 1, 4, 5
\end{shell}

erase\_if() works similarly, but instead of passing a value as second argument, a predicate is passed that returns true for elements that should be removed, and false for elements that should be kept.

The predicate can take the form of a function pointer, a function object, or a lambda expression, all of which are discussed in detail in Chapter 19, “Function Pointers, Function Objects, and Lambda Expressions.”

\mySamllsection{Move Semantics}

Adding elements to a vector can make use of move semantics to improve performance in certain situations. For example, suppose you have the following vector of strings:

\begin{cpp}
vector<string> vec;
\end{cpp}

You can add an element to this vector as follows:

\begin{cpp}
string myElement(5, 'a'); // Constructs the string "aaaaa"
vec.push_back(myElement);
\end{cpp}

However, because myElement is not a temporary object, push\_back() makes a copy of myElement and puts it into the vector.

The vector class also defines a push\_back(T\&\&), which is the move equivalent of push\_back(const T\&). So, copying can be avoided if you call push\_back() as follows:

\begin{cpp}
vec.push_back(move(myElement));
\end{cpp}

This statement explicitly says that myElement should be moved into the vector. Note that after this call, myElement is in a valid but otherwise indeterminate state. You should not use myElement anymore, unless you first bring it back to a determinate state, for example by calling clear() on it! You can also call push\_back() as follows:

\begin{cpp}
vec.push_back(string(5, 'a'));
\end{cpp}

This call to push\_back() triggers a call to the move overload because the call to the string constructor results in a temporary object. The push\_back() member function moves this temporary string object into the vector, avoiding any copying.

\mySamllsection{Emplace Operations}

C++ supports emplace operations on most Standard Library containers, including vector. Emplace means “to put into place.” An example is the emplace\_back() member function of vector, which does not copy or move anything. Instead, it makes space in the container and constructs the object in place, as in this example:

\begin{cpp}
vec.emplace_back(5, 'a');
\end{cpp}

The emplace member functions take a variable number of arguments as a variadic template. Variadic templates are discussed in Chapter 26, “Advanced Templates,” but those details are not required to understand how to use emplace\_back(). Basically, the arguments passed to emplace\_back() are forwarded to a constructor of the type stored in the vector. The difference in performance between emplace\_back() and push\_back() using move semantics depends on how your specific compiler implements these operations. In most situations, you can pick the one based on the syntax that you prefer:

\begin{cpp}
vec.push_back(string(5, 'a'));
// Or
vec.emplace_back(5, 'a');
\end{cpp}

The emplace\_back() member function returns a reference to the inserted element. There is also an emplace() member function that constructs an object in place at a specific position in the vector and returns an iterator to the inserted element.

\mySamllsection{Algorithmic Complexity and Iterator Invalidation}

Inserting or erasing elements in a vector causes all subsequent elements to shift up or down to make room for, or fill in the holes left by, the affected elements. Thus, these operations take linear complexity. Furthermore, all iterators referring to the insertion or removal point or subsequent positions are invalid following the action. The iterators are not “magically” moved to keep up with the elements that are shifted up or down in the vector—that’s up to you.

Also keep in mind that an internal vector reallocation can cause invalidation of all iterators referring to elements in the vector, not just those referring to elements past the point of insertion or deletion. See the next section for details.

\mySamllsection{vector Example: A Round-Robin Class}

A vector allocates memory automatically to store the elements that you insert. Recall that the vector requirements dictate that the elements must be in contiguous memory, like in standard C-style arrays. Because it’s impossible to request to add memory to the end of a current chunk of memory, every time a vector allocates more memory, it must allocate a new, larger chunk in a separate memory location and copy/move all the elements to the new chunk. This process is time-consuming, so vector implementations attempt to avoid it by allocating more space than needed when they have to perform a reallocation. That way, they can avoid reallocating memory every time you insert an element.

One obvious question at this point is why you, as a client of vector, care how it manages its memory internally. You might think that the principle of abstraction should allow you to disregard the internals of the vector memory allocation scheme. Unfortunately, there are two reasons why you need to understand how it works:

\begin{itemize}
\item
Efficiency: The vector allocation scheme can guarantee that an element insertion runs in amortized constant time: most of the time the operation is constant, but once in a while (if it requires a reallocation), it’s linear. If you are worried about efficiency, you can control when a vector performs reallocations.

\item
Iterator invalidations: A reallocation invalidates all iterators referring to elements in a vector.
\end{itemize}

Thus, the vector interface allows you to query and control the vector reallocations, both explained in the upcoming subsections.

\begin{myWarning}{WARNING}
If you don’t control the reallocations explicitly, you should assume that all insertions cause a reallocation and thus invalidate all iterators.
\end{myWarning}

\mySamllsection{Size and Capacity}

vector provides two member functions for obtaining information about its size: size() and capacity(). The size() member function returns the number of elements in a vector, while capacity() returns the number of elements that it can hold without a reallocation. Thus, the number of elements that you can insert without causing a reallocation is capacity() – size().

\begin{myNotic}{NOTE}
You can query whether a vector is empty with the empty() member function. A vector can be empty but have nonzero capacity.
\end{myNotic}

There are also non-member std::size() and std::empty() global functions, which can be used with all containers. They can also be used with statically allocated C-style arrays not accessed through pointers, and with initializer\_lists. Here is an example of using them with a vector:

\begin{cpp}
vector vec { 1, 2, 3 };
println("{}", size(vec)); // 3
println("{}", empty(vec)); // false
\end{cpp}

Additionally, std::ssize(), a global non-member helper function, returns the size as a signed integral type. Here’s an example:

\begin{cpp}
auto s1 { size(vec) }; // Type is size_t (unsigned)
auto s2 { ssize(vec) }; // Type is long long (signed)
\end{cpp}

\mySamllsection{Reserving Capacity}

If you don’t care about efficiency or iterator invalidations, there is never a need to control the vector memory allocation explicitly. However, if you want to make your program as efficient as possible or you want to guarantee that iterators will not be invalidated, you can force a vector to preallocate enough space to hold all of its elements. Of course, you need to know how many elements it will hold, which is sometimes impossible to predict.

One way to preallocate space is to call reserve(), which allocates enough memory to hold the specified number of elements. The upcoming round-robin class example shows the reserve() member function in action.

\begin{myWarning}{WARNING}
Reserving space for elements changes the capacity, but not the size. That is, it doesn’t actually create elements. Don’t access elements past a vector’s size.
\end{myWarning}

Another way to preallocate space is to specify, in the constructor, or with the resize() or assign() member function, how many elements you want a vector to store. This member function actually creates a vector of that size (and probably of that capacity).

\mySamllsection{Reclaiming All Memory}

A vector automatically allocates more memory if needed; however, it will never release any memory, unless the vector is destroyed. Removing elements from a vector decreases the size of the vector, but never its capacity. How then can you reclaim its memory?

One option is to use the shrink\_to\_fit() member function, which requests a vector to reduce its capacity to its size. However, it’s just a request, and a Standard Library implementation is allowed to ignore this request.

Reclaiming all memory of a vector can be done using the following trick: swap the vector with an empty one. The following code snippet shows how memory of a vector called values can be reclaimed with a single statement. The third line of code constructs a temporary empty defaultconstructed vector of the same type as values and swaps this with values. All memory that was allocated for values now belongs to this temporary vector, which is automatically destroyed at the end of that statement freeing all its memory. The end result is that all memory that was allocated for values is reclaimed, and values is left with a capacity of zero.

\begin{cpp}
vector<int> values;
// Populate values ...
vector<int>().swap(values);
\end{cpp}

\mySamllsection{Directly Accessing the Data}

A vector stores its data contiguously in memory. You can get a pointer to this block of memory with the data() member function.

There is also a non-member std::data() function that can be used to get a pointer to the data. It works for the array and vector containers, strings, statically allocated C-style arrays not accessed through pointers, and initializer\_lists. Here is an example for a vector:

\begin{cpp}
vector vec { 1, 2, 3 };
int* data1 { vec.data() };
int* data2 { data(vec) };
\end{cpp}

Another way to get access to the memory block of a vector is by taking the address of the first element, as in: \&vec[0]. You might find this kind of code in legacy code bases, but it is not safe for empty vectors; as such, I recommend not to use it and instead use data().

\mySamllsection{Move Semantics}

All Standard Library containers support move semantics by including a move constructor and move assignment operator. See Chapter 9 for details on move semantics. Standard Library containers can be returned from functions by value without performance penalty. Take a look at the following function:

\begin{cpp}
vector<int> createVectorOfSize(size_t size)
{
    vector<int> vec(size);
    for (int contents { 0 }; auto& i : vec) { i = contents++; }
    return vec;
}
...
vector<int> myVector;
myVector = createVectorOfSize(123);
\end{cpp}

Without move semantics, assigning the result of createVectorOfSize() to myVector might call the copy assignment operator. With the move semantics support in the Standard Library containers, copying of the vector is avoided. Instead, the assignment to myVector triggers a call to the move assignment operator.

Keep in mind, though, that for move semantics to work properly with Standard Library containers, the move constructor and move assignment operator of the type stored in the container must be marked as noexcept! Why are these move member functions not allowed to throw any exceptions? Imagine that they are allowed to throw exceptions. Now, when adding, for example, new elements to a vector, it might be that the capacity of the vector is not sufficient and that it needs to allocate a bigger block of memory. Subsequently, the vector must either copy or move all the data from the original memory block to the new one. If this would be done using a move member function that can potentially throw, then it might happen that an exception gets thrown when part of the data has already been moved to the new memory block. What can we do then? Not much. To avoid these kinds of problems, Standard Library containers will only use move member functions if they guarantee not to throw any exceptions. If they are not marked noexcept, the copy member functions will be used instead to guarantee strong exception safety.

When implementing your own Standard Library–like containers, there is a useful helper function available called std::move\_if\_noexcept(), defined in <utility>. This can be used to call either the move constructor or the copy constructor depending on whether the move constructor is noexcept. In itself, move\_if\_noexcept() doesn’t do much. It accepts a reference as a parameter and converts it to either an rvalue reference if the move constructor is noexcept or to a reference-toconst otherwise, but this simple trick allows you to call the correct constructor with a single call.

The Standard Library does not provide a similar helper function to call the move assignment operator or copy assignment operator depending on whether the former is noexcept. Implementing one yourself is not too complicated, but requires some template metaprogramming techniques and type traits to inspect properties of types. Both topics are discussed in Chapter 26, which also gives an example of implementing your own move\_assign\_if\_noexcept().

\mySamllsection{vector Example: A Round-Robin Class}

A common problem in computer science is distributing requests among a finite list of resources. For example, a simple operating system could keep a list of processes and assign a time slice (such as 100ms) to each process to let the process perform some of its work. After the time slice is finished, the OS suspends the process, and the next process in the list is given a time slice to perform some of its work. One of the simplest algorithmic solutions to this problem is round-robin scheduling. When the time slice of the last process is finished, the scheduler starts over again with the first process. For example, in the case of three processes, the first-time slice would go to the first process, the second slice to the second process, the third slice to the third process, and the fourth slice back to the first process. The cycle would continue in this way indefinitely.

Suppose that you decide to write a generic round-robin scheduling class that can be used with any type of resource. The class should support adding and removing resources and should support cycling through the resources to obtain the next one. You could use a vector directly, but it’s often helpful to write a wrapper class that provides more directly the functionality you need for your specific application. The following example shows a RoundRobin class template with comments explaining the code.

First, here is the class definition, exported from a module called round\_robin:

\begin{cpp}
export module round_robin;
import std;

// Class template RoundRobin
// Provides simple round-robin semantics for a list of elements.
export template <typename T>
class RoundRobin final
{
    public:
        // Client can give a hint as to the number of expected elements for
        // increased efficiency.
        explicit RoundRobin(std::size_t numExpected = 0);
        // Prevent copy construction and copy assignment
        RoundRobin(const RoundRobin& src) = delete;
        RoundRobin& operator=(const RoundRobin& rhs) = delete;
        // Explicitly default a move constructor and move assignment operator
        RoundRobin(RoundRobin&& src) noexcept = default;
        RoundRobin& operator=(RoundRobin&& rhs) noexcept = default;
        // Appends element to the end of the list. May be called
        // between calls to getNext().
        void add(const T& element);
        // Removes the first (and only the first) element
        // in the list that is equal (with operator==) to element.
        // May be called between calls to getNext().
        void remove(const T& element);
        // Returns the next element in the list, starting with the first,
        // and cycling back to the first when the end of the list is
        // reached, taking into account elements that are added or removed.
        T& getNext();
    private:
        std::vector<T> m_elements;
        typename std::vector<T>::iterator m_nextElement;
};
\end{cpp}

As you can see, the public interface is straightforward: only three member functions plus the constructor. The resources are stored in a vector called m\_elements. The iterator m\_nextElement always refers to the element that will be returned with the next call to getNext(). If getNext() hasn’t been called yet, m\_nextElement is equal to begin(m\_elements). Note the use of the typename keyword in front of the line declaring m\_nextElement. So far, you’ve only seen that keyword used to specify template type parameters, but there is another use for it. You must specify typename explicitly whenever you access a type based on one or more template parameters. In this case, the template parameter T is used to access the iterator type. Thus, you must specify typename.

The class also prevents copy construction and copy assignment because of the m\_nextElement data member. To make copy construction and copy assignment work, you would have to implement an assignment operator and copy constructor and make sure m\_nextElement is valid in the destination object.

The implementation of the RoundRobin class follows with comments explaining the code. Note the use of reserve() in the constructor, and the extensive use of iterators in add(), remove(), and getNext(). The trickiest aspect is handling m\_nextElement in the add() and remove() member functions.

\begin{cpp}
template <typename T> RoundRobin<T>::RoundRobin(std::size_t numExpected)
{
    // If the client gave a guideline, reserve that much space.
    m_elements.reserve(numExpected);

    // Initialize m_nextElement even though it isn't used until
    // there's at least one element.
    m_nextElement = begin(m_elements);
}

// Always add the new element at the end.
template <typename T> void RoundRobin<T>::add(const T& element)
{
    // Even though we add the element at the end, the vector could
    // reallocate and invalidate the m_nextElement iterator with
    // the push_back() call. Take advantage of the random-access
    // iterator features to save our spot.
    // Note: ptrdiff_t is a type capable of storing the difference
    //  between two random-access iterators.
    std::ptrdiff_t pos { m_nextElement - begin(m_elements) };

    // Add the element.
    m_elements.push_back(element);

    // Reset our iterator to make sure it is valid.
    m_nextElement = begin(m_elements) + pos;
}

template <typename T> void RoundRobin<T>::remove(const T& element)
{
    for (auto it { begin(m_elements) }; it != end(m_elements); ++it) {
        if (*it == element) {
            // Removing an element invalidates the m_nextElement iterator
            // if it refers to an element past the point of the removal.
            // Take advantage of the random-access features of the iterator
            // to track the position of the current element after removal.
            std::ptrdiff_t newPos;

            if (m_nextElement == end(m_elements) - 1 &&
                m_nextElement == it) {
                    // m_nextElement refers to the last element in the list,
                    // and we are removing that last element, so wrap back to
                    // the beginning.
                    newPos = 0;
                } else if (m_nextElement <= it) {
                    // Otherwise, if m_nextElement is before or at the one
                    // we're removing, the new position is the same as before.
                    newPos = m_nextElement - begin(m_elements);
                } else {
                    // Otherwise, it's one less than before.
                    newPos = m_nextElement - begin(m_elements) - 1;
                }

                // Erase the element (and ignore the return value).
                m_elements.erase(it);

                // Now reset our iterator to make sure it is valid.
                m_nextElement = begin(m_elements) + newPos;

                return;
            }
        }
    }
template <typename T> T& RoundRobin<T>::getNext()
{
    // First, make sure there are elements.
    if (m_elements.empty()) {
        throw std::out_of_range { "No elements in the list" };
    }

    // Store the current element which we need to return.
    auto& toReturn { *m_nextElement };

    // Increment the iterator modulo the number of elements.
    ++m_nextElement;
    if (m_nextElement == end(m_elements)) { m_nextElement = begin(m_elements); }

    // Return a reference to the element.
    return toReturn;
}
\end{cpp}

Here’s a simple implementation of a scheduler that uses the RoundRobin class template, with comments explaining the code:

\begin{cpp}
// Basic Process class.
class Process final
{
    public:
        // Constructor accepting the name of the process.
        explicit Process(string name) : m_name { move(name) } {}

        // Lets a process perform its work for the duration of a time slice.
        void doWorkDuringTimeSlice()
        {
            println("Process {} performing work during time slice.", m_name);
            // Actual implementation omitted.
        }

        // Needed for the RoundRobin::remove() member function to work.
        bool operator==(const Process&) const = default; // = default since C++20.
    private:
        string m_name;
};

// Basic round-robin based process scheduler.
class Scheduler final
{
    public:
        // Constructor takes a vector of processes.
        explicit Scheduler(const vector<Process>& processes)
        {
            // Add the processes.
            for (auto& process : processes) { m_processes.add(process); }
        }

        // Selects the next process using a round-robin scheduling algorithm
        // and allows it to perform some work during this time slice.
        void scheduleTimeSlice()
        {
            try {
                m_processes.getNext().doWorkDuringTimeSlice();
            } catch (const out_of_range&) {
                println(cerr, "No more processes to schedule.");
            }
        }

        // Removes the given process from the list of processes.
        void removeProcess(const Process& process)
        {
            m_processes.remove(process);
        }
    private:
        RoundRobin<Process> m_processes;
};

int main()
{
    vector processes { Process { "1" }, Process { "2" }, Process { "3" } };

    Scheduler scheduler { processes };
    for (size_t i { 0 }; i < 4; ++i) { scheduler.scheduleTimeSlice(); }

    scheduler.removeProcess(processes[1]);
    println("Removed second process");

    for (size_t i { 0 }; i < 4; ++i) { scheduler.scheduleTimeSlice(); }
}
\end{cpp}

The output should be as follows:

\begin{shell}
Process 1 performing work during time slice.
Process 2 performing work during time slice.
Process 3 performing work during time slice.
Process 1 performing work during time slice.
Removed second process
Process 3 performing work during time slice.
Process 1 performing work during time slice.
Process 3 performing work during time slice.
Process 1 performing work during time slice.
\end{shell}

\mySubsubsection{18.2.2.}{The vector<bool> Specialization}

The C++ standard requires a partial specialization of vector for bools, with the intention that it optimizes space allocation by “packing” the Boolean values. Recall that a bool is either true or false and thus could be represented by a single bit, which can take on exactly two values. C++ does not have a native type that stores exactly one bit. Some compilers represent a Boolean value with a type the same size as a char; other compilers use an int. The vector<bool> specialization is supposed to store the “array of bools” in single bits, thus saving space.

\begin{myNotic}{NOTE}
You can think of the vector<bool> as a bit-field instead of a vector. The bitset container described later in this chapter provides a more fullfeatured bit-field implementation than does vector<bool>. However, the benefit of vector<bool> is that it can change size dynamically.
\end{myNotic}

In a half-hearted attempt to provide some bit-field routines for vector<bool>, there is one additional member function called flip() that complements bits; that is, true becomes false, and false becomes true, similar to the logical NOT operator. This member function can be called either on the container—in which case it complements all the elements in the container—or on a single reference returned from operator[] or a similar member function, in which case it complements that single element.

At this point, you should be wondering how you can call a member function on a reference to bool. The answer is that you can’t. The vector<bool> specialization actually defines a class called reference that serves as a proxy for the underlying bool (or bit). When you call operator[], at(), or a similar member function, then vector<bool> returns a reference object, which is a proxy for the real bool.

\begin{myWarning}{WARNING}
The fact that references returned from vector<bool> are really proxies means that you can’t take their addresses to obtain pointers to the actual elements in the container.
\end{myWarning}

In practice, the little amount of space saved by packing bools hardly seems worth the extra effort. Even worse, accessing and modifying elements in a vector<bool> is much slower than, for example, in a vector<int>. Many C++ experts recommend avoiding vector<bool> in favor of the bitset. If you do need a dynamically sized bit field, then just use something like vector<std::int\_fast8\_t> or vector<unsigned char>. The std::int\_fast8\_t type is defined in <cstdint>. It is a signed integer type for which the compiler has to use the fastest integer type it has that is at least 8 bits.

\mySubsubsection{18.2.3.}{deque}

deque (abbreviation for double-ended queue) is almost identical to vector, but is used far less frequently. It is defined in <deque>. The principal differences are as follows:

\begin{itemize}
\item
Elements are not stored contiguously in memory.

\item
A deque supports true constant-time insertion and removal of elements at both the front and the back (a vector supports amortized constant time at just the back).

\item
A deque provides the following member functions that vector omits:
\begin{itemize}
\item
push\_front(): Inserts an element at the beginning.

\item
pop\_front(): Removes the first element.

\item
emplace\_front(): Creates a new element in-place at the beginning and returns a reference to the inserted element.

\item
prepend\_range(): Adds all elements of a given range to the beginning of a deque.
Available since C++23.
\end{itemize}

\item
A deque never moves its elements to a bigger array (as vector does) when inserting elements at the front or at the back. This also means that a deque does not invalidate any iterators in such cases.

\item
A deque does not expose its memory management scheme via reserve() or capacity().
\end{itemize}

deques are rarely used, as opposed to vectors, so they are not further discussed. Consult a Standard Library Reference for a detailed list of all supported member functions.

\mySubsubsection{18.2.4.}{list}

The Standard Library list class template, defined in <list>, is a standard doubly linked list. It supports constant-time insertion and deletion of elements at any point in the list but provides slow (linear) time access to individual elements. In fact, the list does not even provide random-access operations like operator[]. Only through iterators can you access individual elements.

Most of the list operations are identical to those of vector, including the constructors, destructor, copying operations, assignment operations, and comparison operations. This section focuses on those member functions that differ from those of vector.

\mySamllsection{Accessing Elements}

The only member functions provided by a list to access elements are front() and back(), both of which run in constant time. These member functions return a reference to the first and last elements in a list. All other element access must be performed through iterators.

Just as vector, list supports begin(), end(), rbegin(), rend(), cbegin(), cend(), crbegin(), and crend().

\begin{myWarning}{WARNING}
Lists do not provide random access to elements.
\end{myWarning}

\mySamllsection{Iterators}

A list iterator is bidirectional, not random access like a vector iterator. That means that you cannot add and subtract list iterators from each other or perform other pointer arithmetic on them. For example, if p is a list iterator, you can traverse through the elements of the list by doing ++p or --p, but you cannot use the addition or subtraction operator; p+n and p-n do not work.

\mySamllsection{Adding and Removing Elements}

A list supports the same add and remove element member functions as a vector, including push\_ back(), pop\_back(), emplace(), emplace\_back(), the five forms of insert(), assign\_range(), insert\_range(), append\_range(), the two forms of erase(), and clear(). Like a deque, it also provides push\_front(), emplace\_front(), pop\_front(), and prepend\_range(). Member functions adding or removing a single element run in constant time, once you’ve found the correct position, while member functions adding or removing multiple elements run in linear time. Thus, a list could be appropriate for applications that perform many insertions and deletions from the data structure, but do not need quick index-based element access. But even then, a vector might still be faster. Use a performance profiler to make sure.

\mySamllsection{list Size}

Like deques, and unlike vectors, lists do not expose their underlying memory model. Consequently, they support size(), empty(), and resize(), but not reserve() or capacity(). Note that the size() member function on a list has constant complexity.

\mySamllsection{Special list Operations}

A list provides several special operations that exploit its quick element insertion and deletion. This section provides an overview of some of these operations with examples. Consult a Standard Library Reference for a thorough reference of all the member functions.

\mySamllsection{Splicing}

The linked-list characteristics of a list allow it to splice, or insert, an entire list at any position in another list in constant time. The simplest version of this member function works as follows:

\begin{cpp}
// Store the a words in the main dictionary.
list<string> dictionary { "aardvark", "ambulance" };
// Store the b words.
list<string> bWords { "bathos", "balderdash" };
// Add the c words to the main dictionary.
dictionary.push_back("canticle");
dictionary.push_back("consumerism");
// Splice the b words into the main dictionary.
if (!bWords.empty()) {
    // Get an iterator to the last b word.
    auto iterLastB { --(cend(bWords)) };
    // Iterate up to the spot where we want to insert b words.
    auto it { cbegin(dictionary) };
    for (; it != cend(dictionary); ++it) {
        if (*it > *iterLastB) { break; }
    }
    // Add in the b words. This action removes the elements from bWords.
    dictionary.splice(it, bWords);
}
// Print out the dictionary.
println("{:n:}", dictionary);
\end{cpp}

The result from running this program looks like this:

\begin{shell}
aardvark, ambulance, bathos, balderdash, canticle, consumerism
\end{shell}

There are also two other overloads of splice(): one that inserts a single element from another list and one that inserts a range from another list. Additionally, all overloads of splice() are available with either a normal reference or an rvalue reference to the source list.

\begin{myWarning}{WARNING}
Splicing is destructive to the list passed as an argument, i.e., it removes the spliced elements from one list to insert them into the other.
\end{myWarning}

\mySamllsection{More Efficient Versions of Algorithms}

In addition to splice(), a list provides special implementations of several of the generic Standard Library algorithms. The generic forms are covered in Chapter 20. Here, only the specific versions provided by list are discussed.

\begin{myNotic}{NOTE}
When you have a choice, use the list-specific member functions rather than the generic Standard Library algorithms because the former are more efficient. Sometimes you don’t have a choice, and you must use the list-specific member functions; for example, the generic std::sort() algorithm requires random-access iterators, which a list does not provide.
\end{myNotic}

The following table summarizes the algorithms for which list provides special implementations as member functions. See Chapter 20 for more details on the algorithms.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{MEMBER FUNCTION} &
\textbf{DESCRIPTION} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}remove()\\ remove\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Removes all elements matching certain criteria from a list and returns the\\ number of removed elements.\end{tabular} \\ \hline
unique() &
\begin{tabular}[c]{@{}l@{}}Removes duplicate consecutive elements from a list, based on\\ operator== or a user-supplied binary predicate, and returns the number of\\ removed elements.\end{tabular} \\ \hline
merge() &
\begin{tabular}[c]{@{}l@{}}Merges two lists. Both lists must be sorted according to operator\textless or\\ a user-defined comparator. Like splice(), merge() is destructive to the\\ list passed as an argument.\end{tabular} \\ \hline
sort() &
Performs a stable sort on elements in a list. \\ \hline
reverse() &
Reverses the order of the elements in a list. \\ \hline
\end{longtable}

\mySamllsection{list Example: Determining Enrollment}

Suppose that you are writing a computer registration system for a university. One feature you might provide is the ability to generate a complete list of enrolled students in the university from lists of the students in each class. For the sake of this example, assume that you must write only a single function that takes a vector of lists of student names (as strings), plus a list of students that have been dropped from their courses because they failed to pay tuition. This function should generate a complete list of all the students in all the courses, without any duplicates, and without those students who have been dropped. Note that students might be in more than one course.

Here is the code for this function, with comments explaining the code. With the power of Standard Library lists, the function is practically shorter than its written description! Note that the Standard Library allows you to “nest” containers: in this case, you can use a vector of lists.

\begin{cpp}
// courseStudents is a vector of lists, one for each course. The lists
// contain the students enrolled in those courses. They are not sorted.
//
// droppedStudents is a list of students who failed to pay their
// tuition and so were dropped from their courses.
//
// The function returns a list of every enrolled (non-dropped) student in
// all the courses.
list<string> getTotalEnrollment(const vector<list<string>>& courseStudents,
                                const list<string>& droppedStudents)
{
    list<string> allStudents;

    // Concatenate all the course lists onto the master list
    for (auto& lst : courseStudents) {
        allStudents.append_range(lst);
    }

    // Sort the master list
    allStudents.sort();

    // Remove duplicate student names (those who are in multiple courses).
    allStudents.unique();

    // Remove students who are on the dropped list.
    // Iterate through the dropped list, calling remove on the
    // master list for each student in the dropped list.
    for (auto& str : droppedStudents) {
        allStudents.remove(str);
    }

    // done!
    return allStudents;
}
\end{cpp}

\begin{myNotic}{NOTE}
This example demonstrates the use of the list-specific algorithms. As stated several times before, often a vector is faster than a list. So, the recommended solution to the student enrollment problem would be to only use vectors and to combine these with generic Standard Library algorithms, but those are discussed in Chapter 20.
\end{myNotic}

\mySubsubsection{18.2.5.}{forward\_list}

A forward\_list, defined in <forward\_list>, is similar to a list except that it is a singly linked list, while list is a doubly linked list. This means that forward\_list supports only forward iteration, and because of this, ranges need to be specified differently compared to a list. If you want to modify any list, you need access to the element before the first element of interest. Because a forward\_list does not have an iterator that supports going backward, there is no easy way to get to the preceding element. For this reason, ranges that will be modified—for example, ranges supplied to erase() and splice()—must be open at the beginning. The begin() function that was discussed earlier returns an iterator to the first element and thus can only be used to construct a range that is closed at the beginning. The forward\_list class therefore provides a before\_begin() member function, which returns an iterator that points to an imaginary element before the beginning of the list. You cannot dereference this iterator as it points to invalid data. However, incrementing this iterator by 1 makes it the same as the iterator returned by begin(); as a result, it can be used to make a range that is open at the beginning.

Constructors and assignment operators are similar between a list and a forward\_list. The C++ standard requires that forward\_list minimizes its memory use. That’s the reason why there is no size() member function, because by not providing it, there is no need to store the size of the list. Additionally, a list has to store a pointer to the previous and the next element in the list, while a forward\_list only needs to store a pointer to the next element, further reducing memory use. For example, each element in a list<int> on a 64-bit system requires 20 bytes (two 64-bit pointers, 16 bytes, and the int itself, 4 bytes). A forward\_list<int> requires only 12 bytes (one 64-bit pointer, 8 bytes, and the int, 4 bytes) per element.

The following table sums up the differences between a list and a forward\_list. A filled box (■) means the container supports that operation, while an empty box (□) means the operation is not supported.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{OPERATION}                           & \textbf{list} & \textbf{forward\_list} \\ \hline
\endfirsthead
%
\endhead
%
append\_range() (C++23)                      & ■             & □                      \\ \hline
assign()                                     & ■             & ■                      \\ \hline
assign\_range() (C++23)                      & ■             & ■                      \\ \hline
back()                                       & ■             & □                      \\ \hline
before\_begin()                              & □             & ■                      \\ \hline
begin()                                      & ■             & ■                      \\ \hline
cbefore\_begin()                             & □             & ■                      \\ \hline
cbegin()                                     & ■             & ■                      \\ \hline
cend()                                       & ■             & ■                      \\ \hline
clear()                                      & ■             & ■                      \\ \hline
crbegin()                                    & ■             & □                      \\ \hline
crend()                                      & ■             & □                      \\ \hline
emplace()                                    & ■             & □                      \\ \hline
emplace\_after()                             & □             & ■                      \\ \hline
emplace\_back()                              & ■             & □                      \\ \hline
emplace\_front()                             & ■             & ■                      \\ \hline
empty()                                      & ■             & ■                      \\ \hline
end()                                        & ■             & ■                      \\ \hline
erase()                                      & ■             & □                      \\ \hline
erase\_after()                               & □             & ■                      \\ \hline
front()                                      & ■             & ■                      \\ \hline
insert()                                     & ■             & □                      \\ \hline
insert\_after()                              & □             & ■                      \\ \hline
insert\_range() (C++23)                      & ■             & □                      \\ \hline
insert\_range\_after() (C++23)               & □             & ■                      \\ \hline
iterator / const\_iterator                   & ■             & ■                      \\ \hline
max\_size()                                  & ■             & ■                      \\ \hline
merge()                                      & ■             & ■                      \\ \hline
pop\_back()                                  & ■             & □                      \\ \hline
pop\_front()                                 & ■             & ■                      \\ \hline
prepend\_range() (C++23)                     & ■             & ■                      \\ \hline
push\_back()                                 & ■             & □                      \\ \hline
push\_front()                                & ■             & ■                      \\ \hline
rbegin()                                     & ■             & □                      \\ \hline
remove()                                     & ■             & ■                      \\ \hline
remove\_if()                                 & ■             & ■                      \\ \hline
rend()                                       & ■             & □                      \\ \hline
resize()                                     & ■             & ■                      \\ \hline
reverse()                                    & ■             & ■                      \\ \hline
reverse\_iterator / const\_reverse\_iterator & ■             & □                      \\ \hline
size()                                       & ■             & □                      \\ \hline
sort()                                       & ■             & ■                      \\ \hline
splice()                                     & ■             & □                      \\ \hline
splice\_after()                              & □             & ■                      \\ \hline
swap()                                       & ■             & ■                      \\ \hline
unique()                                     & ■             & ■                      \\ \hline
\end{longtable}

The following example demonstrates the use of forward\_lists:

\begin{cpp}
// Create 3 forward lists using an initializer_list
// to initialize their elements (uniform initialization).
forward_list<int> list1 { 5, 6 };
forward_list list2 { 1, 2, 3, 4 }; // CTAD is supported.
forward_list list3 { 7, 8, 9 };

// Insert list2 at the front of list1 using splice.
list1.splice_after(list1.before_begin(), list2);

// Add number 0 at the beginning of the list1.
list1.push_front(0);

// Insert list3 at the end of list1.
// For this, we first need an iterator to the last element.
auto iter { list1.before_begin() };
auto iterTemp { iter };
while (++iterTemp != end(list1)) { ++iter; }
list1.insert_after(iter, cbegin(list3), cend(list3));

// Output the contents of list1.
println("{:n}", list1);
\end{cpp}

To insert list3 at the end of list1, you need an iterator to the last element of list1. However, because this is a forward\_list, you cannot use --end(list1), so you need to iterate over the list from the beginning and stop at the last element. The output is as follows:

\begin{shell}
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
\end{shell}

\mySubsubsection{18.2.6.}{array}

An array, defined in <array>, is similar to a vector except that it is of a fixed size; it cannot grow or shrink in size. The purpose of a fixed size is to allow an array to be allocated on the stack, rather than always demanding access to the free store as vector does.

For arrays containing primitive types (integers, floating-point numbers, characters, Booleans, and so on), initialization of elements is different compared to how they are initialized for containers such as vector, list, and so on. If no initialization values are given to an array when it is created, then the array elements will be uninitialized, i.e., contain garbage. For other containers, such as vector and list, elements are always initialized, either with given values or using zero initialization. As such, arrays behave virtually identical to C-style arrays.

Just like vectors, arrays support random-access iterators, and elements are stored in contiguous memory. An array has support for front(), back(), at(), and operator[]. It also supports a fill() member function to fill the array with a specific element. Because it is fixed in size, it does not support push\_back(), pop\_back(), insert(), erase(), clear(), resize(), reserve(), capacity(), or any of the range-based member functions. A disadvantage compared to a vector is that the swap() member function of an array runs in linear time, while it has constant complexity for a vector. An array can also not be moved in constant time, while a vector can. An array has a size() member function, which is a clear advantage over C-style arrays. The following example demonstrates how to use the array class. Note that the array declaration requires two template parameters: the first specifies the type of the elements, and the second specifies the fixed number of elements in the array.

\begin{cpp}
// Create an array of 3 integers and initialize them
// with the given initializer_list using uniform initialization.
array<int, 3> arr { 9, 8, 7 };
// Output the size of the array.
println("Array size = {}", arr.size()); // or std::size(arr)
// Output the contents using C++23's support for formatting ranges.
println("{:n}", arr);
// Output the contents again using a range-based for loop.
for (const auto& i : arr) { print("{} ", i); }
println("");

println("Performing arr.fill(3)...");
// Use the fill member function to change the contents of the array.
arr.fill(3);
// Output the contents of the array using iterators.
for (auto iter { cbegin(arr) }; iter != cend(arr); ++iter) {
    print("{} ", *iter);
}
\end{cpp}

The output is as follows:

\begin{shell}
Array size = 3
9, 8, 7
9 8 7
Performing arr.fill(3)...
3 3 3
\end{shell}

You can use the std::get<n>() function template to retrieve an element from an std::array at the given index n. The index has to be a constant expression, so it cannot, for example, be a loop variable. The benefit of using std::get<n>() is that the compiler checks at compile time that the given index is valid; otherwise, it results in a compilation error, as in this example:

\begin{cpp}
array myArray { 11, 22, 33 }; // std::array supports CTAD.
println("{}", std::get<1>(myArray));
println("{}", std::get<10>(myArray)); // BUG! Compilation error!
\end{cpp}

std::to\_array(), defined in <array>, converts a given C-style array to an std::array, using copy-initialization of the elements. The function works only for one-dimensional arrays. Here is a quick example:

\begin{cpp}
auto arr1 { to_array({ 11, 22, 33 }) }; // Type is array<int, 3>

double carray[] { 9, 8, 7, 6 };
auto arr2 { to_array(carray) }; // Type is array<double, 4>
\end{cpp}











因为存储元素的序列，vector、deque、list、forward\_list和array称为顺序容器。了解顺序容器的最佳方式是直接通过vector示例来学习，这应该是首选容器。下一节将详细描述vector容器，然后简要讨论deque、list、forward\_list和array。熟悉了顺序容器，它们之间的切换就很简单了。

\mySubsubsection{18.2.1.}{vector}

标准库的vector容器类似于标准C语言风格的数组：元素存储在连续的内存中，每个元素都有自己的“槽”。可以对vector进行索引，也可以向末尾添加新元素或在其他任何位置插入。向vector中插入和删除元素通常具有线性时间复杂度，尽管这些操作实际上在vector末尾以摊销的常数时间运行，这在本章后面的一节中会进行介绍。随机访问单个元素的复杂度是常数；有关算法复杂性的讨论，请参见第4章。

\mySamllsection{vector 概述}

vector在<vector>中定义为具有两个类型参数的类模板：存储的元素类型和一个分配器类型：

\begin{cpp}
template <typename T, typename Allocator = allocator<T>> class vector;
\end{cpp}

Allocator参数指定了客户端可以设置内存分配器对象的类型，以便使用自定义内存分配。这个模板参数有一个默认值。

\begin{myNotic}{NOTE}
对于大多数应用程序，Allocator模板类型参数的默认值就足够了。本章始终使用默认分配器。如果感兴趣，第25章介绍了更多细节。
\end{myNotic}

std::vector是constexpr（参见第9章），就像std::string一样。vector可以用来在编译时执行操作，并且可以用于constexpr函数和其他constexpr类的实现。

\mySamllsection{固定长度的vector}

使用vector的一种方式是，作为固定长度的数组。vector提供了一个构造函数，允许指定元素的数量，并提供了一个重载的operator[]来访问和修改这些元素。当用于访问vector边界之外的元素时，operator[]的结果未定义，所以编译器可以决定在这种情况下如何表现。例如，Microsoft Visual C++的默认行为是在调试模式下编译程序时显示运行时错误消息，并在发布模式下禁用任何边界检查以提高性能，可以修改这些默认行为。

\begin{myWarning}{WARNING}
与“真实”数组索引一样，vector上的operator[]不提供边界检查。
\end{myWarning}

除了使用operator[]之外，还可以通过at()、front()和back()访问vector元素。at()成员函数与operator[]相同，除了它执行边界检查，如果索引超出边界，则抛出一个out\_of\_range异常。front()和back()分别返回对vector的第一个和最后一个元素的引用，在空容器上调用front()或back()将触发未定义行为。

\begin{myNotic}{NOTE}
所有vector元素访问的复杂度都是常数。
\end{myNotic}

这里有一个小程序示例，用于“标准化”测试分数，使最高分设置为100，其他所有分数相应调整。程序创建一个包含十个双精度浮点数的vector，从用户那里读取十个值，将每个值除以最大分数（乘以100），并打印新值。为了创建vector，使用了圆括号(10)，而不是统一初始化大括号{10}，因为后者将创建只有一个值为10的元素的vector。为了简洁起见，省略了错误检查部分的代码。

\begin{cpp}
vector<double> doubleVector(10); // Create a vector of 10 doubles.

// Initialize max to smallest number.
double max { -numeric_limits<double>::infinity() };

for (size_t i { 0 }; i < doubleVector.size(); ++i) {
    print("Enter score {}: ", i + 1);
    cin >> doubleVector[i];
    if (doubleVector[i] > max) {
        max = doubleVector[i];
    }
}

max /= 100.0;
for (auto& element : doubleVector) {
    element /= max;
    print("{} ", element);
}
\end{cpp}

从这个例子中可以看出，可以像使用标准C语言风格的数组一样使用vector。注意，第一个for循环使用size()成员函数来确定容器中的元素数量。这个例子还演示了使用范围基于for循环的vector，因为需要引用，范围基于for循环使用auto\&，而不是auto，这样每个迭代中都可以修改实际元素。

\begin{myNotic}{NOTE}
vector上的operator[]通常返回对元素的引用，该引用可以用在赋值语句的左侧。如果在const vector对象上调用operator[]，将返回对const元素的引用，该引用不能用作赋值的目标。有关如何实现这个技巧的详细信息，请参见第15章。
\end{myNotic}

\mySamllsection{动态 vector}

vector的真正强大之处在于其动态增长的能力。例如，考虑上一节中的测试分数归一化程序，并增加了处理任意数量测试分数的要求。这是新版本：

\begin{cpp}
vector<double> doubleVector; // Create a vector with zero elements.

// Initialize max to smallest number.
double max { -numeric_limits<double>::infinity() };

for (size_t i { 1 }; true; ++i) {
    double value;
    print("Enter score {} (-1 to stop): ", i);
    cin >> value;
    if (value == -1) {
        break;
    }
    doubleVector.push_back(value);
    if (value > max) {
        max = value;
    }
}

max /= 100.0;
for (auto& element : doubleVector) {
    element /= max;
    print("{} ", element);
}
\end{cpp}

这个版本使用默认构造函数创建一个零元素的vector。当每个分数读取时，通过push\_back()成员函数添加到vector末尾，该函数负责为新元素分配空间。范围基于的for循环，不需要任何更改。

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{格式化和打印vector}

从C++23开始，std::format()和print()函数可以用来格式化和打印整个容器，只需一条语句。这对所有标准库顺序容器、容器适配器和关联容器都有效，并在第2章中介绍。这是一个例子：

\begin{cpp}
vector values { 1.1, 2.2, 3.3 };
println("{}", values); // Prints the following: [1.1, 2.2, 3.3]
\end{cpp}

可以指定格式说明符n来去除方括号：

\begin{cpp}
println("{:n}", values); // Prints the following: 1.1, 2.2, 3.3
\end{cpp}

如果编译器还不支持这个特性，可以使用基于范围的for循环来遍历vector元素，并打印它们：

\begin{cpp}
for (const auto& value : values) { std::cout << value << ", "; }
\end{cpp}


\mySamllsection{vector其他细节}

现在已经对vector有了初步了解，是时候深入探讨其细节了。

\mySamllsection{构造函数和析构函数}

默认构造函数创建一个零元素的vector。

\begin{cpp}
vector<int> intVector; // Creates a vector of ints with zero elements
\end{cpp}

可以指定元素的数量，并可选地指定这些元素的值：

\begin{cpp}
vector<int> intVector(10, 100); // Creates vector of 10 ints with value 100
\end{cpp}

如果省略了默认值，新的对象会进行零初始化。零初始化使用默认构造函数构造对象，并将原始整数类型（如char、int等）初始化为零，原始浮点类型初始化为0.0，指针类型初始化为nullptr。

可以像这样创建内置类的vector：

\begin{cpp}
vector<string> stringVector(10, "hello");
\end{cpp}

用户定义的类也可以用作vector元素：

\begin{cpp}
class Element { };
...
vector<Element> elementVector;
\end{cpp}

vector也可以用包含初始元素的initializer\_list来构造：

\begin{cpp}
vector<int> intVector({ 1, 2, 3, 4, 5, 6 });
\end{cpp}

正如第1章中介绍，统一初始化适用于大多数标准库容器，包括vector。这里有一个例子：

\begin{cpp}
vector<int> intVector = { 1, 2, 3, 4, 5, 6 };
vector<int> intVector { 1, 2, 3, 4, 5, 6 };
\end{cpp}

由于类模板参数推导（CTAD），可以省略模板类型参数：

\begin{cpp}
vector intVector { 1, 2, 3, 4, 5, 6 };
\end{cpp}

不过，使用统一初始化时要小心；通常，在调用对象的构造函数时，可以使用统一初始化语法：

\begin{cpp}
string text { "Hello World." };
\end{cpp}

使用vector时需要小心。例如，下面的代码行调用vector构造函数，来创建一个包含10个值为100的整数vector：

\begin{cpp}
vector<int> intVector(10, 100); // Creates vector of 10 ints with value 100
\end{cpp}

这里使用统一初始化，并不是创建一个包含10个整数的vector，而是创建一个只有两个元素，初始化为10和100的vector：

\begin{cpp}
vector<int> intVector { 10, 100 }; // Creates vector with two elements: 10 and 100
\end{cpp}

还可以在堆区上分配vector：

\begin{cpp}
auto elementVector { make_unique<vector<Element>>(10) };
\end{cpp}

\mySamllsection{vector的复制和赋值}

vector存储对象副本，并且其析构函数会为每个对象调用析构函数。

vector类的复制构造函数和赋值运算符对vector中的所有元素执行深拷贝，为了效率应该通过引用为非常量或引用为常量，而不是通过值将vector传递给函数。

除了正常的复制和赋值外，vector还提供了一个assign()成员函数，该函数删除所有当前元素并添加任意数量的新元素。如果想要重用vector，这个成员函数很有用。这里有一个简单的例子。intVector用10个默认值为0的元素创建，然后使用assign()删除所有10个元素，并用5个值为100的元素替换：

\begin{cpp}
vector<int> intVector(10);
println("intVector: {:n}", intVector); // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
...
intVector.assign(5, 100);
println("intVector: {:n}", intVector); // 100, 100, 100, 100, 100
\end{cpp}

assign()也可以接受一个initializer\_list，如下所示。此语句之后，intVector具有给定值的四个元素：

\begin{cpp}
intVector.assign({ 1, 2, 3, 4 });
println("intVector: {:n}", intVector); // 1, 2, 3, 4
\end{cpp}

vector提供了一个swap()成员函数，允许在常数时间内交换两个vector的内容。这里有一个简单的例子：

\begin{cpp}
vector<int> vectorOne(10);
vector<int> vectorTwo(5, 100);
println("vectorOne: {:n}", vectorOne); // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
println("vectorTwo: {:n}", vectorTwo); // 100, 100, 100, 100, 100

vectorOne.swap(vectorTwo);

println("vectorOne: {:n}", vectorOne); // 100, 100, 100, 100, 100
println("vectorTwo: {:n}", vectorTwo); // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
\end{cpp}

\mySamllsection{比较vector}

标准库为vector提供了通常的六个重载比较运算符：==, !=, <, >, <=, >=。如果两个vector具有相同数量的元素，并且两个vector中对应的元素彼此相等，则这两个vector相等。两个vector按字典顺序比较，如果一个vector在元素0到i-1之间与另一个向量在元素0到i-1之间相等，但第一个向量的元素i小于第二个vector的元素i，则一个vector“小于”另一个vector，其中i必须在范围0...n内，并且n必须小于两个vector中较小者的size()。

\begin{myNotic}{NOTE}
使用operator==或!=比较两个vector，需要各个元素都可以使用operator==才能进行比较。使用operator<, >, <=, 或>=比较两个vector需要各个元素可以使用operator<进行比较。如果打算在vector中存储自定义类的对象，请确保支持这些运算符。
\end{myNotic}

这里有一个比较vector<int>的例子：

\begin{cpp}
vector<int> vectorOne(10);
vector<int> vectorTwo(10);

if (vectorOne == vectorTwo) { println("equal!"); }
else { println("not equal!"); }

vectorOne[3] = 50;

if (vectorOne < vectorTwo) { println("vectorOne is less than vectorTwo"); }
else { println("vectorOne is not less than vectorTwo"); }
\end{cpp}

输出为：

\begin{shell}
equal!
vectorOne is not less than vectorTwo
\end{shell}

\mySamllsection{vector迭代器}

第17章介绍了容器迭代器的概念。讨论起来会有些抽象，通过查看代码示例会好一些。这是本章前面测试分数标准化程序中最后一个for循环：

\begin{cpp}
for (auto& element : doubleVector) {
    element /= max;
    print("{} ", element);
}
\end{cpp}

这个循环可以使用迭代器，而不是范围基于for循环来写：

\begin{cpp}
for (vector<double>::iterator iter { begin(doubleVector) };
iter != end(doubleVector); ++iter) {
    *iter /= max;
    print("{} ", *iter);
}
\end{cpp}

首先，看一下for循环的初始化语句：

\begin{cpp}
vector<double>::iterator iter { begin(doubleVector) };
\end{cpp}

回忆一下，每个容器都定义了一个名为iterator的类型，用于表示该类型容器的迭代器。begin()返回一个指向容器中第一个元素的该类型迭代器，所以初始化语句在变量iter中获取了一个指向doubleVector第一个元素的迭代器。接下来，看一下for循环的比较：

\begin{cpp}
iter != end(doubleVector);
\end{cpp}

这个语句简单地检查迭代器，是否超过了vector中元素序列的末尾；到达该点时，循环终止。这样的语句中总是使用operator!=，而不是operator<，因为后者不是所有类型的迭代器都支持；详见第17章。

增量语句，++iter，将迭代器增加以引用vector中的下一个元素。

\begin{myNotic}{NOTE}
尽可能使用前缀递增，而不是后缀递增。前缀递增至少和后缀递增一样高效，通常更高效。iter++必须返回一个新的迭代器对象，而++iter可以直接返回对iter的引用。有关实现operator++两个版本的详细信息，请参见第15章。
\end{myNotic}

for循环体包含以下两行：

\begin{cpp}
*iter /= max;
print("{} ", *iter);
\end{cpp}

如你所见，代码可以访问和修改它迭代的元素。第一行使用operator*来取消iter的引用，以获取它所引用的元素，并赋值给该元素。第二行再次取消iter的引用，但这次只是为了将元素打印到标准输出控制台。

前面的使用迭代器的for循环，可以通过使用auto关键字简化：

\begin{cpp}
for (auto iter { begin(doubleVector) };
    iter != end(doubleVector); ++iter) {
    *iter /= max;
    print("{} ", *iter);
}
\end{cpp}

使用auto，编译器会根据初始化表达式的右侧自动推导变量iter的类型，在这种情况下的类型为调用begin()的结果类型。

vector支持以下成员函数来获取迭代器：

\begin{itemize}
\item
begin()和end()返回指向第一个元素和最后一个元素之后的位置的迭代器

\item
rbegin()和rend()返回指向最后一个元素和第一个元素之前的位置的反向迭代器

\item
cbegin(), cend(), crbegin()和crend()返回常量迭代器
\end{itemize}

\begin{myNotic}{NOTE}
如果需要遍历容器中的所有元素，建议使用范围基于for循环，而不是迭代器。因为前者更易于阅读和编写，且出错率更低。仅在需要遍历子范围或在循环体中需要迭代器时，再使用迭代器。
\end{myNotic}

\mySamllsection{访问对象元素的字段}

如果容器的元素是对象，可以在迭代器上使用->运算符来调用这些对象的成员函数或访问数据成员。例如，下面的程序创建了一个包含10个字符串的vector，然后遍历所有字符串，并将一个新字符串附加到每个字符串：

\begin{cpp}
vector<string> stringVector(10, "hello");
for (auto it { begin(stringVector) }; it != end(stringVector); ++it) {
    it->append(" there");
}
\end{cpp}

通常，使用基于范围的for循环可以使代码更简洁，如本例所示：

\begin{cpp}
for (auto& str : stringVector) {
    str.append(" there");
}
\end{cpp}

\mySamllsection{const\_iterator}

普通迭代器可读写，如果在const对象上调用begin()或end()，或者调用cbegin()或cend()，会得到一个const\_iterator。const\_iterator是只读的；不能修改它所引用的元素。迭代器可以转换为const\_iterator，所以写这样的代码是安全的：

\begin{cpp}
vector<type>::const_iterator it { begin(myVector) };
\end{cpp}

然而，const\_iterator不能转换为迭代器。如果myVector是const，下面的代码将无法编译：

\begin{cpp}
vector<type>::iterator it { begin(myVector) };
\end{cpp}

\begin{myNotic}{NOTE}
如果你不需要修改vector的元素，应该使用const\_iterator。这个规则可以更容易地保证你代码的正确性，并帮助编译器进行更好的优化。
\end{myNotic}

当使用auto关键字时，使用const\_iterators看起来会有点不同。假设写了以下代码：

\begin{cpp}
vector<string> stringVector(10, "hello");
for (auto iter { begin(stringVector) }; iter != end(stringVector); ++iter) {
    println("{}", *iter);
}
\end{cpp}

由于使用了auto关键字，编译器会自动推导iter变量的类型，并使其成为一个普通迭代器，因为stringVector不是const。如果想要一个只读的const\_iterator与auto结合使用，那么需要使用cbegin()和cend()，而不是begin()和end()：

\begin{cpp}
for (auto iter { cbegin(stringVector) }; iter != cend(stringVector); ++iter) {
    println("{}", *iter);
}
\end{cpp}

现在编译器使用const\_iterator作为iter变量的类型，这是cbegin()返回的类型。

基于范围的for循环也可以强制使用const迭代器，如下所示：

\begin{cpp}
for (const auto& element : stringVector) {
    println("{}", element);
}
\end{cpp}

\mySamllsection{迭代器的安全性}

通常，迭代器的安全性类似于指针——非常不安全。例如，可以这样写代码：

\begin{cpp}
vector<int> intVector;
auto iter { end(intVector) };
*iter = 10; // Bug! Iter doesn't refer to a valid element.
\end{cpp}

回想一下，end()返回的迭代器是指向vector末尾之后的迭代器，而不是指向最后一个元素的迭代器！因为迭代器不需要执行任何验证，所以尝试解引将导致未定义行为。

另一个问题可能发生在使用不匹配的迭代器时。例如，下面的for循环用vectorTwo的迭代器初始化iter，并尝试将其与vectorOne的end迭代器进行比较。不用说，这个循环不会做预期的事情，可能永远不会终止。在循环中解引用迭代器，很可能会产生未定义的结果。

\begin{cpp}
vector<int> vectorOne(10);
vector<int> vectorTwo(10);
// BUG! Possible infinite loop.
for (auto iter { begin(vectorTwo) }; iter != end(vectorOne); ++iter) { /* ... */ }
\end{cpp}

\begin{myNotic}{NOTE}
Microsoft Visual C++默认在调试构建的程序中，为前两个问题提供运行时断言错误。默认情况下，Release构建不执行迭代器的验证。可以为Release构建启用它，但这会有性能损失。
\end{myNotic}

\mySamllsection{其他迭代器的操作}

vector迭代器是随机访问的，所以可以向前或向后移动它，并且可以跳转。例如，以下代码最终将第5个元素（索引4）更改为值4：

\begin{cpp}
vector<int> intVector(10);
auto it { begin(intVector) };
it += 5;
--it;
*it = 4;
\end{cpp}

\mySamllsection{迭代器与索引}

既然可以写一个for循环，使用简单的索引变量和size()成员函数来遍历vector的元素，为什么还要使用迭代器呢？这是一个好问题，主要有三个答案：

\begin{itemize}
\item
迭代器允许在容器的任何位置插入和删除元素以及元素序列。

\item
迭代器允许你使用标准库算法，这些算法在第20章中介绍。

\item
使用迭代器顺序访问每个元素，通常比索引容器以单独获取每个元素更有效。这对vector不适用，但适用于list、map和set。
\end{itemize}

\mySamllsection{vector中存储引用}

如本章前面提到的，可以将引用存储在容器中，如vector。要做到这一点，可以在容器中存储std::reference\_wrapper，使用std::ref()和cref()函数模板创建非const和const reference\_wrapper实例。使用get()成员函数来获取reference\_wrapper包装的对象，所有这些都在<functional>中定义。以下是一个示例：

\begin{cpp}
string str1 { "Hello" };
string str2 { "World" };

// Create a vector of references to strings.
vector<reference_wrapper<string>> vec { ref(str1) };

vec.push_back(ref(str2)); // push_back() works as well.
// Modify the string referred to by the second reference in the vector.
vec[1].get() += "!";

// The end result is that str2 is modified.
println("{} {}", str1, str2);
\end{cpp}

\mySamllsection{添加和删除元素}

如你所知，可以使用push\_back()成员函数向vector追加一个元素。vector提供一个相应的名为pop\_back()的删除成员函数。

\begin{myWarning}{WARNING}
pop\_back()不会返回删除的元素。如果想保留那个元素，必须使用back()先获取。
\end{myWarning}

还可以使用insert()成员函数，在vector的任何位置插入元素，该函数将一个或多个元素添加到由迭代器指定的位置，并将所有后续元素下移以为新元素腾出空间。insert()有五个不同的重载版本，分别执行以下操作：

\begin{itemize}
\item
插入一个元素。

\item
插入n个元素的副本。

\item
插入一个迭代器范围内的元素。迭代器范围是半开放的，包括起始迭代器所引用的元素，但不包括结束迭代器所引用的元素。

\item
通过移动语义将单个元素插入到vector中。

\item
将一个元素列表初始化列表插入到vector中，其中元素列表作为初始化列表给出。
\end{itemize}

\begin{myNotic}{NOTE}
push\_back()和insert()有接受左值或右值作为参数的重载版本，两个重载版本都会根据需要分配内存以存储新元素。左值重载存储给定元素的副本，而右值重载使用移动语义将给定元素的所有权移动到vector中，而非复制。
\end{myNotic}

\CXXTwentythreeLogo{-40}{-50}

C++23 adds the following member functions: assign\_range() to replace all elements in a vector with the elements of a given range, insert\_range() to insert all elements of a given range into a vector at a given position, and append\_range() to append all elements of a given range to the end of a vector. Chapter 17 discusses ranges in detail.

You can remove elements from any point in a vector with erase(), and you can remove all elements with clear(). There are two overloads of erase(): one accepting a single iterator to remove a single element, and one accepting two iterators specifying a range of elements to remove.

Let’s look at an example program that demonstrates some of the member functions for adding and removing elements. The following code snippet demonstrates clear(), push\_back(), pop\_back(), the C++23 append\_range(), the two-argument version of erase(), and the following overloads of insert():

\begin{itemize}
\item
insert(const\_iterator pos, const T\& x): The value x is inserted at position pos.

\item
insert(const\_iterator pos, size\_type n, const T\& x): The value x is inserted n times at position pos.

\item
insert(const\_iterator pos, InputIterator first, InputIterator last): The elements in the range [first, last) are inserted at position pos.
\end{itemize}

Here is the code snippet:

\begin{cpp}
vector vectorOne { 1, 2, 3, 5 };
vector<int> vectorTwo;
println("{:n}", vectorOne);

// Oops, we forgot to add 4. Insert it in the correct place.
vectorOne.insert(cbegin(vectorOne) + 3, 4);

// Add elements 6 through 10 to vectorTwo.
for (int i { 6 }; i <= 10; ++i) {
    vectorTwo.push_back(i);
}
println("{:n}", vectorOne);
println("{:n}", vectorTwo);

// Add all elements from vectorTwo to the end of vectorOne.
vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));
println("{:n}", vectorOne);

// Add all vectorTwo elements to the end of vectorOne using C++23 append_range().
// Note how much clearer this is compared to the previous call to insert().
vectorOne.append_range(vectorTwo);
println("{:n}", vectorOne);

// Now erase the numbers 2 through 5 in vectorOne.
vectorOne.erase(cbegin(vectorOne) + 1, cbegin(vectorOne) + 5);
println("{:n}", vectorOne);

// Clear vectorTwo entirely.
vectorTwo.clear();

// And add 10 copies of the value 100.
vectorTwo.insert(cbegin(vectorTwo), 10, 100);
println("{:n}", vectorTwo);

// Decide we only want 9 elements.
vectorTwo.pop_back();
println("{:n}", vectorTwo);
\end{cpp}

The output of the program is as follows:

\begin{shell}
1, 2, 3, 5
1, 2, 3, 4, 5
6, 7, 8, 9, 10
1, 2, 3, 4, 5, 6, 7, 8, 9, 10
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10
1, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10
100, 100, 100, 100, 100, 100, 100, 100, 100, 100
100, 100, 100, 100, 100, 100, 100, 100, 100
\end{shell}

Recall that iterator pairs represent half-open ranges, and insert() adds elements before the element referred to by a given iterator position. Thus, you can insert the entire contents of vectorTwo at the end of vectorOne, like this:

\begin{cpp}
vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));
\end{cpp}

\begin{myWarning}{WARNING}
Member functions such as insert() and erase() that take a common iterator range as argument assume that the beginning and ending iterators refer to elements in the same container and that the end iterator refers to an element at or past the begin iterator. The member functions will not work correctly if these preconditions are not met!
\end{myWarning}

If you want to remove all elements satisfying a condition, one solution would be to write a loop iterating over all the elements and erasing every element that matches the condition. However, this solution has quadratic complexity, which is bad for performance. This quadratic complexity can be avoided by using the remove-erase-idiom, which has a linear complexity. The remove-erase-idiom is discussed in Chapter 20.

Starting with C++20, however, there is a more elegant solution in the form of the std::erase() and std::erase\_if() non-member functions, defined for all Standard Library containers. The former is demonstrated in the following code snippet:

\begin{cpp}
vector values { 1, 2, 3, 2, 1, 2, 4, 5 };
println("{:n}", values);

erase(values, 2); // Removes all values equal to 2.
println("{:n}", values);
\end{cpp}

The output is as follows:

\begin{shell}
1, 2, 3, 2, 1, 2, 4, 5
1, 3, 1, 4, 5
\end{shell}

erase\_if() works similarly, but instead of passing a value as second argument, a predicate is passed that returns true for elements that should be removed, and false for elements that should be kept.

The predicate can take the form of a function pointer, a function object, or a lambda expression, all of which are discussed in detail in Chapter 19, “Function Pointers, Function Objects, and Lambda Expressions.”

\mySamllsection{Move Semantics}

Adding elements to a vector can make use of move semantics to improve performance in certain situations. For example, suppose you have the following vector of strings:

\begin{cpp}
vector<string> vec;
\end{cpp}

You can add an element to this vector as follows:

\begin{cpp}
string myElement(5, 'a'); // Constructs the string "aaaaa"
vec.push_back(myElement);
\end{cpp}

However, because myElement is not a temporary object, push\_back() makes a copy of myElement and puts it into the vector.

The vector class also defines a push\_back(T\&\&), which is the move equivalent of push\_back(const T\&). So, copying can be avoided if you call push\_back() as follows:

\begin{cpp}
vec.push_back(move(myElement));
\end{cpp}

This statement explicitly says that myElement should be moved into the vector. Note that after this call, myElement is in a valid but otherwise indeterminate state. You should not use myElement anymore, unless you first bring it back to a determinate state, for example by calling clear() on it! You can also call push\_back() as follows:

\begin{cpp}
vec.push_back(string(5, 'a'));
\end{cpp}

This call to push\_back() triggers a call to the move overload because the call to the string constructor results in a temporary object. The push\_back() member function moves this temporary string object into the vector, avoiding any copying.

\mySamllsection{Emplace Operations}

C++ supports emplace operations on most Standard Library containers, including vector. Emplace means “to put into place.” An example is the emplace\_back() member function of vector, which does not copy or move anything. Instead, it makes space in the container and constructs the object in place, as in this example:

\begin{cpp}
vec.emplace_back(5, 'a');
\end{cpp}

The emplace member functions take a variable number of arguments as a variadic template. Variadic templates are discussed in Chapter 26, “Advanced Templates,” but those details are not required to understand how to use emplace\_back(). Basically, the arguments passed to emplace\_back() are forwarded to a constructor of the type stored in the vector. The difference in performance between emplace\_back() and push\_back() using move semantics depends on how your specific compiler implements these operations. In most situations, you can pick the one based on the syntax that you prefer:

\begin{cpp}
vec.push_back(string(5, 'a'));
// Or
vec.emplace_back(5, 'a');
\end{cpp}

The emplace\_back() member function returns a reference to the inserted element. There is also an emplace() member function that constructs an object in place at a specific position in the vector and returns an iterator to the inserted element.

\mySamllsection{Algorithmic Complexity and Iterator Invalidation}

Inserting or erasing elements in a vector causes all subsequent elements to shift up or down to make room for, or fill in the holes left by, the affected elements. Thus, these operations take linear complexity. Furthermore, all iterators referring to the insertion or removal point or subsequent positions are invalid following the action. The iterators are not “magically” moved to keep up with the elements that are shifted up or down in the vector—that’s up to you.

Also keep in mind that an internal vector reallocation can cause invalidation of all iterators referring to elements in the vector, not just those referring to elements past the point of insertion or deletion. See the next section for details.

\mySamllsection{vector Example: A Round-Robin Class}

A vector allocates memory automatically to store the elements that you insert. Recall that the vector requirements dictate that the elements must be in contiguous memory, like in standard C-style arrays. Because it’s impossible to request to add memory to the end of a current chunk of memory, every time a vector allocates more memory, it must allocate a new, larger chunk in a separate memory location and copy/move all the elements to the new chunk. This process is time-consuming, so vector implementations attempt to avoid it by allocating more space than needed when they have to perform a reallocation. That way, they can avoid reallocating memory every time you insert an element.

One obvious question at this point is why you, as a client of vector, care how it manages its memory internally. You might think that the principle of abstraction should allow you to disregard the internals of the vector memory allocation scheme. Unfortunately, there are two reasons why you need to understand how it works:

\begin{itemize}
\item
Efficiency: The vector allocation scheme can guarantee that an element insertion runs in amortized constant time: most of the time the operation is constant, but once in a while (if it requires a reallocation), it’s linear. If you are worried about efficiency, you can control when a vector performs reallocations.

\item
Iterator invalidations: A reallocation invalidates all iterators referring to elements in a vector.
\end{itemize}

Thus, the vector interface allows you to query and control the vector reallocations, both explained in the upcoming subsections.

\begin{myWarning}{WARNING}
If you don’t control the reallocations explicitly, you should assume that all insertions cause a reallocation and thus invalidate all iterators.
\end{myWarning}

\mySamllsection{Size and Capacity}

vector provides two member functions for obtaining information about its size: size() and capacity(). The size() member function returns the number of elements in a vector, while capacity() returns the number of elements that it can hold without a reallocation. Thus, the number of elements that you can insert without causing a reallocation is capacity() – size().

\begin{myNotic}{NOTE}
You can query whether a vector is empty with the empty() member function. A vector can be empty but have nonzero capacity.
\end{myNotic}

There are also non-member std::size() and std::empty() global functions, which can be used with all containers. They can also be used with statically allocated C-style arrays not accessed through pointers, and with initializer\_lists. Here is an example of using them with a vector:

\begin{cpp}
vector vec { 1, 2, 3 };
println("{}", size(vec)); // 3
println("{}", empty(vec)); // false
\end{cpp}

Additionally, std::ssize(), a global non-member helper function, returns the size as a signed integral type. Here’s an example:

\begin{cpp}
auto s1 { size(vec) }; // Type is size_t (unsigned)
auto s2 { ssize(vec) }; // Type is long long (signed)
\end{cpp}

\mySamllsection{Reserving Capacity}

If you don’t care about efficiency or iterator invalidations, there is never a need to control the vector memory allocation explicitly. However, if you want to make your program as efficient as possible or you want to guarantee that iterators will not be invalidated, you can force a vector to preallocate enough space to hold all of its elements. Of course, you need to know how many elements it will hold, which is sometimes impossible to predict.

One way to preallocate space is to call reserve(), which allocates enough memory to hold the specified number of elements. The upcoming round-robin class example shows the reserve() member function in action.

\begin{myWarning}{WARNING}
Reserving space for elements changes the capacity, but not the size. That is, it doesn’t actually create elements. Don’t access elements past a vector’s size.
\end{myWarning}

Another way to preallocate space is to specify, in the constructor, or with the resize() or assign() member function, how many elements you want a vector to store. This member function actually creates a vector of that size (and probably of that capacity).

\mySamllsection{Reclaiming All Memory}

A vector automatically allocates more memory if needed; however, it will never release any memory, unless the vector is destroyed. Removing elements from a vector decreases the size of the vector, but never its capacity. How then can you reclaim its memory?

One option is to use the shrink\_to\_fit() member function, which requests a vector to reduce its capacity to its size. However, it’s just a request, and a Standard Library implementation is allowed to ignore this request.

Reclaiming all memory of a vector can be done using the following trick: swap the vector with an empty one. The following code snippet shows how memory of a vector called values can be reclaimed with a single statement. The third line of code constructs a temporary empty defaultconstructed vector of the same type as values and swaps this with values. All memory that was allocated for values now belongs to this temporary vector, which is automatically destroyed at the end of that statement freeing all its memory. The end result is that all memory that was allocated for values is reclaimed, and values is left with a capacity of zero.

\begin{cpp}
vector<int> values;
// Populate values ...
vector<int>().swap(values);
\end{cpp}

\mySamllsection{Directly Accessing the Data}

A vector stores its data contiguously in memory. You can get a pointer to this block of memory with the data() member function.

There is also a non-member std::data() function that can be used to get a pointer to the data. It works for the array and vector containers, strings, statically allocated C-style arrays not accessed through pointers, and initializer\_lists. Here is an example for a vector:

\begin{cpp}
vector vec { 1, 2, 3 };
int* data1 { vec.data() };
int* data2 { data(vec) };
\end{cpp}

Another way to get access to the memory block of a vector is by taking the address of the first element, as in: \&vec[0]. You might find this kind of code in legacy code bases, but it is not safe for empty vectors; as such, I recommend not to use it and instead use data().

\mySamllsection{Move Semantics}

All Standard Library containers support move semantics by including a move constructor and move assignment operator. See Chapter 9 for details on move semantics. Standard Library containers can be returned from functions by value without performance penalty. Take a look at the following function:

\begin{cpp}
vector<int> createVectorOfSize(size_t size)
{
    vector<int> vec(size);
    for (int contents { 0 }; auto& i : vec) { i = contents++; }
    return vec;
}
...
vector<int> myVector;
myVector = createVectorOfSize(123);
\end{cpp}

Without move semantics, assigning the result of createVectorOfSize() to myVector might call the copy assignment operator. With the move semantics support in the Standard Library containers, copying of the vector is avoided. Instead, the assignment to myVector triggers a call to the move assignment operator.

Keep in mind, though, that for move semantics to work properly with Standard Library containers, the move constructor and move assignment operator of the type stored in the container must be marked as noexcept! Why are these move member functions not allowed to throw any exceptions? Imagine that they are allowed to throw exceptions. Now, when adding, for example, new elements to a vector, it might be that the capacity of the vector is not sufficient and that it needs to allocate a bigger block of memory. Subsequently, the vector must either copy or move all the data from the original memory block to the new one. If this would be done using a move member function that can potentially throw, then it might happen that an exception gets thrown when part of the data has already been moved to the new memory block. What can we do then? Not much. To avoid these kinds of problems, Standard Library containers will only use move member functions if they guarantee not to throw any exceptions. If they are not marked noexcept, the copy member functions will be used instead to guarantee strong exception safety.

When implementing your own Standard Library–like containers, there is a useful helper function available called std::move\_if\_noexcept(), defined in <utility>. This can be used to call either the move constructor or the copy constructor depending on whether the move constructor is noexcept. In itself, move\_if\_noexcept() doesn’t do much. It accepts a reference as a parameter and converts it to either an rvalue reference if the move constructor is noexcept or to a reference-toconst otherwise, but this simple trick allows you to call the correct constructor with a single call.

The Standard Library does not provide a similar helper function to call the move assignment operator or copy assignment operator depending on whether the former is noexcept. Implementing one yourself is not too complicated, but requires some template metaprogramming techniques and type traits to inspect properties of types. Both topics are discussed in Chapter 26, which also gives an example of implementing your own move\_assign\_if\_noexcept().

\mySamllsection{vector Example: A Round-Robin Class}

A common problem in computer science is distributing requests among a finite list of resources. For example, a simple operating system could keep a list of processes and assign a time slice (such as 100ms) to each process to let the process perform some of its work. After the time slice is finished, the OS suspends the process, and the next process in the list is given a time slice to perform some of its work. One of the simplest algorithmic solutions to this problem is round-robin scheduling. When the time slice of the last process is finished, the scheduler starts over again with the first process. For example, in the case of three processes, the first-time slice would go to the first process, the second slice to the second process, the third slice to the third process, and the fourth slice back to the first process. The cycle would continue in this way indefinitely.

Suppose that you decide to write a generic round-robin scheduling class that can be used with any type of resource. The class should support adding and removing resources and should support cycling through the resources to obtain the next one. You could use a vector directly, but it’s often helpful to write a wrapper class that provides more directly the functionality you need for your specific application. The following example shows a RoundRobin class template with comments explaining the code.

First, here is the class definition, exported from a module called round\_robin:

\begin{cpp}
export module round_robin;
import std;

// Class template RoundRobin
// Provides simple round-robin semantics for a list of elements.
export template <typename T>
class RoundRobin final
{
    public:
        // Client can give a hint as to the number of expected elements for
        // increased efficiency.
        explicit RoundRobin(std::size_t numExpected = 0);
        // Prevent copy construction and copy assignment
        RoundRobin(const RoundRobin& src) = delete;
        RoundRobin& operator=(const RoundRobin& rhs) = delete;
        // Explicitly default a move constructor and move assignment operator
        RoundRobin(RoundRobin&& src) noexcept = default;
        RoundRobin& operator=(RoundRobin&& rhs) noexcept = default;
        // Appends element to the end of the list. May be called
        // between calls to getNext().
        void add(const T& element);
        // Removes the first (and only the first) element
        // in the list that is equal (with operator==) to element.
        // May be called between calls to getNext().
        void remove(const T& element);
        // Returns the next element in the list, starting with the first,
        // and cycling back to the first when the end of the list is
        // reached, taking into account elements that are added or removed.
        T& getNext();
    private:
        std::vector<T> m_elements;
        typename std::vector<T>::iterator m_nextElement;
};
\end{cpp}

As you can see, the public interface is straightforward: only three member functions plus the constructor. The resources are stored in a vector called m\_elements. The iterator m\_nextElement always refers to the element that will be returned with the next call to getNext(). If getNext() hasn’t been called yet, m\_nextElement is equal to begin(m\_elements). Note the use of the typename keyword in front of the line declaring m\_nextElement. So far, you’ve only seen that keyword used to specify template type parameters, but there is another use for it. You must specify typename explicitly whenever you access a type based on one or more template parameters. In this case, the template parameter T is used to access the iterator type. Thus, you must specify typename.

The class also prevents copy construction and copy assignment because of the m\_nextElement data member. To make copy construction and copy assignment work, you would have to implement an assignment operator and copy constructor and make sure m\_nextElement is valid in the destination object.

The implementation of the RoundRobin class follows with comments explaining the code. Note the use of reserve() in the constructor, and the extensive use of iterators in add(), remove(), and getNext(). The trickiest aspect is handling m\_nextElement in the add() and remove() member functions.

\begin{cpp}
template <typename T> RoundRobin<T>::RoundRobin(std::size_t numExpected)
{
    // If the client gave a guideline, reserve that much space.
    m_elements.reserve(numExpected);

    // Initialize m_nextElement even though it isn't used until
    // there's at least one element.
    m_nextElement = begin(m_elements);
}

// Always add the new element at the end.
template <typename T> void RoundRobin<T>::add(const T& element)
{
    // Even though we add the element at the end, the vector could
    // reallocate and invalidate the m_nextElement iterator with
    // the push_back() call. Take advantage of the random-access
    // iterator features to save our spot.
    // Note: ptrdiff_t is a type capable of storing the difference
    //  between two random-access iterators.
    std::ptrdiff_t pos { m_nextElement - begin(m_elements) };

    // Add the element.
    m_elements.push_back(element);

    // Reset our iterator to make sure it is valid.
    m_nextElement = begin(m_elements) + pos;
}

template <typename T> void RoundRobin<T>::remove(const T& element)
{
    for (auto it { begin(m_elements) }; it != end(m_elements); ++it) {
        if (*it == element) {
            // Removing an element invalidates the m_nextElement iterator
            // if it refers to an element past the point of the removal.
            // Take advantage of the random-access features of the iterator
            // to track the position of the current element after removal.
            std::ptrdiff_t newPos;

            if (m_nextElement == end(m_elements) - 1 &&
                m_nextElement == it) {
                    // m_nextElement refers to the last element in the list,
                    // and we are removing that last element, so wrap back to
                    // the beginning.
                    newPos = 0;
                } else if (m_nextElement <= it) {
                    // Otherwise, if m_nextElement is before or at the one
                    // we're removing, the new position is the same as before.
                    newPos = m_nextElement - begin(m_elements);
                } else {
                    // Otherwise, it's one less than before.
                    newPos = m_nextElement - begin(m_elements) - 1;
                }

                // Erase the element (and ignore the return value).
                m_elements.erase(it);

                // Now reset our iterator to make sure it is valid.
                m_nextElement = begin(m_elements) + newPos;

                return;
            }
        }
    }
template <typename T> T& RoundRobin<T>::getNext()
{
    // First, make sure there are elements.
    if (m_elements.empty()) {
        throw std::out_of_range { "No elements in the list" };
    }

    // Store the current element which we need to return.
    auto& toReturn { *m_nextElement };

    // Increment the iterator modulo the number of elements.
    ++m_nextElement;
    if (m_nextElement == end(m_elements)) { m_nextElement = begin(m_elements); }

    // Return a reference to the element.
    return toReturn;
}
\end{cpp}

Here’s a simple implementation of a scheduler that uses the RoundRobin class template, with comments explaining the code:

\begin{cpp}
// Basic Process class.
class Process final
{
    public:
        // Constructor accepting the name of the process.
        explicit Process(string name) : m_name { move(name) } {}

        // Lets a process perform its work for the duration of a time slice.
        void doWorkDuringTimeSlice()
        {
            println("Process {} performing work during time slice.", m_name);
            // Actual implementation omitted.
        }

        // Needed for the RoundRobin::remove() member function to work.
        bool operator==(const Process&) const = default; // = default since C++20.
    private:
        string m_name;
};

// Basic round-robin based process scheduler.
class Scheduler final
{
    public:
        // Constructor takes a vector of processes.
        explicit Scheduler(const vector<Process>& processes)
        {
            // Add the processes.
            for (auto& process : processes) { m_processes.add(process); }
        }

        // Selects the next process using a round-robin scheduling algorithm
        // and allows it to perform some work during this time slice.
        void scheduleTimeSlice()
        {
            try {
                m_processes.getNext().doWorkDuringTimeSlice();
            } catch (const out_of_range&) {
                println(cerr, "No more processes to schedule.");
            }
        }

        // Removes the given process from the list of processes.
        void removeProcess(const Process& process)
        {
            m_processes.remove(process);
        }
    private:
        RoundRobin<Process> m_processes;
};

int main()
{
    vector processes { Process { "1" }, Process { "2" }, Process { "3" } };

    Scheduler scheduler { processes };
    for (size_t i { 0 }; i < 4; ++i) { scheduler.scheduleTimeSlice(); }

    scheduler.removeProcess(processes[1]);
    println("Removed second process");

    for (size_t i { 0 }; i < 4; ++i) { scheduler.scheduleTimeSlice(); }
}
\end{cpp}

The output should be as follows:

\begin{shell}
Process 1 performing work during time slice.
Process 2 performing work during time slice.
Process 3 performing work during time slice.
Process 1 performing work during time slice.
Removed second process
Process 3 performing work during time slice.
Process 1 performing work during time slice.
Process 3 performing work during time slice.
Process 1 performing work during time slice.
\end{shell}

\mySubsubsection{18.2.2.}{The vector<bool> Specialization}

The C++ standard requires a partial specialization of vector for bools, with the intention that it optimizes space allocation by “packing” the Boolean values. Recall that a bool is either true or false and thus could be represented by a single bit, which can take on exactly two values. C++ does not have a native type that stores exactly one bit. Some compilers represent a Boolean value with a type the same size as a char; other compilers use an int. The vector<bool> specialization is supposed to store the “array of bools” in single bits, thus saving space.

\begin{myNotic}{NOTE}
You can think of the vector<bool> as a bit-field instead of a vector. The bitset container described later in this chapter provides a more fullfeatured bit-field implementation than does vector<bool>. However, the benefit of vector<bool> is that it can change size dynamically.
\end{myNotic}

In a half-hearted attempt to provide some bit-field routines for vector<bool>, there is one additional member function called flip() that complements bits; that is, true becomes false, and false becomes true, similar to the logical NOT operator. This member function can be called either on the container—in which case it complements all the elements in the container—or on a single reference returned from operator[] or a similar member function, in which case it complements that single element.

At this point, you should be wondering how you can call a member function on a reference to bool. The answer is that you can’t. The vector<bool> specialization actually defines a class called reference that serves as a proxy for the underlying bool (or bit). When you call operator[], at(), or a similar member function, then vector<bool> returns a reference object, which is a proxy for the real bool.

\begin{myWarning}{WARNING}
The fact that references returned from vector<bool> are really proxies means that you can’t take their addresses to obtain pointers to the actual elements in the container.
\end{myWarning}

In practice, the little amount of space saved by packing bools hardly seems worth the extra effort. Even worse, accessing and modifying elements in a vector<bool> is much slower than, for example, in a vector<int>. Many C++ experts recommend avoiding vector<bool> in favor of the bitset. If you do need a dynamically sized bit field, then just use something like vector<std::int\_fast8\_t> or vector<unsigned char>. The std::int\_fast8\_t type is defined in <cstdint>. It is a signed integer type for which the compiler has to use the fastest integer type it has that is at least 8 bits.

\mySubsubsection{18.2.3.}{deque}

deque (abbreviation for double-ended queue) is almost identical to vector, but is used far less frequently. It is defined in <deque>. The principal differences are as follows:

\begin{itemize}
\item
Elements are not stored contiguously in memory.

\item
A deque supports true constant-time insertion and removal of elements at both the front and the back (a vector supports amortized constant time at just the back).

\item
A deque provides the following member functions that vector omits:
\begin{itemize}
\item
push\_front(): Inserts an element at the beginning.

\item
pop\_front(): Removes the first element.

\item
emplace\_front(): Creates a new element in-place at the beginning and returns a reference to the inserted element.

\item
prepend\_range(): Adds all elements of a given range to the beginning of a deque.
Available since C++23.
\end{itemize}

\item
A deque never moves its elements to a bigger array (as vector does) when inserting elements at the front or at the back. This also means that a deque does not invalidate any iterators in such cases.

\item
A deque does not expose its memory management scheme via reserve() or capacity().
\end{itemize}

deques are rarely used, as opposed to vectors, so they are not further discussed. Consult a Standard Library Reference for a detailed list of all supported member functions.

\mySubsubsection{18.2.4.}{list}

The Standard Library list class template, defined in <list>, is a standard doubly linked list. It supports constant-time insertion and deletion of elements at any point in the list but provides slow (linear) time access to individual elements. In fact, the list does not even provide random-access operations like operator[]. Only through iterators can you access individual elements.

Most of the list operations are identical to those of vector, including the constructors, destructor, copying operations, assignment operations, and comparison operations. This section focuses on those member functions that differ from those of vector.

\mySamllsection{Accessing Elements}

The only member functions provided by a list to access elements are front() and back(), both of which run in constant time. These member functions return a reference to the first and last elements in a list. All other element access must be performed through iterators.

Just as vector, list supports begin(), end(), rbegin(), rend(), cbegin(), cend(), crbegin(), and crend().

\begin{myWarning}{WARNING}
Lists do not provide random access to elements.
\end{myWarning}

\mySamllsection{Iterators}

A list iterator is bidirectional, not random access like a vector iterator. That means that you cannot add and subtract list iterators from each other or perform other pointer arithmetic on them. For example, if p is a list iterator, you can traverse through the elements of the list by doing ++p or --p, but you cannot use the addition or subtraction operator; p+n and p-n do not work.

\mySamllsection{Adding and Removing Elements}

A list supports the same add and remove element member functions as a vector, including push\_ back(), pop\_back(), emplace(), emplace\_back(), the five forms of insert(), assign\_range(), insert\_range(), append\_range(), the two forms of erase(), and clear(). Like a deque, it also provides push\_front(), emplace\_front(), pop\_front(), and prepend\_range(). Member functions adding or removing a single element run in constant time, once you’ve found the correct position, while member functions adding or removing multiple elements run in linear time. Thus, a list could be appropriate for applications that perform many insertions and deletions from the data structure, but do not need quick index-based element access. But even then, a vector might still be faster. Use a performance profiler to make sure.

\mySamllsection{list Size}

Like deques, and unlike vectors, lists do not expose their underlying memory model. Consequently, they support size(), empty(), and resize(), but not reserve() or capacity(). Note that the size() member function on a list has constant complexity.

\mySamllsection{Special list Operations}

A list provides several special operations that exploit its quick element insertion and deletion. This section provides an overview of some of these operations with examples. Consult a Standard Library Reference for a thorough reference of all the member functions.

\mySamllsection{Splicing}

The linked-list characteristics of a list allow it to splice, or insert, an entire list at any position in another list in constant time. The simplest version of this member function works as follows:

\begin{cpp}
// Store the a words in the main dictionary.
list<string> dictionary { "aardvark", "ambulance" };
// Store the b words.
list<string> bWords { "bathos", "balderdash" };
// Add the c words to the main dictionary.
dictionary.push_back("canticle");
dictionary.push_back("consumerism");
// Splice the b words into the main dictionary.
if (!bWords.empty()) {
    // Get an iterator to the last b word.
    auto iterLastB { --(cend(bWords)) };
    // Iterate up to the spot where we want to insert b words.
    auto it { cbegin(dictionary) };
    for (; it != cend(dictionary); ++it) {
        if (*it > *iterLastB) { break; }
    }
    // Add in the b words. This action removes the elements from bWords.
    dictionary.splice(it, bWords);
}
// Print out the dictionary.
println("{:n:}", dictionary);
\end{cpp}

The result from running this program looks like this:

\begin{shell}
aardvark, ambulance, bathos, balderdash, canticle, consumerism
\end{shell}

There are also two other overloads of splice(): one that inserts a single element from another list and one that inserts a range from another list. Additionally, all overloads of splice() are available with either a normal reference or an rvalue reference to the source list.

\begin{myWarning}{WARNING}
Splicing is destructive to the list passed as an argument, i.e., it removes the spliced elements from one list to insert them into the other.
\end{myWarning}

\mySamllsection{More Efficient Versions of Algorithms}

In addition to splice(), a list provides special implementations of several of the generic Standard Library algorithms. The generic forms are covered in Chapter 20. Here, only the specific versions provided by list are discussed.

\begin{myNotic}{NOTE}
When you have a choice, use the list-specific member functions rather than the generic Standard Library algorithms because the former are more efficient. Sometimes you don’t have a choice, and you must use the list-specific member functions; for example, the generic std::sort() algorithm requires random-access iterators, which a list does not provide.
\end{myNotic}

The following table summarizes the algorithms for which list provides special implementations as member functions. See Chapter 20 for more details on the algorithms.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{MEMBER FUNCTION} &
\textbf{DESCRIPTION} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}remove()\\ remove\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Removes all elements matching certain criteria from a list and returns the\\ number of removed elements.\end{tabular} \\ \hline
unique() &
\begin{tabular}[c]{@{}l@{}}Removes duplicate consecutive elements from a list, based on\\ operator== or a user-supplied binary predicate, and returns the number of\\ removed elements.\end{tabular} \\ \hline
merge() &
\begin{tabular}[c]{@{}l@{}}Merges two lists. Both lists must be sorted according to operator\textless or\\ a user-defined comparator. Like splice(), merge() is destructive to the\\ list passed as an argument.\end{tabular} \\ \hline
sort() &
Performs a stable sort on elements in a list. \\ \hline
reverse() &
Reverses the order of the elements in a list. \\ \hline
\end{longtable}

\mySamllsection{list Example: Determining Enrollment}

Suppose that you are writing a computer registration system for a university. One feature you might provide is the ability to generate a complete list of enrolled students in the university from lists of the students in each class. For the sake of this example, assume that you must write only a single function that takes a vector of lists of student names (as strings), plus a list of students that have been dropped from their courses because they failed to pay tuition. This function should generate a complete list of all the students in all the courses, without any duplicates, and without those students who have been dropped. Note that students might be in more than one course.

Here is the code for this function, with comments explaining the code. With the power of Standard Library lists, the function is practically shorter than its written description! Note that the Standard Library allows you to “nest” containers: in this case, you can use a vector of lists.

\begin{cpp}
// courseStudents is a vector of lists, one for each course. The lists
// contain the students enrolled in those courses. They are not sorted.
//
// droppedStudents is a list of students who failed to pay their
// tuition and so were dropped from their courses.
//
// The function returns a list of every enrolled (non-dropped) student in
// all the courses.
list<string> getTotalEnrollment(const vector<list<string>>& courseStudents,
                                const list<string>& droppedStudents)
{
    list<string> allStudents;

    // Concatenate all the course lists onto the master list
    for (auto& lst : courseStudents) {
        allStudents.append_range(lst);
    }

    // Sort the master list
    allStudents.sort();

    // Remove duplicate student names (those who are in multiple courses).
    allStudents.unique();

    // Remove students who are on the dropped list.
    // Iterate through the dropped list, calling remove on the
    // master list for each student in the dropped list.
    for (auto& str : droppedStudents) {
        allStudents.remove(str);
    }

    // done!
    return allStudents;
}
\end{cpp}

\begin{myNotic}{NOTE}
This example demonstrates the use of the list-specific algorithms. As stated several times before, often a vector is faster than a list. So, the recommended solution to the student enrollment problem would be to only use vectors and to combine these with generic Standard Library algorithms, but those are discussed in Chapter 20.
\end{myNotic}

\mySubsubsection{18.2.5.}{forward\_list}

A forward\_list, defined in <forward\_list>, is similar to a list except that it is a singly linked list, while list is a doubly linked list. This means that forward\_list supports only forward iteration, and because of this, ranges need to be specified differently compared to a list. If you want to modify any list, you need access to the element before the first element of interest. Because a forward\_list does not have an iterator that supports going backward, there is no easy way to get to the preceding element. For this reason, ranges that will be modified—for example, ranges supplied to erase() and splice()—must be open at the beginning. The begin() function that was discussed earlier returns an iterator to the first element and thus can only be used to construct a range that is closed at the beginning. The forward\_list class therefore provides a before\_begin() member function, which returns an iterator that points to an imaginary element before the beginning of the list. You cannot dereference this iterator as it points to invalid data. However, incrementing this iterator by 1 makes it the same as the iterator returned by begin(); as a result, it can be used to make a range that is open at the beginning.

Constructors and assignment operators are similar between a list and a forward\_list. The C++ standard requires that forward\_list minimizes its memory use. That’s the reason why there is no size() member function, because by not providing it, there is no need to store the size of the list. Additionally, a list has to store a pointer to the previous and the next element in the list, while a forward\_list only needs to store a pointer to the next element, further reducing memory use. For example, each element in a list<int> on a 64-bit system requires 20 bytes (two 64-bit pointers, 16 bytes, and the int itself, 4 bytes). A forward\_list<int> requires only 12 bytes (one 64-bit pointer, 8 bytes, and the int, 4 bytes) per element.

The following table sums up the differences between a list and a forward\_list. A filled box (■) means the container supports that operation, while an empty box (□) means the operation is not supported.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{操作}                           & \textbf{list} & \textbf{forward\_list} \\ \hline
\endfirsthead
%
\endhead
%
append\_range() (C++23)                      & ■             & □                      \\ \hline
assign()                                     & ■             & ■                      \\ \hline
assign\_range() (C++23)                      & ■             & ■                      \\ \hline
back()                                       & ■             & □                      \\ \hline
before\_begin()                              & □             & ■                      \\ \hline
begin()                                      & ■             & ■                      \\ \hline
cbefore\_begin()                             & □             & ■                      \\ \hline
cbegin()                                     & ■             & ■                      \\ \hline
cend()                                       & ■             & ■                      \\ \hline
clear()                                      & ■             & ■                      \\ \hline
crbegin()                                    & ■             & □                      \\ \hline
crend()                                      & ■             & □                      \\ \hline
emplace()                                    & ■             & □                      \\ \hline
emplace\_after()                             & □             & ■                      \\ \hline
emplace\_back()                              & ■             & □                      \\ \hline
emplace\_front()                             & ■             & ■                      \\ \hline
empty()                                      & ■             & ■                      \\ \hline
end()                                        & ■             & ■                      \\ \hline
erase()                                      & ■             & □                      \\ \hline
erase\_after()                               & □             & ■                      \\ \hline
front()                                      & ■             & ■                      \\ \hline
insert()                                     & ■             & □                      \\ \hline
insert\_after()                              & □             & ■                      \\ \hline
insert\_range() (C++23)                      & ■             & □                      \\ \hline
insert\_range\_after() (C++23)               & □             & ■                      \\ \hline
iterator / const\_iterator                   & ■             & ■                      \\ \hline
max\_size()                                  & ■             & ■                      \\ \hline
merge()                                      & ■             & ■                      \\ \hline
pop\_back()                                  & ■             & □                      \\ \hline
pop\_front()                                 & ■             & ■                      \\ \hline
prepend\_range() (C++23)                     & ■             & ■                      \\ \hline
push\_back()                                 & ■             & □                      \\ \hline
push\_front()                                & ■             & ■                      \\ \hline
rbegin()                                     & ■             & □                      \\ \hline
remove()                                     & ■             & ■                      \\ \hline
remove\_if()                                 & ■             & ■                      \\ \hline
rend()                                       & ■             & □                      \\ \hline
resize()                                     & ■             & ■                      \\ \hline
reverse()                                    & ■             & ■                      \\ \hline
reverse\_iterator / const\_reverse\_iterator & ■             & □                      \\ \hline
size()                                       & ■             & □                      \\ \hline
sort()                                       & ■             & ■                      \\ \hline
splice()                                     & ■             & □                      \\ \hline
splice\_after()                              & □             & ■                      \\ \hline
swap()                                       & ■             & ■                      \\ \hline
unique()                                     & ■             & ■                      \\ \hline
\end{longtable}

The following example demonstrates the use of forward\_lists:

\begin{cpp}
// Create 3 forward lists using an initializer_list
// to initialize their elements (uniform initialization).
forward_list<int> list1 { 5, 6 };
forward_list list2 { 1, 2, 3, 4 }; // CTAD is supported.
forward_list list3 { 7, 8, 9 };

// Insert list2 at the front of list1 using splice.
list1.splice_after(list1.before_begin(), list2);

// Add number 0 at the beginning of the list1.
list1.push_front(0);

// Insert list3 at the end of list1.
// For this, we first need an iterator to the last element.
auto iter { list1.before_begin() };
auto iterTemp { iter };
while (++iterTemp != end(list1)) { ++iter; }
list1.insert_after(iter, cbegin(list3), cend(list3));

// Output the contents of list1.
println("{:n}", list1);
\end{cpp}

To insert list3 at the end of list1, you need an iterator to the last element of list1. However, because this is a forward\_list, you cannot use --end(list1), so you need to iterate over the list from the beginning and stop at the last element. The output is as follows:

\begin{shell}
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
\end{shell}

\mySubsubsection{18.2.6.}{array}

An array, defined in <array>, is similar to a vector except that it is of a fixed size; it cannot grow or shrink in size. The purpose of a fixed size is to allow an array to be allocated on the stack, rather than always demanding access to the free store as vector does.

For arrays containing primitive types (integers, floating-point numbers, characters, Booleans, and so on), initialization of elements is different compared to how they are initialized for containers such as vector, list, and so on. If no initialization values are given to an array when it is created, then the array elements will be uninitialized, i.e., contain garbage. For other containers, such as vector and list, elements are always initialized, either with given values or using zero initialization. As such, arrays behave virtually identical to C-style arrays.

Just like vectors, arrays support random-access iterators, and elements are stored in contiguous memory. An array has support for front(), back(), at(), and operator[]. It also supports a fill() member function to fill the array with a specific element. Because it is fixed in size, it does not support push\_back(), pop\_back(), insert(), erase(), clear(), resize(), reserve(), capacity(), or any of the range-based member functions. A disadvantage compared to a vector is that the swap() member function of an array runs in linear time, while it has constant complexity for a vector. An array can also not be moved in constant time, while a vector can. An array has a size() member function, which is a clear advantage over C-style arrays. The following example demonstrates how to use the array class. Note that the array declaration requires two template parameters: the first specifies the type of the elements, and the second specifies the fixed number of elements in the array.

\begin{cpp}
// Create an array of 3 integers and initialize them
// with the given initializer_list using uniform initialization.
array<int, 3> arr { 9, 8, 7 };
// Output the size of the array.
println("Array size = {}", arr.size()); // or std::size(arr)
// Output the contents using C++23's support for formatting ranges.
println("{:n}", arr);
// Output the contents again using a range-based for loop.
for (const auto& i : arr) { print("{} ", i); }
println("");

println("Performing arr.fill(3)...");
// Use the fill member function to change the contents of the array.
arr.fill(3);
// Output the contents of the array using iterators.
for (auto iter { cbegin(arr) }; iter != cend(arr); ++iter) {
    print("{} ", *iter);
}
\end{cpp}

The output is as follows:

\begin{shell}
Array size = 3
9, 8, 7
9 8 7
Performing arr.fill(3)...
3 3 3
\end{shell}

You can use the std::get<n>() function template to retrieve an element from an std::array at the given index n. The index has to be a constant expression, so it cannot, for example, be a loop variable. The benefit of using std::get<n>() is that the compiler checks at compile time that the given index is valid; otherwise, it results in a compilation error, as in this example:

\begin{cpp}
array myArray { 11, 22, 33 }; // std::array supports CTAD.
println("{}", std::get<1>(myArray));
println("{}", std::get<10>(myArray)); // BUG! Compilation error!
\end{cpp}

std::to\_array(), defined in <array>, converts a given C-style array to an std::array, using copy-initialization of the elements. The function works only for one-dimensional arrays. Here is a quick example:

\begin{cpp}
auto arr1 { to_array({ 11, 22, 33 }) }; // Type is array<int, 3>

double carray[] { 9, 8, 7, 6 };
auto arr2 { to_array(carray) }; // Type is array<double, 4>
\end{cpp}










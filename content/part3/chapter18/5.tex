

C++标准库提供了几种不同类型的关联容器：

\begin{itemize}
\item
有序关联容器： map, multimap, set和 multiset.

\item
无序关联容器：unordered\_map, unordered\_multimap, unordered\_set, 和unordered\_multiset。 这些也称为哈希表。

\item
平面关联容器适配器： flat\_map, flat\_multimap, flat\_set和 flat\_multiset。这些适配顺序容器以表现出有序关联容器的特性。

\CXXTwentythreeLogo{-45}{20}
\end{itemize}

\mySubsubsection{18.5.1.}{有序关联容器}

与顺序容器不同，有序关联容器不将元素存储在线性配置中。相反，它们提供键到值的映射，插入、删除和查找的时间相等。

标准库提供了四种有序关联容器：map、multimap、set和multiset。这些容器将元素存储在有序、树状的数据结构中。

\mySamllsection{pair 工具类}

深入研究有序关联容器之前，简要回顾一下在第1章中介绍的pair类模板。其定义在<utility>中，并将两个可能不同类型的值组合在一起。这些值可以通过first和second公共数据成员访问，所有比较运算符都得到支持，并且可同时比较first和second值。以下是几个示例：

\begin{cpp}
// Two-argument constructor and default constructor
pair<string, int> myPair { "hello", 5 };
pair<string, int> myOtherPair;

// Can assign directly to first and second
myOtherPair.first = "hello";
myOtherPair.second = 6;

// Copy constructor
pair<string, int> myThirdPair { myOtherPair };

// operator<
if (myPair < myOtherPair) {
    println("myPair is less than myOtherPair");
} else {
    println("myPair is greater than or equal to myOtherPair");
}

// operator==
if (myOtherPair == myThirdPair) {
    println("myOtherPair is equal to myThirdPair");
} else {
    println("myOtherPair is not equal to myThirdPair");
}
\end{cpp}

输出为：

\begin{shell}
myPair is less than myOtherPair
myOtherPair is equal to myThirdPair
\end{shell}

使用类模板参数推导（CTAD），可以省略模板类型参数。这里有一个例子。注意对标准字符串字面量s的使用。

\begin{cpp}
pair myPair { "hello"s, 5 }; // Type is pair<string, int>.
\end{cpp}

C++17引入对CTAD的支持之前，可以使用std::make\_pair()工具函数模板从两个值构造一个pair。以下是构造一个int和double的pair的三种方式：

\begin{cpp}
pair<int, double> pair1 { make_pair(5, 10.10) };
auto pair2 { make_pair(5, 10.10) };
pair pair3 { 5, 10.10 }; // CTAD
\end{cpp}

\mySamllsection{map}

map，定义在< map >中，存储键/值对而不是单个值。插入、查找和删除都基于键；值只是“顺便携带”

map根据键保持元素排序，因此插入、删除和查找的时间复杂度都是对数。由于顺序，当枚举元素时，会按照类型operator<或按用户定义比较器的顺序出现。它通常实现为某种形式的平衡树，如红黑树，但树结构对客户端不可见。

当需要基于“键”存储和检索元素，并且希望按特定顺序排列时，应该使用map。

\mySamllsection{构造 map}

map类模板接受四种类型：键类型、值类型、比较器类型和分配器类型，本章忽略分配器。比较器与前面描述的priority\_queue的比较器类似，允许更改默认比较器。在本章中，只使用默认的less比较器。使用默认比较器时，请确保所有键都支持operator<。如果对更多细节感兴趣，第19章将解释如何自定义比较器。

如果忽略比较器和分配器参数，构造map就像构造vector或list一样，除了在模板实例化中分别指定键和值类型。例如，以下代码构造了一个使用int作为键和Data类对象作为值的map：

\begin{cpp}
class Data final
{
    public:
        explicit Data(int value = 0) : m_value { value } { }
        int getValue() const { return m_value; }
        void setValue(int value) { m_value = value; }
    private:
        int m_value;
};
...
map<int, Data> dataMap;
\end{cpp}

内部，dataMap为map中的每个元素存储一个pair<int, Data>。

map也支持统一初始化。以下map在内部存储pair<string, int>的实例：

\begin{cpp}
map<string, int> m {
    { "Marc G.", 12 }, { "Warren B.", 34 }, { "Peter V.W.", 56 }
};
\end{cpp}

类模板参数推导不按预期工作，以下代码无法编译：

\begin{cpp}
map m {
    { "Marc G."s, 12 }, { "Warren B."s, 34 }, { "Peter V.W."s, 56 }
};
\end{cpp}

这不起作用，因为编译器无法从\{"Marc G."s, 12\}推导出pair<string, int>。如果真的想这样做，可以编写以下内容（注意字符串字面量的s后缀！）：

\begin{cpp}
map m {
    pair { "Marc G."s, 12 }, pair { "Warren B."s, 34 }, pair { "Peter V.W."s, 56 }
};
\end{cpp}

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{格式化和打印Map}

与vector一样，std::format()和print()函数可以用来格式化和打印整个map，只需一条语句。对于vector，输出用方括号括起来，每个元素之间用逗号分隔。对于map，输出略有不同：输出用花括号括起来，每个键/值对之间用逗号分隔，键和值之间用冒号分隔。例如，打印上一节中的map m，输出为：

\begin{cpp}
{"Marc G.": 12, "Peter V.W.": 56, "Warren B.": 34}
\end{cpp}

\mySamllsection{插入元素}

将元素插入顺序容器，如vector和list，需要指定元素要添加的位置。与map以及其他有序关联容器不同，其内部实现决定了新元素应存储的位置，只需提供键和值。

\begin{myNotic}{NOTE}
map和其他有序关联容器确实提供了一个带有迭代器位置的insert()版本。那个位置只是对容器的一个“提示”，即正确位置。容器不必将元素插入那个位置。
\end{myNotic}

在插入元素时，重要的是要注意map需要唯一的键：map中的每个元素都必须有不同的键。如果想支持具有相同键的多个元素，有两个选择：要么使用map，并将另一个容器（如vector）作为键的值存储，或者使用稍后介绍的multimap。

\mySamllsection{insert()成员函数}

insert()成员函数可用于向map添加元素，其优点是可以检测键是否已经存在。必须将键/值对作为pair对象或作为初始化列表指定，insert()基本形式的返回类型是一个包含迭代器和布尔值的pair。返回类型复杂的原因是，insert()不会覆盖已经存在指定键的值。返回的pair中的布尔值元素指明insert()是否实际插入了新的键/值对，迭代器指向具有指定键的map中的元素（根据插入是否成功或失败，是新的还是旧的值）。map迭代器的详细介绍将在下一节中进行。继续上一节的map示例，可以这样使用insert()：

\begin{cpp}
map<int, Data> dataMap;

auto ret { dataMap.insert({ 1, Data { 4 } }) }; // Using an initializer_list
if (ret.second) { println("Insert succeeded!"); }
else { println("Insert failed!"); }

ret = dataMap.insert(make_pair(1, Data { 6 })); // Using a pair object
if (ret.second) { println("Insert succeeded!"); }
else { println("Insert failed!"); }
\end{cpp}

ret变量的类型为：

\begin{cpp}
pair<map<int, Data>::iterator, bool> ret;
\end{cpp}

pair的第一个元素是具有int类型键和Data类型值的map的迭代器，pair的第二个元素是一个布尔值。

程序的输出如下：

\begin{shell}
Insert succeeded!
Insert failed!
\end{shell}

使用if语句初始化器，可以在单个语句中将数据插入map并检查结果：

\begin{cpp}
if (auto result { dataMap.insert({ 1, Data { 4 } }) }; result.second) {
    println("Insert succeeded!");
} else {
    println("Insert failed!");
}
\end{cpp}

这还可以与结构化绑定一起使用：

\begin{cpp}
if (auto [iter, success] { dataMap.insert({ 1, Data { 4 } }) }; success) {
    println("Insert succeeded!");
} else {
    println("Insert failed!");
}
\end{cpp}

\mySamllsection{The insert\_or\_assign()成员函数}

insert\_or\_assign()的返回类型与insert()类似，但如果已经存在具有给定键的元素，insert\_or\_assign()将用新值覆盖旧值，而insert()在这种情况下不会覆盖旧值。insert\_or\_assign()与insert()的另一个区别在于，它有两个独立的参数：键和值。以下是使用insert\_or\_assign()的示例：

\begin{cpp}
auto ret { dataMap.insert_or_assign(1, Data { 7 }) };
if (ret.second) { println("Inserted."); }
else { println("Overwritten."); }
\end{cpp}

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{insert\_range()成员函数}

C++23为map添加了insert\_range()，将给定范围内的所有元素插入到map中，并返回添加的第一个元素的迭代器。以下是使用insert\_range()的示例：

\begin{cpp}
vector<pair<int, Data>> moreData { {2, Data{22}}, {3, Data{33}}, {4, Data{44}} };
dataMap.insert_range(moreData);
\end{cpp}

\mySamllsection{operator[]}

向map中插入元素的另一种成员函数是通过重载的operator[]。主要区别在于语法：分别指定键和值。此外，operator[]总是成功。如果没有与给定键对应的值，将创建一个具有该键和值的新元素。如果已经有具有该键的元素，operator[]将用新指定的值替换该值。以下是使用operator[]代替insert()的示例的一部分：

\begin{cpp}
map<int, Data> dataMap;
dataMap[1] = Data { 4 };
dataMap[1] = Data { 6 }; // Replaces the element with key 1
\end{cpp}

然而，operator[]有一个主要缺点：总是构造一个新的值对象，即使不需要使用。因此，需要元素的默认构造函数，并且可能不如insert()高效。

由于operator[]在请求的元素不存在时在map中创建新元素，所以这个运算符没有标记为const。例如，有以下函数：

\begin{cpp}
void func(const map<int, int>& m)
{
    println("{}", m[1]); // Error
}
\end{cpp}

这无法编译，即使只是想读取m[1]的值。这是因为参数m是对map的const引用，而operator[]没有标记为const。这种情况下，应该使用find()或at()成员函数。

\mySamllsection{Emplace成员函数}

map支持emplace()和emplace\_hint()，用于在原地构造元素，类似于vector的emplace成员函数。还有一个try\_emplace()成员函数，如果给定的键不存在，则在原地插入元素，如果键已经存在于map中，则不做任何事情。

\mySamllsection{map迭代器}

map迭代器的工作方式与顺序容器上的迭代器类似。主要区别在于，迭代器指向键/值对，而不仅仅是值。要访问值，必须检索pair对象的第二字段。map迭代器是双向的，所以可以双向遍历。以下是遍历map的方式：

\begin{cpp}
for (auto iter { cbegin(dataMap) }; iter != cend(dataMap); ++iter) {
    println("{}", iter->second.getValue());
}
\end{cpp}

再看看用于访问值的表达式：

\begin{cpp}
iter->second.getValue()
\end{cpp}

iter指向一个键/值对，因此可以使用->运算符访问该对的第二字段，这是一个Data对象。然后，可以调用该Data对象的getValue()成员函数。

请注意，以下代码是功能等效的：

\begin{cpp}
(*iter).second.getValue()
\end{cpp}

使用基于范围的for循环，循环可以写得更具有可读性并减少错误：

\begin{cpp}
for (const auto& p : dataMap) {
    println("{}", p.second.getValue());
}
\end{cpp}

可以使用基于范围的for循环和结构化绑定更优雅地实现元素修改：

\begin{cpp}
for (const auto& [key, data] : dataMap) {
    println("{}", data.getValue());
}
\end{cpp}

\begin{myWarning}{WARNING}
可以通过非常量迭代器修改元素值，但如果尝试通过非常量迭代器修改元素的键，编译器将生成错误，这将破坏map中元素的排序顺序。
\end{myWarning}

\mySamllsection{查找元素}

map提供基于键的对数查找元素。如果已经知道给定键的元素在map中，最简单的方法是通过operator[]进行查找，只要在非常量map或对非常量map的引用上调用即可。operator[]的好处是返回一个引用，可以直接使用和修改，而不必担心从pair对象中提取值。以下是对前一个示例的扩展，以调用具有键1的Data对象值的setValue()成员函数：

\begin{cpp}
map<int, Data> dataMap;
dataMap[1] = Data { 4 };
dataMap[1] = Data { 6 };
dataMap[1].setValue(100);
\end{cpp}

作为替代，map提供了find()成员函数，其返回一个迭代器，指向具有请求键的键/值对，如果存在，或者如果键在map中找不到，则返回end()迭代器。这对于以下情况很有用：

\begin{itemize}
\item
如果不知道元素是否存在，可能不想使用operator[]，因为如果它找不到已存在的键，会插入一个新的元素。

\item
如果有一个常量或对常量map的引用，这种情况下不能使用operator[]。
\end{itemize}

以下是一个使用find()执行对键1的Data对象修改的示例：

\begin{cpp}
auto it { dataMap.find(1) };
if (it != end(dataMap)) {
    it->second.setValue(100);
}
\end{cpp}

使用find()稍微有些笨拙，但在某些情况下是必要的。

或者，可以使用at()成员函数，其与operator[]一样。如果存在，则返回对map中具有请求键的值的引用。如果请求的键在map中找不到，会抛出out\_of\_range异常。at()成员函数在常量或对常量map上正常工作。例如：

\begin{cpp}
dataMap.at(1).setValue(200);
\end{cpp}

如果只想知道具有特定键的元素是否在map中，可以使用count()成员函数，返回与给定键在map中的元素数量。对于map，结果将始终为0或1，因为不能有具有重复键的元素。

此外，所有关联容器（有序、无序和扁平）都有一个名为contains()的成员函数。如果给定的键存在于容器中，返回true，否则返回false。有了这个，不再需要使用count()来确定关联容器中是否包含某个键。以下是包含键1的示例：

\begin{cpp}
auto isKeyInMap { dataMap.contains(1) };
\end{cpp}

\mySamllsection{删除元素}

map可以在特定迭代器位置删除一个元素，或在给定迭代器范围内删除所有元素，分别以常数时间和对数时间完成。从客户端的角度来看，这两个erase()成员函数与顺序容器中的erase()成员函数等效。然而，map的一个伟大特性是，还提供了一个erase()，用于删除匹配特定键的元素。以下是使用erase()的示例：

\begin{cpp}
map<int, Data> dataMap;
dataMap[1] = Data { 4 };
println("There are {} elements with key 1.", dataMap.count(1));
dataMap.erase(1);
println("There are {} elements with key 1.", dataMap.count(1));
\end{cpp}

输出为：

\begin{shell}
There are 1 elements with key 1.
There are 0 elements with key 1.
\end{shell}

\mySamllsection{节点}

所有有序和无序关联容器都是基于节点的数据结构。标准库提供了对节点的直接访问，形式为节点句柄。确切类型未指定，但每个容器都有一个类型别名node\_type，指定了该容器的节点句柄类型。节点句柄只能移动，并且是存储在节点中的元素的拥有者，其提供了对键和值的读写访问。

可以使用extract()成员函数基于给定的迭代器位置，或给定的键从关联容器中提取节点，作为节点句柄。从容器中提取节点会将其从容器中删除，因为返回的节点句柄是提取元素的唯一拥有者。

提供了新的insert()重载，允许节点句柄插入到容器中。

通过使用extract()提取节点句柄和使用insert()插入节点句柄，可以有效地将数据从一个关联容器转移到另一个关联容器，而无需复制或移动。甚至可以将节点从map转移到multimap，并将节点从set转移到multiset。继续使用前面部分的示例，以下代码片段将dataMap中键为1的节点，转移到一个名为dataMap2的第二个map中：

\begin{cpp}
map<int, Data> dataMap2;
auto extractedNode { dataMap.extract(1) };
dataMap2.insert(move(extractedNode));
\end{cpp}

最后两行可以合并为一行：

\begin{cpp}
dataMap2.insert(dataMap.extract(1));
\end{cpp}

对移动所有节点从一个关联容器到另一个容器的一个操作是merge()。如果移动节点会导致目标容器中出现重复（目标容器不允许重复），则源容器中的节点将保持不变。以下是使用merge()的示例：

\begin{cpp}
map<int, int> src { {1, 11}, {2, 22} };
map<int, int> dst { {2, 22}, {3, 33}, {4, 44}, {5, 55} };
dst.merge(src);
println("src = {}", src); // src = {2: 22}
println("dst = {}", dst); // dst = {1: 11, 2: 22, 3: 33, 4: 44, 5: 55}
\end{cpp}

merge操作后，src仍然包含一个元素\{2: 22\}，因为目标容器已经包含这样的元素，所以无法移动。

\mySamllsection{map 示例: 银行账户}

可以通过使用map来实现一个简单的银行账户数据库。一个常见的模式是将键设置为一个类或结构体的一个字段，键是账户号码。下面是简单的BankAccount和BankDB类：

\begin{cpp}
export class BankAccount final
{
    public:
        explicit BankAccount(int accountNumber, std::string name)
            : m_accountNumber { accountNumber }, m_clientName { std::move(name) }{}
        void setAccountNumber(int accountNumber) {
            m_accountNumber = accountNumber; }
        int getAccountNumber() const { return m_accountNumber; }

        void setClientName(std::string name) { m_clientName = std::move(name); }
        const std::string& getClientName() const { return m_clientName; }
    private:
        int m_accountNumber;
        std::string m_clientName;
};
export class BankDB final
{
    public:
        // Adds account to the bank database. If an account exists already
        // with that account number, the new account is not added. Returns true
        // if the account is added, false if it's not.
        bool addAccount(const BankAccount& account);

        // Removes the account with accountNumber from the database.
        void deleteAccount(int accountNumber);

        // Returns a reference to the account represented
        // by its account number or the client name.
        // Throws out_of_range if the account is not found.
        BankAccount& findAccount(int accountNumber);
        BankAccount& findAccount(std::string_view name);

        // Adds all the accounts from db to this database.
        // Deletes all the accounts from db.
        void mergeDatabase(BankDB& db);
    private:
        std::map<int, BankAccount> m_accounts;
};
\end{cpp}

以下是BankDB成员函数的实现:

\begin{cpp}
bool BankDB::addAccount(const BankAccount& account)
{
    // Do the actual insert, using the account number as the key.
    auto res { m_accounts.emplace(account.getAccountNumber(), account) };
    // or: auto res { m_accounts.insert(
        // pair { account.getAccountNumber(), account }) };
    // Return the bool field of the pair specifying success or failure.
    return res.second;
}

void BankDB::deleteAccount(int accountNumber)
{
    m_accounts.erase(accountNumber);
}

BankAccount& BankDB::findAccount(int accountNumber)
{
    // Finding an element via its key can be done with find().
    auto it { m_accounts.find(accountNumber) };
    if (it == end(m_accounts)) {
        throw out_of_range { format("No account with number {}.", accountNumber) };
    }
    // Remember that iterators into maps refer to pairs of key/value.
    return it->second;
}

BankAccount& BankDB::findAccount(string_view name)
{
    // Finding an element by a non-key attribute requires a linear
    // search through the elements. The following uses structured bindings.
    for (auto& [accountNumber, account] : m_accounts) {
        if (account.getClientName() == name) {
            return account; // found it!
        }
    }
    throw out_of_range { format("No account with name '{}'.", name) };
}

void BankDB::mergeDatabase(BankDB& db)
{
    // Use merge().
    m_accounts.merge(db.m_accounts);
    // Or: m_accounts.insert(begin(db.m_accounts), end(db.m_accounts));

    // Now clear the source database.
    db.m_accounts.clear();
}
\end{cpp}

可以用下面的代码测试BankDB类:

\begin{cpp}
BankDB db;
db.addAccount(BankAccount { 100, "Nicholas Solter" });
db.addAccount(BankAccount { 200, "Scott Kleper" });

try {
    auto& account { db.findAccount(100) };
    println("Found account 100");
    account.setClientName("Nicholas A Solter");

    auto& account2 { db.findAccount("Scott Kleper") };
    println("Found account of Scott Kleper");

    auto& account3 { db.findAccount(1000) };
} catch (const out_of_range& caughtException) {
    println("Unable to find account: {}", caughtException.what());
}
\end{cpp}

输出为:

\begin{shell}
Found account 100
Found account of Scott Kleper
Unable to find account: No account with number 1000.
\end{shell}

\mySamllsection{multimap}

A multimap is a map that allows multiple elements with the same key. Like maps, multimaps support uniform initialization. The interface is almost identical to the map interface, with the following differences:

\begin{itemize}
\item
multimaps do not provide operator[] and at(). The semantics of these do not make sense if there can be multiple elements with a single key.

\item
Inserts on multimaps always succeed. Thus, the multimap::insert() member function that adds a single element returns just an iterator instead of a pair.

\item
The insert\_or\_assign() and try\_emplace() member functions supported by map are not supported by multimap.
\end{itemize}

\begin{myNotic}{NOTE}
multimaps allow you to insert identical key/value pairs. If you want to avoid this redundancy, you must check explicitly before inserting a new element.
\end{myNotic}

The trickiest aspect of multimaps is looking up elements. You can’t use operator[], because it is not provided. find() isn’t very useful because it returns an iterator referring to any one of the elements with a given key (not necessarily the first element with that key).

However, multimaps store all elements with the same key together and provide member functions to obtain iterators for this subrange of elements with the same key in the container. The lower\_bound() and upper\_bound() member functions each return a single iterator referring to the first and one-past-the-last elements matching a given key. If there are no elements matching that key, the iterators returned by lower\_bound() and upper\_bound() will be equal to each other.

If you need to obtain both iterators bounding the elements with a given key, it’s more efficient to use equal\_range() instead of calling lower\_bound() followed by calling upper\_bound(). The equal\_range() member function returns a pair of the two iterators that would be returned by lower\_bound() and upper\_bound().

\begin{myNotic}{NOTE}
The lower\_bound(), upper\_bound(), and equal\_range() member functions exist for maps as well, but their usefulness is limited because a map cannot have multiple elements with the same key.
\end{myNotic}

\mySamllsection{multimap Example: Buddy Lists}

Most of the numerous online chat programs allow users to have a “buddy list” or list of friends. The chat program confers special privileges on users in the buddy list, such as allowing them to send unsolicited messages to the user.

One way to implement the buddy lists for an online chat program is to store the information in a multimap. One multimap could store the buddy lists for every user. Each entry in the container stores one buddy for a user. The key is the user, and the value is the buddy. For example, if Harry Potter and Ron Weasley had each other on their individual buddy lists, there would be two entries of the form “Harry Potter” maps to “Ron Weasley” and “Ron Weasley” maps to “Harry Potter.” A multimap allows multiple values for the same key, so the same user is allowed multiple buddies. Here is the BuddyList class definition:

\begin{cpp}
export class BuddyList final
{
    public:
        // Adds buddy as a friend of name.
        void addBuddy(const std::string& name, const std::string& buddy);
        // Removes buddy as a friend of name.
        void removeBuddy(const std::string& name, const std::string& buddy);
        // Returns true if buddy is a friend of name, false otherwise.
        bool isBuddy(const std::string& name, const std::string& buddy) const;
        // Retrieves a list of all the friends of name.
        std::vector<std::string> getBuddies(const std::string& name) const;
    private:
        std::multimap<std::string, std::string> m_buddies;
};
\end{cpp}

Here are the implementations, with comments explaining the code. It demonstrates the use of lower\_bound(), upper\_bound(), and equal\_range().

\begin{cpp}
void BuddyList::addBuddy(const string& name, const string& buddy)
{
    // Make sure this buddy isn't already there. We don't want
    // to insert an identical copy of the key/value pair.
    if (!isBuddy(name, buddy)) {
        m_buddies.insert({ name, buddy }); // Using initializer_list
    }
}

void BuddyList::removeBuddy(const string& name, const string& buddy)
{
    // Obtain the beginning and end of the range of elements with
    // key 'name'. Use both lower_bound() and upper_bound() to demonstrate
    // their use. Otherwise, it's more efficient to call equal_range().
    auto begin { m_buddies.lower_bound(name) }; // Start of the range
    auto end { m_buddies.upper_bound(name) }; // End of the range

    // Iterate through the elements with key 'name' looking
    // for a value 'buddy'. If there are no elements with key 'name',
    // begin equals end, so the loop body doesn't execute.
    for (auto iter { begin }; iter != end; ++iter) {
        if (iter->second == buddy) {
            // We found a match! Remove it from the map.
            m_buddies.erase(iter);
            break;
        }
    }
}

bool BuddyList::isBuddy(const string& name, const string& buddy) const
{
    // Obtain the beginning and end of the range of elements with
    // key 'name' using equal_range(), and structured bindings.
    auto [begin, end] { m_buddies.equal_range(name) };

    // Iterate through the elements with key 'name' looking
    // for a value 'buddy'.
    for (auto iter { begin }; iter != end; ++iter) {
        if (iter->second == buddy) {
            // We found a match!
            return true;
        }
    }
    // No matches
    return false;
}

vector<string> BuddyList::getBuddies(const string& name) const
{
    // Obtain the beginning and end of the range of elements with
    // key 'name' using equal_range(), and structured bindings.
    auto [begin, end] { m_buddies.equal_range(name) };

    // Create a vector with all names in the range (all buddies of name).
    vector<string> buddies;
    for (auto iter { begin }; iter != end; ++iter) {
        buddies.push_back(iter->second);
    }
    return buddies;
}
\end{cpp}

Note that removeBuddy() can’t simply use the version of erase() that erases all elements with a given key, because it should erase only one element with the key, not all of them. Note also that getBuddies() can’t use insert() on the vector to insert the elements in the range returned by equal\_range(), because the elements referred to by the multimap iterators are key/value pairs, not strings. The getBuddies() member function must iterate explicitly through the range extracting the string from each key/value pair and pushing that onto the new vector to be returned.

Alternatively, with the C++23 ranges functionality discussed in Chapter 17, getBuddies() can be implemented as follows without any explicit loops:

\begin{cpp}
vector<string> BuddyList::getBuddies(const string& name) const
{
    auto [begin, end] { m_buddies.equal_range(name) };
    return ranges::subrange { begin, end } | views::values | ranges::to<vector>();
}
\end{cpp}

Here is a test of the BuddyList:

\begin{cpp}
BuddyList buddies;
buddies.addBuddy("Harry Potter", "Ron Weasley");
buddies.addBuddy("Harry Potter", "Hermione Granger");
buddies.addBuddy("Harry Potter", "Hagrid");
buddies.addBuddy("Harry Potter", "Draco Malfoy");
// That's not right! Remove Draco.
buddies.removeBuddy("Harry Potter", "Draco Malfoy");
buddies.addBuddy("Hagrid", "Harry Potter");
buddies.addBuddy("Hagrid", "Ron Weasley");
buddies.addBuddy("Hagrid", "Hermione Granger");

auto harrysFriends { buddies.getBuddies("Harry Potter") };

println("Harry's friends: ");
for (const auto& name : harrysFriends) {
    println("\t{}", name);
}
\end{cpp}

The output is as follows:

\begin{shell}
Harry's friends:
        Ron Weasley
        Hermione Granger
        Hagrid
\end{shell}

\mySamllsection{set}

A set, defined in <set>, is similar to a map. The difference is that instead of storing key/value pairs, in sets the value is the key. sets are useful for storing information in which there is no explicit key, but which you want to have in sorted order without any duplicates, with quick insertion, lookup, and deletion.

The interface supplied by set is almost identical to that of map. The main difference is that set doesn’t provide operator[], insert\_or\_assign(), and try\_emplace().

You cannot change the value of elements in a set because modifying elements of a set while they are in the container would destroy the order.

\mySamllsection{set Example: Access Control List}

One way to implement basic security on a computer system is through access control lists. Each entity on the system, such as a file or a device, has a list of users with permissions to access that entity. Users can generally be added to and removed from the permissions list for an entity only by users with special privileges. Internally, a set provides a nice way to represent the access control list. You could use one set for each entity, containing all the usernames that are allowed to access the entity. Here is a class definition for a simple access control list:

\begin{cpp}
export class AccessList final
{
    public:
        // Default constructor
        AccessList() = default;
        // Constructor to support uniform initialization.
        AccessList(std::initializer_list<std::string_view> users)
        {
            m_allowed.insert(begin(users), end(users));
        }
        // Adds the user to the permissions list.
        void addUser(std::string user)
        {
            m_allowed.emplace(std::move(user));
        }
        // Removes the user from the permissions list.
        void removeUser(const std::string& user)
        {
            m_allowed.erase(user);
        }
        // Returns true if the user is in the permissions list.
        bool isAllowed(const std::string& user) const
        {
            return m_allowed.contains(user);
        }
        // Returns all the users who have permissions.
        const std::set<std::string>& getAllUsers() const
        {
            return m_allowed;
        }
        // Returns a vector of all the users who have permissions.
        std::vector<std::string> getAllUsersAsVector() const
        {
            return { begin(m_allowed), end(m_allowed) };
        }
    private:
        std::set<std::string> m_allowed;
};
\end{cpp}

Take a look at the interesting one-line implementation of getAllUsersAsVector(). That one line constructs a vector<string> to return, by passing a begin and end iterator of m\_allowed to the vector constructor. If you want, you can split this over two lines:

\begin{cpp}
std::vector<std::string> users { begin(m_allowed), end(m_allowed) };
return users;
\end{cpp}

Finally, here is a simple test program:

\begin{cpp}
AccessList fileX { "mgregoire", "baduser" };
fileX.addUser("pvw");
fileX.removeUser("baduser");

if (fileX.isAllowed("mgregoire")) { println("mgregoire has permissions"); }
if (fileX.isAllowed("baduser")) { println("baduser has permissions"); }

// C++23 supports formatting/printing of ranges, see Chapter 2.
println("Users with access: {:n:}", fileX.getAllUsers());

// Iterating over the elements of a set.
print("Users with access: ");
for (const auto& user : fileX.getAllUsers()) { print("{} ", user); }
println("");

// Iterating over the elements of a vector.
print("Users with access: ");
for (const auto& user : fileX.getAllUsersAsVector()) { print("{} ", user); }
println("");
\end{cpp}

One of the constructors for AccessList uses an initializer\_list as a parameter so that you can use the uniform initialization syntax, as demonstrated in the test program for initializing fileX.

The output of this program is as follows:

\begin{shell}
mgregoire has permissions
Users with access: mgregoire, pvw
Users with access: mgregoire pvw
Users with access: mgregoire pvw
\end{shell}

Note that the m\_allowed data member needs to be a set of std::strings, and not of string\_views. Changing it to a set of string\_views will introduce problems with dangling pointers. For example, suppose you have the following code:

\begin{cpp}
AccessList fileX;
{
    string user { "someuser" };
    fileX.addUser(user);
}
\end{cpp}

This code snippet creates a string called user and then adds that to the fileX access control list. However, the string and the call to addUser() are inside a set of curly brackets; that is, the string has a shorter lifetime than fileX. At the closing curly bracket, the string goes out of scope and is destroyed. This would leave the fileX access control list with a string\_view pointing to a destroyed string, i.e., a dangling pointer! This problem is avoided by using a set of strings.

\mySamllsection{multiset}

A multiset is to a set what a multimap is to a map. A multiset supports all the operations of a set, but it allows multiple elements that are equal to each other to be stored in the container simultaneously. An example of a multiset is not shown because it’s so similar to set and multimap.

\mySubsubsection{18.5.2.}{Unordered Associative Containers Or Hash Tables}

The Standard Library has support for unordered associative containers or hash tables. There are four of them: unordered\_map, unordered\_multimap, unordered\_set, and unordered\_multiset. The map, multimap, set, and multiset containers discussed earlier sort their elements, while these unordered variants do not sort their elements.

\mySamllsection{Hash Functions}

The unordered associative containers are hash tables. That is because the implementation makes use of hash functions. The implementation usually consists of some kind of array where each element in the array is called a bucket. Each bucket has a specific numerical index like 0, 1, 2, up until the last bucket. A hash function transforms a key into a hash value, which is then transformed into a bucket index. The value associated with that key is then stored in that bucket.

The result of a hash function is not always unique. The situation in which two or more keys hash to the same bucket index is called a collision. A collision can occur when different keys result in the same hash value or when different hash values transform to the same bucket index. There are many approaches to handling collisions, including quadratic re-hashing and linear chaining, among others. If you are interested, consult one of the references in the “Algorithms and Data Structures” section in Appendix B. The Standard Library does not specify which collision-handling algorithm is required, but most current implementations have chosen to resolve collisions by linear chaining. With linear chaining, buckets do not directly contain the data values associated with the keys but contain a pointer to a linked list. This linked list contains all the data values for that specific bucket. Figure 18.1 shows how this works.

\myGraphic{0.9}{content/part3/chapter18/images/1.png}{图 18.1}

In Figure 18.1, there are two collisions. The first collision is because applying the hash function to the keys “Marc G.” and “John D.” results in the same hash value that maps to bucket index 128. This bucket then points to a linked list containing the keys “Marc G.” and “John D.” together with their associated data values. The second collision is caused by the hash values for “Scott K.” and “Johan G.” mapping to the same bucket index 129.

From Figure 18.1, it is also clear how lookups based on keys work and what the complexity is.
A lookup involves a single hash function call to calculate the hash value. This hash value is then transformed to a bucket index. Once the bucket index is known, one or more equality operations are required to find the right key in the linked list. This shows that lookups can be much faster compared to lookups with normal maps, but it all depends on how many collisions there are.

The choice of the hash function is important. A hash function that creates no collisions is known as a perfect hash. A perfect hash has a lookup time that is constant; a regular hash has a lookup time that is, on average, close to 1, independent of the number of elements. As the number of collisions increases, the lookup time increases, reducing performance. Collisions can be reduced by increasing the basic hash table size, but you need to take cache sizes into account.

The C++ standard provides hash functions for pointers and all primitive data types such as bool, char, int, float, double, and so on. Hash functions are also provided for several Standard Library classes, such as optional, bitset, unique\_ptr, shared\_ptr, string, string\_view, vector<bool>, and more. If there is no standard hash function available for the type of keys you want to use, then you have to implement your own hash function. Creating a perfect hash is a nontrivial exercise, even when the set of keys is fixed and known. It requires deep mathematical analysis. Even creating a nonperfect one, but one that is good enough and has decent performance, is still challenging. It’s outside the scope of this book to explain the mathematics behind hash functions in detail. Instead, only an example of a simple hash function is given.

The following code demonstrates how to write a custom hash function. The code defines a class IntWrapper that just wraps a single integer. An operator== is provided because that’s a requirement for keys used in unordered associative containers.

\begin{cpp}
class IntWrapper
{
    public:
        explicit IntWrapper(int i) : m_wrappedInt { i } {}
        int getValue() const { return m_wrappedInt; }
        bool operator==(const IntWrapper&) const = default;// = default since C++20
    private:
        int m_wrappedInt;
};
\end{cpp}

To write the actual hash function for IntWrapper, you write a specialization of the std::hash class template for IntWrapper. The std::hash class template is defined in <functional>. This specialization needs an implementation of the function call operator that calculates and returns the hash of a given IntWrapper instance. For this example, the request is simply forwarded to the standard hash function for integers:

\begin{cpp}
namespace std
{
    template<> struct hash<IntWrapper>
    {
        size_t operator()(const IntWrapper& x) const {
            return std::hash<int>{}(x.getValue());
        }
    };
}
\end{cpp}

Note that you normally are not allowed to put anything in the std namespace; however, std class template specializations are an exception to this rule. The implementation of the function call operator is just one line. It creates an instance of the standard hash function for integers——std::hash<int>\{\}—and then calls the function call operator on it with x.getValue() as argument. Note that this forwarding works in this example because IntWrapper contains just one data member, an integer. If the class contained multiple data members, then a hash value would need to be calculated taking all those data members into account; however, those details fall outside the scope of this book.

\mySamllsection{unordered\_map}

unordered\_map is defined in <unordered\_map> as a class template:

\begin{cpp}
template <typename Key,
          typename T,
          typename Hash = hash<Key>,
          typename Pred = std::equal_to<Key>,
          typename Alloc = std::allocator<std::pair<const Key, T>>>
    class unordered_map;
\end{cpp}

There are five template type parameters: the key type, the value type, the hash type, the equality comparator type, and the allocator type. The last three parameters have default values. The most important parameters are the first two. As with maps, uniform initialization can be used to initialize an unordered\_map. Iterating over the elements is also similar to maps, as shown in the following example.

\begin{cpp}
unordered_map<int, string> m {
    {1, "Item 1"}, {2, "Item 2"}, {3, "Item 3"}, {4, "Item 4"}
};
// Using C++23 support for formatting/printing ranges.
println("{}", m);
// Using structured bindings.
for (const auto& [key, value] : m) { print("{} = {}, ", key, value); }
println("");
// Without structured bindings.
for (const auto& p : m) { print("{} = {}, ", p.first, p.second); }
\end{cpp}

The output is as follows:

\begin{shell}
{4: "Item 4", 3: "Item 3", 2: "Item 2", 1: "Item 1"}
4 = Item 4, 3 = Item 3, 2 = Item 2, 1 = Item 1,
4 = Item 4, 3 = Item 3, 2 = Item 2, 1 = Item 1,
\end{shell}

The following table summarizes the differences between map and unordered\_map. A filled box (■) means the container supports that operation, while an empty box (□) means the operation is not supported.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{操作}                           & \textbf{map} & \textbf{unordered\_map} \\ \hline
\endfirsthead
%
\endhead
%
at()                                         & ■            & ■                       \\ \hline
begin()                                      & ■            & ■                       \\ \hline
begin(n)                                     & □            & ■                       \\ \hline
bucket()                                     & □            & ■                       \\ \hline
bucket\_count()                              & □            & ■                       \\ \hline
bucket\_size()                               & □            & ■                       \\ \hline
cbegin()                                     & ■            & ■                       \\ \hline
cbegin(n)                                    & □            & ■                       \\ \hline
cend()                                       & ■            & ■                       \\ \hline
cend(n)                                      & □            & ■                       \\ \hline
clear()                                      & ■            & ■                       \\ \hline
contains()                                   & ■            & ■                       \\ \hline
count()                                      & ■            & ■                       \\ \hline
crbegin()                                    & ■            & □                       \\ \hline
crend()                                      & ■            & □                       \\ \hline
emplace()                                    & ■            & ■                       \\ \hline
emplace\_hint()                              & ■            & ■                       \\ \hline
empty()                                      & ■            & ■                       \\ \hline
end()                                        & ■            & ■                       \\ \hline
end(n)                                       & □            & ■                       \\ \hline
equal\_range()                               & ■            & ■                       \\ \hline
erase()                                      & ■            & ■                       \\ \hline
extract()                                    & ■            & ■                       \\ \hline
find()                                       & ■            & ■                       \\ \hline
insert()                                     & ■            & ■                       \\ \hline
insert\_or\_assign()                         & ■            & ■                       \\ \hline
insert\_range() (C++23)                      & ■            & ■                       \\ \hline
iterator / const\_iterator                   & ■            & ■                       \\ \hline
load\_factor()                               & □            & ■                       \\ \hline
local\_iterator / const\_local\_iterator     & □            & ■                       \\ \hline
lower\_bound()                               & ■            & □                       \\ \hline
max\_bucket\_count()                         & □            & ■                       \\ \hline
max\_load\_factor()                          & □            & ■                       \\ \hline
max\_size()                                  & ■            & ■                       \\ \hline
merge()                                      & ■            & ■                       \\ \hline
operator{[}{]}                               & ■            & ■                       \\ \hline
rbegin()                                     & ■            & □                       \\ \hline
rehash()                                     & □            & ■                       \\ \hline
rend()                                       & ■            & □                       \\ \hline
reserve()                                    & □            & ■                       \\ \hline
reverse\_iterator / const\_reverse\_iterator & ■            & □                       \\ \hline
size()                                       & ■            & ■                       \\ \hline
swap()                                       & ■            & ■                       \\ \hline
try\_emplace()                               & ■            & ■                       \\ \hline
upper\_bound()                               & ■            & □                       \\ \hline
\end{longtable}

As with map, all keys in an unordered\_map must be unique. The preceding table includes a number of hash-specific member functions. For example, load\_factor() returns the average number of elements per bucket to give you an indication of the number of collisions. The bucket\_count() member function returns the number of buckets in the container. It also provides a local\_iterator and const\_local\_iterator, allowing you to iterate over the elements in a single bucket; however, these may not be used to iterate across buckets. The bucket(key) member function returns the index of the bucket that contains the given key; begin(n) returns a local\_iterator referring to the first element in the bucket with index n, and end(n) returns a local\_iterator referring to one-past-the-last element in the bucket with index n. The example in the next section demonstrates how to use some of these member functions.

\mySamllsection{unordered\_map Example: Phone Book}

The following example uses an unordered\_map to represent a phone book. The name of a person is the key, while the phone number is the value associated with that key.

\begin{cpp}
void printMap(const auto& m) // Abbreviated function template
{
    for (auto& [key, value] : m) {
        println("{} (Phone: {})", key, value);
    }
    println("-------");
}

int main()
{
    // Create a hash table.
    unordered_map<string, string> phoneBook {
        { "Marc G.", "123-456789" },
        { "Scott K.", "654-987321" } };
    printMap(phoneBook);

    // Add/remove some phone numbers.
    phoneBook.insert(make_pair("John D.", "321-987654"));
    phoneBook["Johan G."] = "963-258147";
    phoneBook["Freddy K."] = "999-256256";
    phoneBook.erase("Freddy K.");
    printMap(phoneBook);

    // Find the bucket index for a specific key.
    const size_t bucket { phoneBook.bucket("Marc G.") };
    println("Marc G. is in bucket {} containing the following {} names:",
        bucket, phoneBook.bucket_size(bucket));
    // Get begin and end iterators for the elements in this bucket.
    // 'auto' is used here. The compiler deduces the type of
    // both as unordered_map<string, string>::const_local_iterator
    auto localBegin { phoneBook.cbegin(bucket) };
    auto localEnd { phoneBook.cend(bucket) };
    for (auto iter { localBegin }; iter != localEnd; ++iter) {
        println("\t{} (Phone: {})", iter->first, iter->second);
    }
    println("-------");

    // Print some statistics about the hash table
    println("There are {} buckets.", phoneBook.bucket_count());
    println("Average number of elements in a bucket is {}.",
    phoneBook.load_factor());
}
\end{cpp}

A possible output is as follows. Note that the output can be different on different systems, because it depends on the implementation of both the hash function and the unordered\_map itself being used.

\begin{shell}
Scott K. (Phone: 654-987321)
Marc G. (Phone: 123-456789)
-------
Scott K. (Phone: 654-987321)
Marc G. (Phone: 123-456789)
Johan G. (Phone: 963-258147)
John D. (Phone: 321-987654)
-------
Marc G. is in bucket 1 containing the following 2 names:
        Scott K. (Phone: 654-987321)
        Marc G. (Phone: 123-456789)
-------
There are 8 buckets.
Average number of elements in a bucket is 0.5
\end{shell}

\mySamllsection{unordered\_multimap}

An unordered\_multimap is an unordered\_map that allows multiple elements with the same key. Their interfaces are almost identical, with the following differences:

\begin{itemize}
\item
unordered\_multimaps do not provide operator[] and at(). The semantics of these do not make sense if there can be multiple elements with a single key.

\item
Inserts on unordered\_multimaps always succeed. Thus, the unordered\_multimap::insert() member function that adds a single element returns just an iterator instead of a pair.

\item
The insert\_or\_assign() and try\_emplace() member functions supported by unordered\_map are not supported by an unordered\_multimap.
\end{itemize}

\begin{myNotic}{NOTE}
unordered\_multimaps allow you to insert identical key/value pairs. If you want to avoid this redundancy, you must check explicitly before inserting a new element.
\end{myNotic}

As discussed earlier with multimaps, looking up elements in unordered\_multimaps cannot be done using operator[] because it is not provided. You can use find(), but it returns an iterator referring to any one of the elements with a given key (not necessarily the first element with that key). Instead, it’s best to use the equal\_range() member function, which returns a pair of iterators: one referring to the first element matching a given key, and one referring to one-past-the-last element matching that key. The use of equal\_range() is the same as discussed for multimaps, so you can look at the example given for multimaps to see how it works.

\mySamllsection{unordered\_set/unordered\_multiset}

<unordered\_set> defines unordered\_set and unordered\_multiset, which are similar to set and multiset, respectively, except that they do not sort their keys but use a hash function. The differences between unordered\_set and unordered\_map are similar to the differences between set and map as discussed earlier in this chapter, so they are not discussed in detail here. Consult a Standard Library Reference for a thorough summary of unordered\_set and unordered\_multiset operations.

\CXXTwentythreeLogo{-40}{-50}

\mySubsubsection{18.5.3.}{Flat Set and Flat Map Associative Container Adapters}

C++23 introduces the following new container adapters:

\begin{itemize}
\item
std::flat\_set and flat\_multiset defined in <flat\_set>

\item
std::flat\_map and flat\_multimap defined in <flat\_map>
\end{itemize}

These are adapters providing an associative container interface on top of sequential containers.
flat\_set and flat\_map require unique keys, just as set and map, while flat\_multiset and flat\_multimap support duplicate keys, just as multiset and multimap. They all store their data sorted on the keys using std::less as the default comparator. flat\_set and flat\_multiset provide for fast retrieval of a key, while flat\_map and flat\_multimap provide for fast retrieval of a value based on a key. A flat\_set and a flat\_multiset require one underlying sequential container to store their keys. A flat\_map and a flat\_multimap require two underlying containers, one to store the keys and another one to store the values. The underlying container must support random-access iterators, such as vector and deque. By default, vector is used.

All flat associative container adapters have an interface similar to their ordered counterparts, except that the flat container adapters are not node-based data structures and thus don’t have any concept of node handles as discussed earlier in this chapter in the context of the ordered associative containers. Another difference is that the flat variants provide random-access iterators, while the ordered counterparts provide only bidirectional iterators.

With the addition of these flat container adapters, the Standard Library now provides three variants of each associative container type; e.g., there are now three map containers: map, unordered\_map, and flat\_map. All three basically work in a similar fashion, but they store their data in drastically different data structures and thus have different time- and space-efficiency. Because the flat associative container adapters store their data sorted in sequential containers, they all have linear time complexity for adding and removing elements, which can potentially be slower than adding and removing elements from ordered and unordered containers. Lookups have logarithmic complexity, just as the ordered associative containers. However, for the flat variants, lookups and especially iteration over the elements are more efficient than for the ordered ones because the former store their data in sequential containers and thus have a much more efficient and cache-friendly memory layout. They also need less memory per element compared to the ordered or unordered variants. Which one of the three flavors per type to choose for a specific use case depends on the exact requirements of your use case. If performance is important, then I recommend profiling all three of them to find out which one is best suited for a specific use. Profiling is explained in Chapter 29, “Writing Efficient C++.”

The flat associative container adapters are often just drop-in replacements for their ordered counterparts. For example, the access control list example from earlier has a data member called m\_allowed of type set<string>, an ordered associative container. The code can easily be changed to use a flat\_set instead. Two changes are necessary. First, the type of m\_allowed is changed to the following:

\begin{cpp}
std::flat_set<std::string> m_allowed;
\end{cpp}

Second, the return type of getAllUsers() is changed to a flat\_set:

\begin{cpp}
const std::flat_set<std::string>& getAllUsers() const { return m_allowed; }
\end{cpp}

Everything else remains the same.

\mySubsubsection{18.5.4.}{Performance of Associative Containers}

As is clear from this section, the C++ Standard Library contains several different associative containers. How do you know which one to use for a certain task? If iterating over the contents of an associative container is important for your use case, then the flat associative container adapters have the best performance, because of the way they store their data in continuous memory. If other operations are more important for you, then the unordered associative containers are usually faster compared to the ordered ones. However, if performance is really important, then the only way to decide on the correct container is by benchmarking all of them for your specific use case. Usually, though, you can just pick the one that is easier to work with. To use the ordered versions with your own class types, you must implement comparison operations for your class, while for the unordered versions, you need to write a hash function. The latter is usually harder to implement.











第1章中解释了C++中的运算符，如+、<、*和<{}<，可作用于内置类型，如int和double，允许执行算术、逻辑和其他操作。还有如->和*这样的运算符，对指针解引用。C++中的运算符概念很广泛，甚至包括[]（数组索引）、()（函数调用）、类型转换以及内存分配和回收运算符。运算符重载允许你改变语言运算符对你类的行为。然而，这种能力也有自己的规则、限制和选择。

\mySubsubsection{15.1.1.}{为什么要重载运算符？}

学习如何重载运算符之前，可能想知道为什么你想要这样做。因不同的运算符而异，但一般的指导原则是让类表现得像内置类型。类越接近内置类型，客户端使用起来就越容易。例如，写一个类来表示分数，能够定义+、-、*和/在应用于该类的对象时就会很有用。

重载运算符的另一个原因是，获得对程序行为更大的控制权。例如，重载类内存分配和回收运算符，以精确指定每个新对象的内存分配和回收。

需要强调的是，运算符重载并不一定会让开发工作更容易，其主要目的是让类的用户使用起来更容易。

\mySubsubsection{15.1.2.}{运算符重载的限制}

以下是在重载运算符时不能做的事情：

\begin{itemize}
\item
不能添加新的运算符符号，只能重新定义语言中已有的运算符的含义。本章后面“可重载运算符总结”一节中的表格，列出了可以重载的运算符。

\item
有些运算符不能重载，比如.和.*（对象中的成员访问）、::（范围解析运算符）和?:（条件运算符）。

\item
元数描述了与运算符相关联的参数或操作数的数量。只能更改函数调用、new和delete运算符的元数，以及，自C++23起，还可以更改下标运算符（数组索引）[]的元数。对于所有其他运算符，不能更改元数。一元运算符，如++，只作用于一个操作数。二元运算符，如/，作用于两个操作数。

\item
不能改变运算符的优先级和结合性。优先级用于决定哪些运算符需要在其他运算符之前执行，而结合性可以是左到右或右到左，并指定具有相同优先级的运算符的执行顺序。再次强调，这个约束在大多数程序中不应该是关注的焦点，很有有改变求值顺序的需求，但在某些领域中，这是需要考虑的。例如，正在编写一个表示数学向量的类，并希望重载\^{}运算符以便能够将向量提升到一定的幂，那么请记住\^{}与许多其他运算符（如+）相比具有较低的优先级。例如，x和y是数学向量，编写x\^{}3+y将计算为x\^{}(3+y)，而不是(x\^{}3)+y。

\item
不能为内置类型重新定义运算符。运算符必须是类中的成员函数，或者至少全局重载运算符函数的一个参数必须是用户定义类型（例如，类）。所以不能做些荒谬的事情，比如将+对int的定义改为减法（尽管可以在自己的类中这样做）。这个规则的例外是内存分配和回收运算符，可以替换程序中所有内存分配的全局运算符。
\end{itemize}

有些运算符已经有两个不同的含义。例如，运算符-可以用作二元运算符（如在x=y-z;中）或一元运算符（如在x=-y;中）。*运算符可以用作乘法或对指针解引用。<{}<运算符是流插入运算符或左移运算符，具体取决于上下文。对于具有双重含义的运算符，可以两种含义都重载。

\mySubsubsection{15.1.3.}{选择操作符重载}

重载操作符时，需要编写一个名为operatorX的全局函数或成员函数，其中X是某个操作符的符号，operator和X之间可以有可选的空格。例如，第9章为SpreadsheetCell对象声明operator+：

\begin{cpp}
SpreadsheetCell operator+(const SpreadsheetCell& lhs, const SpreadsheetCell& rhs);
\end{cpp}

以下各节描述了在编写每个重载操作符时，涉及到的选择。

\mySamllsection{成员函数或全局函数}

首先，需要决定操作符应该是类的成员函数，还是全局函数。后者可以是类的友元函数，但应作为最后的手段——应尽可能限制向类添加友元函数，因为它们可以直接访问private数据成员，从而绕过数据隐藏原则。

如何选择成员函数和全局函数？首先，需要了解这两种选择的区别。当操作符是类的成员函数时，操作符表达式的左侧必须始终是该类的对象。如果编写一个全局函数，左侧可以是不同类型的对象。

有三种不同类型的操作符：

\begin{itemize}
\item
必须作为成员函数的操作符。因为它们在类的外部没有意义，所以C++语言要求某些操作符必须是类的成员函数。例如，operator=与类紧密相关，不能存在于其他任何地方。本节“可重载操作符的总结”中的表格列出了必须作为成员函数的操作符，大多数操作符没有这个要求。

\item
必须作为全局函数的操作符。当需要允许操作符左侧的变量与类不同的类型时，必须使操作符成为全局函数。这条规则特别适用于<{}<和>{>}插入和提取流操作符，其中左侧是iostream对象，而不是类的对象。这也适用于像二进制+和-这样的交换操作符，允许左侧的变量不是类的对象。如果希望为二元操作符的左操作数进行隐式转换，则需要全局函数。第9章已经介绍了这个问题。

\item
可以作为成员函数或全局函数的操作符。在C++社区中，关于是否最好将操作符重载为成员函数或全局函数存在一些分歧。然而，我建议，除非必须按照前面的描述将其作为全局函数，否则使每个操作符成为成员函数。

这个规则的一个主要优点是，成员函数可以是虚函数，而全局函数显然不能。因此，在继承树中编写重载操作符时，尽可能应使它们成为成员函数。
\end{itemize}

将重载操作符编写为成员函数时，如果不改变对象，应将其标记为const。

将重载操作符编写为全局函数时，将其放在包含要编写操作符的类的同一命名空间中。

\mySamllsection{Choosing Argument Types}

You are somewhat limited in your choice of argument types because, as stated earlier, for most operators you cannot change the number of arguments. For example, operator/ must always have two arguments if it is a global function, and one argument if it’s a member function. The compiler issues an error if it differs from this standard. In this sense, the operator functions are different from normal functions, which you can overload with any number of parameters. Additionally, although you can write the operator for whichever types you want, the choice is usually constrained by the class for which you are writing the operator. For example, if you want to implement addition for class T, you don’t write an operator+ that takes two strings! The real choice arises when you try to determine whether to take parameters by value or by reference and whether to make them const.

The choice of value versus reference is easy: you should take every non-primitive parameter type by reference, unless the function always makes a copy of the passed object, see Chapter 9.

The const decision is also trivial: mark every parameter const unless you actually modify it. The table in the section “Summary of Overloadable Operators” shows sample prototypes for each operator, with the arguments marked const and reference as appropriate.

\mySamllsection{Choosing Return Types}

C++ doesn’t determine overload resolution based on return type. Thus, you can specify any return type you want when you write overloaded operators. However, just because you can do something doesn’t mean you should do it. This flexibility implies that you could write confusing code in which comparison operators return pointers, and arithmetic operators return bools. However, you shouldn’t do that. Instead, you should write your overloaded operators such that they return the same types as the operators do for the built-in types. If you write a comparison operator, return a bool. If you write an arithmetic operator, return an object representing the result. Sometimes the return type is not obvious at first. For example, as Chapter 8 mentions, operator= should return a reference to the object on which it’s called in order to support chained assignments. Other operators have similarly tricky return types, all of which are summarized in the table in the section “Summary of Overloadable Operators.”

The same choices of reference and const apply to return types as well. However, for return values, the choices are more difficult. The general rule for value or reference is to return a reference if you can; otherwise, return a value. How do you know when you can return a reference? This choice applies only to operators that return objects: the choice is moot for the comparison operators that return bool, the conversion operators that have no return type, and the function call operator, which may return any type you want. If your operator constructs a new object, then you must return that new object by value. If it does not construct a new object, you can return a reference to the object on which the operator is called, or one of its arguments. The table in the section “Summary of Overloadable Operators” shows examples.

A return value that can be modified as an lvalue (e.g., on the left-hand side of an assignment expression) must be non-const. Otherwise, it should be const. More operators than you might expect require that you return lvalues, including all of the assignment operators (operator=, operator+=, operator-=, and so on).

\mySamllsection{Choosing Behavior}

You can provide whichever implementation you want in an overloaded operator. For example, you could write an operator+ that launches a game of Scrabble. However, as Chapter 6 describes, you should generally constrain your implementations to provide behaviors that clients expect. Write operator+ so that it performs addition, or something like addition, such as string concatenation. This chapter explains how you should implement your overloaded operators. In exceptional circumstances, you might want to differ from these recommendations; but, in general, you should follow the standard patterns.

\mySubsubsection{15.1.4.}{Operators You Shouldn’t Overload}

Some operators should not be overloaded, even though it is permitted. Specifically, the address-of operator (operator\&) is not particularly useful to overload and leads to confusion if you do because you are changing fundamental language behavior (taking addresses of variables) in potentially unexpected ways. The entire Standard Library, which uses operator overloading extensively, never overloads the address-of operator.

Additionally, you should avoid overloading the binary Boolean operators operator\&\& and || because you lose C++’s short-circuit evaluation rules. Short-circuiting is not possible in that case because all operands need to be evaluated before they can be passed to your overloaded operator function. If your class needs logical operators, provide operator\& and | instead.

Finally, you should not overload the comma operator (operator,). Yes, you read that correctly: there really is a comma operator in C++. It’s also called the sequencing operator, and is used to separate two expressions in a single statement, while guaranteeing that they are evaluated left to right. The following snippet demonstrates the comma operator:

\begin{cpp}
int x { 1 };
println("{}", (++x, 2 * x)); // Increments x to 2, doubles it, and prints 4.
\end{cpp}

There is rarely a good reason to overload the comma operator.

\mySubsubsection{15.1.5.}{Summary of Overloadable Operators}

The following table lists the operators you can overload, specifies whether they should be member functions of the class or global functions, summarizes when you should (or should not) overload them, and provides sample prototypes showing the proper parameter and return value types. Operators that cannot be overloaded, such as ., .*, ::, and ?: are not in this list.

This table is a useful reference for the future when you want to write an overloaded operator. You’re bound to forget which return type you should use and whether or not the function should be a member function.

In this table, T is the name of the class for which the overloaded operator is written, and E is a different type. The sample prototypes given are not exhaustive; often there are other combinations of T and E possible for a given operator:

% Please add the following required packages to your document preamble:
% \usepackage[normalem]{ulem}
% \useunder{\uline}{\ul}{}
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|l|l|}
\hline
\textbf{OPERATOR} &
\textbf{\begin{tabular}[c]{@{}l@{}}NAME OR\\ CATEGORY\end{tabular}} &
\textbf{\begin{tabular}[c]{@{}l@{}}MEMBER\\ FUNCTION\\ OR GLOBAL\\ FUNCTION\end{tabular}} &
\textbf{\begin{tabular}[c]{@{}l@{}}WHEN TO\\ OVERLOAD\end{tabular}} &
\textbf{\begin{tabular}[c]{@{}l@{}}SAMPLE\\ PROTOTYPES\end{tabular}} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}operator+\\ operator\\ operator*\\ operator/\\ operator\%\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Binary\\ arithmetic\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Global function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ you want to\\ provide these\\ operations for\\ your class\end{tabular} &
\begin{tabular}[c]{@{}l@{}}T operator+(const\\ T\&, const T\&);\\ T operator+(const\\ T\&, const E\&);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator\\ operator+\\ operator˜\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Unary\\ arithmetic\\ and bitwise\\ operators\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ you want to\\ provide these\\ operations for\\ your class\end{tabular} &
T operator-() const; \\ \hline
\begin{tabular}[c]{@{}l@{}}operator++\\ operator--\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Pre-increment\\ and pre\\ decrement\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever you\\ overload +=\\ and -= taking\\ an arithmetic\\ argument (int,\\ long, . . .)\end{tabular} &
T\& operator++(); \\ \hline
\begin{tabular}[c]{@{}l@{}}operator++\\ operator--\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Post-increment\\ and post\\ decrement\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever you\\ overload +=\\ and -= taking\\ an arithmetic\\ argument (int,\\ long, . . .)\end{tabular} &
T operator++(int); \\ \hline
operator= &
\begin{tabular}[c]{@{}l@{}}Assignment\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ required\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ your class has\\ dynamically\\ allocated\\ resources, or\\ members that\\ are references\end{tabular} &
\begin{tabular}[c]{@{}l@{}}T\& operator=(const\\ T\&);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator+=\\ operator-=\\ operator*=\\ operator/=\\ operator\%=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Shorthand /\\ compound\\ arithmetic\\ assignment\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ you overload\\ the binary\\ arithmetic\\ operators and\\ your class is not\\ designed to be\\ immutable\end{tabular} &
\begin{tabular}[c]{@{}l@{}}T\& operator+=(const\\ T\&);\\ T\& operator+=(const\\ E\&);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator\textless{}\textless\\ operator\textgreater{}\textgreater\\ operator\&\\ operator|\\ operator\textasciicircum{}\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Binary bitwise\\ operators\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Global function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ you want to\\ provide these\\ operations\end{tabular} &
\begin{tabular}[c]{@{}l@{}}T operator\textless{}\textless{}(const\\ T\&, const T\&);\\ T operator\textless{}\textless{}(const\\ T\&, const E\&);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator\textless{}\textless{}=\\ operator\textgreater{}\textgreater{}=\\ operator\&=\\ operator|=\\ operator\textasciicircum{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Shorthand /\\ compound\\ bitwise\\ assignment\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever you\\ overload the\\ binary bitwise\\ operators and\\ your class is not\\ designed to be\\ immutable\end{tabular} &
\begin{tabular}[c]{@{}l@{}}T\& operator\textless{}\textless{}=(const\\ T\&);\\ T\& operator\textless{}\textless{}=(const\\ E\&);\end{tabular} \\ \hline
operator\textless{}=\textgreater{} &
\begin{tabular}[c]{@{}l@{}}Three-way\\ comparison\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever you\\ want to provide\\ comparison\\ support for\\ your class; if\\ possible, this\\ should be\\ defaulted using\\ =default\end{tabular} &
\begin{tabular}[c]{@{}l@{}}auto\\ operator\textless{}=\textgreater{}(const\\ T\&) const = default;\\ partial\_ordering\\ operator\textless{}=\textgreater{}(const\\ E\&) const;\end{tabular} \\ \hline
operator== &
\begin{tabular}[c]{@{}l@{}}Binary equality\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Post-C++20:\\ member function\\ recommended\\ Pre-C++20:\\ global function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever you\\ want to provide\\ comparison\\ support for\\ your class, and\\ you cannot\\ default the\\ three-way\\ comparison\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}bool operator==(const\\ T\&) const;\\ bool operator==(const\\ E\&) const;\\ bool operator==(const\\ T\&, const T\&);\\ bool operator==(const\\ T\&, const E\&);\end{tabular} \\ \hline
operator!= &
\begin{tabular}[c]{@{}l@{}}Binary\\ inequality\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Post-C++20:\\ member function\\ recommended\\ Pre-C++20:\\ global function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Post-C++20:\\ not needed as\\ the compiler\\ automatically\\ provides !=\\ when == is\\ supported\\ Pre-C++20:\\ Whenever you\\ want to provide\\ comparison\\ support for\\ your class\end{tabular} &
\begin{tabular}[c]{@{}l@{}}bool operator!=(const\\ T\&) const;\\ bool operator!=(const\\ E\&) const;\\ bool operator!=(const\\ T\&, const T\&);\\ bool operator!=(const\\ T\&, const E\&);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator\textless\\ operator\textgreater\\ operator\textless{}=\\ operator\textgreater{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Binary\\ comparison\\ operators\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Global function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ you want to\\ provide these\\ operations; not\\ needed when\\ \textless{}=\textgreater is provided\end{tabular} &
\begin{tabular}[c]{@{}l@{}}bool operator\textless{}(const\\ T\&, const T\&);\\ bool operator\textless{}(const\\ T\&, const E\&);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator\textless{}\textless\\ operator\textgreater{}\textgreater{}\end{tabular} &
\begin{tabular}[c]{@{}l@{}}I/O stream\\ operators\\ (insertion and\\ extraction)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Global function\\ required\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ you want to\\ provide these\\ operations\end{tabular} &
\begin{tabular}[c]{@{}l@{}}ostream\&\\ operator\textless{}\textless{}(ostream\&,\\ const T\&);\\ istream\&\\ operator\textgreater{}\textgreater{}(istream\&,\\ T\&);\end{tabular} \\ \hline
operator! &
\begin{tabular}[c]{@{}l@{}}Boolean\\ negation\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Rarely; use\\ bool or void*\\ conversion\\ instead\end{tabular} &
\begin{tabular}[c]{@{}l@{}}bool operator!()\\ const;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator\&\&\\ operator||\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Binary Boolean\\ operators\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Global function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Rarely, if ever,\\ because you\\ lose short\\ circuiting;\\ it’s better to\\ overload \& and\\ | instead, as\\ these never\\ short-circuit\end{tabular} &
\begin{tabular}[c]{@{}l@{}}bool operator\&\&(const\\ T\&, const T\&);\end{tabular} \\ \hline
operator{[}{]} &
\begin{tabular}[c]{@{}l@{}}Subscripting\\ (array index)\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ required\end{tabular} &
\begin{tabular}[c]{@{}l@{}}When you want\\ to support\\ subscripting\end{tabular} &
\begin{tabular}[c]{@{}l@{}}E\& operator{[}{]}\\ (size\_t);\\ const E\& operator{[}{]}\\ (size\_t) const;\end{tabular} \\ \hline
operator() &
\begin{tabular}[c]{@{}l@{}}Function call\\ operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ required\end{tabular} &
\begin{tabular}[c]{@{}l@{}}When you\\ want objects\\ to behave\\ like function\\ pointers\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Return type and parameters\\ can vary; see later examples\\ in this chapter\end{tabular} \\ \hline
operator type() &
\begin{tabular}[c]{@{}l@{}}Conversion, or\\ cast, operators\\ (separate\\ operator for\\ each type)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ required\end{tabular} &
\begin{tabular}[c]{@{}l@{}}When you want\\ to provide\\ conversions\\ from your class\\ to other types\end{tabular} &
\begin{tabular}[c]{@{}l@{}}operator double()\\ const;\end{tabular} \\ \hline
operator ""\_x &
\begin{tabular}[c]{@{}l@{}}User-defined\\ literal operator\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Global function\\ required\end{tabular} &
\begin{tabular}[c]{@{}l@{}}When you want\\ to support user\\ defined literals\end{tabular} &
\begin{tabular}[c]{@{}l@{}}T operator""\_i(long\\ double d);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator new\\ operator new{[}{]}\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Memory\\ allocation\\ routines\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}When you\\ want to control\\ memory\\ allocation for\\ your classes\\ (rarely)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}void* operator\\ new(size\_t size);\\ void* operator new{[}{]}\\ (size\_t size);\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator delete\\ operator delete{[}{]}\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Memory\\ deallocation\\ routines\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Whenever\\ you overload\\ the memory\\ allocation\\ routines (rarely)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}void operator\\ delete(void* ptr)\\ noexcept;\\ void operator\\ delete{[}{]}(void* ptr)\\ noexcept;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}operator*\\ operator-\textgreater{}\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Dereferencing\\ operators\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Member function\\ recommended\\ for operator*\\ Member function\\ required for\\ operator-\textgreater{}\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Useful for smart\\ pointers\end{tabular} &
\begin{tabular}[c]{@{}l@{}}E\& operator*() const;\\ E* operator-\textgreater{}()\\ const;\end{tabular} \\ \hline
operator\& &
\begin{tabular}[c]{@{}l@{}}Address-of\\ operator\end{tabular} &
N/A &
Never &
N/A \\ \hline
operator-\textgreater{}* &
\begin{tabular}[c]{@{}l@{}}Dereference\\ pointer-to\\ member\end{tabular} &
N/A &
Never &
N/A \\ \hline
operator, &
\begin{tabular}[c]{@{}l@{}}Comma\\ operator\end{tabular} &
N/A &
Never &
N/A \\ \hline
\end{longtable}



\mySubsubsection{15.1.6.}{Rvalue References}

Chapter 9 discusses move semantics and rvalue references. It demonstrates these by defining move assignment operators, which are used by the compiler in cases where the source object is a temporary object that will be destroyed after the assignment, or an object that is explicitly moved from using std::move(). The normal assignment operator from the preceding table has the following prototype:

\begin{cpp}
T& operator=(const T&);
\end{cpp}

The move assignment operator has almost the same prototype, but uses an rvalue reference. It modifies the argument so it cannot be passed as const. See Chapter 9 for details.

\begin{cpp}
T& operator=(T&&) noexcept;
\end{cpp}

The preceding table does not include sample prototypes with rvalue references. However, for most operators it can make sense to write both a version using normal lvalue references and a version using rvalue references. Whether or not it does make sense depends on implementation details of your class. The operator= is one example from Chapter 9. Another example is operator+ to prevent unnecessary memory allocations. The std::string class from the Standard Library, for example, implements an operator+ using rvalue references as follows (simplified):

\begin{cpp}
string operator+(string&& lhs, string&& rhs);
\end{cpp}

The implementation of this operator reuses memory of one of the arguments because they are being passed as rvalue references, meaning both are temporary objects that will be destroyed when this operator+ is finished. The implementation of this operator+ has the following effect depending on the size and the capacity of both operands:

\begin{cpp}
return move(lhs.append(rhs));
\end{cpp}

or

\begin{cpp}
return move(rhs.insert(0, lhs));
\end{cpp}

In fact, string defines several operator+ overloads accepting two strings as arguments and different combinations of lvalue and rvalue references. Here is a list (simplified):

\begin{cpp}
string operator+(const string& lhs, const string& rhs); // No memory reuse.
string operator+(string&& lhs, const string& rhs); // Can reuse memory of lhs.
string operator+(const string& lhs, string&& rhs); // Can reuse memory of rhs.
string operator+(string&& lhs, string&& rhs); // Can reuse memory of lhs or rhs.
\end{cpp}

Reusing memory of one of the rvalue reference arguments is implemented in the same way as it is explained for move assignment operators in Chapter 9.

\mySubsubsection{15.1.7.}{Precedence and Associativity}

In statements containing multiple operators, the precedence of the operators is used to decide which operators need to be executed before other operators. For example, * and / are always executed before + and -.

The associativity can be either left-to-right or right-to-left and specifies in which order operators of the same precedence are executed.

The following table lists the precedence and associativity of all available C++ operators, including those that you cannot overload and operators you haven’t seen mentioned in this book yet. Operators with a lower precedence number are executed before operators with a higher precedence number. In the table, T represents a type, while x, y, and z represent objects:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{PRECEDENCE} & \textbf{OPERATOR}                                   & \textbf{ASSOCIATIVITY} \\ \hline
\endfirsthead
%
\endhead
%
1                   & ::                                                  & Left-to-right          \\ \hline
2                   & x++{} x-- x() x{[}{]} T() T\{\} . -\textgreater{}     & Left-to-right          \\ \hline
3 &
\begin{tabular}[c]{@{}l@{}}++x --x +x -x ! ˜ *x \&x (T)\\ sizeof co\_await new delete new{[}{]} delete{[}{]}\end{tabular} &
Right-to-left \\ \hline
4                   & .* -\textgreater{}*                                 & Left-to-right          \\ \hline
5                   & x*y x/y x\%y                                        & Left-to-right          \\ \hline
6                   & x+y x-y                                             & Left-to-right          \\ \hline
7                   & \textless{}\textless \textgreater{}\textgreater{}   & Left-to-right          \\ \hline
8                   & \textless{}=\textgreater{}                          & Left-to-right          \\ \hline
9                   & \textless \textless{}= \textgreater \textgreater{}= & Left-to-right          \\ \hline
10                  & == !=                                               & Left-to-right          \\ \hline
11                  & x\&y                                                & Left-to-right          \\ \hline
12                  & \textasciicircum{}                                  & Left-to-right          \\ \hline
13                  & |                                                   & Left-to-right          \\ \hline
14                  & \&\&                                                & Left-to-right          \\ \hline
15                  & ||                                                  & Left-to-right          \\ \hline
16 &
\begin{tabular}[c]{@{}l@{}}x?y:z throw co\_yield\\ = += -= *= /= \%= \textless{}\textless{}= \textgreater{}\textgreater{}= \&= \textasciicircum{}= |=\end{tabular} &
Right-to-left \\ \hline
17                  & ,                                                   & Left-to-right          \\ \hline
\end{longtable}

\mySubsubsection{15.1.8.}{Relational Operators}

The following set of function templates for relational operators are defined in <utility> in the std::rel\_ops namespace:

\begin{cpp}
template<class T> bool operator!=(const T& a, const T& b);// Needs operator==
template<class T> bool operator>(const T& a, const T& b); // Needs operator<
template<class T> bool operator<=(const T& a, const T& b);// Needs operator<
template<class T> bool operator>=(const T& a, const T& b);// Needs operator<
\end{cpp}

These function templates define the operators !=, >, <=, and >= in terms of the == and < operators for any class. So, if you implement operator== and < for your class, you get the other relational operators for free with these templates.

However, there are a lot of problems with this technique. A first problem is that those operators might be created for all classes that you use in relational operations, not only for your own class.

A second problem with this technique is that utility templates such as std::greater<T> (discussed in Chapter 19, “Function Pointers, Function Objects, and Lambda Expressions”) do not work with those automatically generated relational operators.

Yet another problem with these is that implicit conversions won’t work.

Finally, with C++20’s three-way comparison operator and the fact that C++20 has deprecated the std::rel\_ops namespace, there is no longer any reason to still use rel\_ops.

\begin{myWarning}{WARNING}
Never use std::rel\_ops; it has been deprecated since C++20! Instead, to add support for all six comparison operators to a class, just explicitly default or implement operator<=> and possibly operator== for the class. See Chapter 9 for details.
\end{myWarning}

\mySubsubsection{15.1.9.}{Alternative Notation}

C++ supports the following alternative notations for a selection of operators. These were mainly used in the old days when using character sets that didn’t include certain characters such as ~, |, and \^{}.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|l|}
\hline
\textbf{OPERATOR} & \textbf{ALTERNATIVE NOTATION} & \textbf{OPERATOR} & \textbf{ALTERNATIVE NOTATION} \\ \hline
\endfirsthead
%
\endhead
%
\&\&   & and     & !=                  & not\_eq \\ \hline
\&=    & and\_eq & ||                  & or      \\ \hline
\&     & bitand  & |=                  & or\_eq  \\ \hline
|      & bitor   & \textasciicircum{}  & xor     \\ \hline
$\sim$ & compl   & \textasciicircum{}= & xor\_eq \\ \hline
！      & not     &                     &         \\ \hline
\end{longtable}




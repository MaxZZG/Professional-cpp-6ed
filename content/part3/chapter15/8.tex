
Going back to the SpreadsheetCell example, consider these two lines of code:

\begin{cpp}
SpreadsheetCell cell { 1.23 };
double d1 { cell }; // DOES NOT COMPILE!
\end{cpp}

A SpreadsheetCell contains a double representation, so it seems logical that you could assign it to a double variable. Well, you can’t. The compiler tells you that it doesn’t know how to convert a SpreadsheetCell to a double. You might be tempted to try forcing the compiler to do what you want, like this:

\begin{cpp}
double d1 { (double)cell }; // STILL DOES NOT COMPILE!
\end{cpp}

First, the preceding code still doesn’t compile because the compiler still doesn’t know how to convert the SpreadsheetCell to a double. It already knew from the first line what you wanted it to do, and it would do it if it could. Second, it’s a bad idea in general to add gratuitous casts to your program.

If you want to allow this kind of conversion, you must tell the compiler how to perform it. Specifically, you can write a conversion operator to convert SpreadsheetCells to doubles. The prototype looks like this:

\begin{cpp}
operator double() const;
\end{cpp}

The name of the function is operator double. It has no return type because the return type is specified by the name of the operator: double. It is const because it doesn’t change the object on which it is called. The implementation looks like this:

\begin{cpp}
SpreadsheetCell::operator double() const
{
    return getValue();
}
\end{cpp}

That’s all you need to do to write a conversion operator from SpreadsheetCell to double. Now the compiler accepts the following lines and does the right thing at run time:

\begin{cpp}
SpreadsheetCell cell { 1.23 };
double d1 { cell }; // Works as expected
\end{cpp}

You can write conversion operators for any type with this same syntax. For example, here is an std::string conversion operator for SpreadsheetCell:

\begin{cpp}
operator std::string() const;
\end{cpp}

And here is an implementation:

\begin{cpp}
SpreadsheetCell::operator std::string() const
{
    return doubleToString(getValue());
}
\end{cpp}

Now you can convert a SpreadsheetCell to a string. However, due to the constructors provided by string, the following does not work:

\begin{cpp}
string str { cell };
\end{cpp}

Instead, you can either use normal assignment syntax instead of uniform initialization, or use an explicit static\_cast() as follows:

\begin{cpp}
string str1 = cell;
string str2 { static_cast<string>(cell) };
\end{cpp}


\mySubsubsection{15.8.1.}{Operator auto}

Instead of explicitly specifying the type that a conversion operator returns, you can specify auto and let the compiler deduce it for you. For example, the double conversion operator of SpreadsheetCell could be written as follows:

\begin{cpp}
operator auto() const { return getValue(); }
\end{cpp}

There is one caveat, the implementation of member functions with auto return type deduction must be visible to users of the class. Hence, this example puts the implementation directly in the class definition.

Also, remember from Chapter 1 that auto strips away reference and const qualifiers. So, if your operator auto returns a reference to a type T, then the deduced type will be T returned by value, resulting in a copy being made. If needed, you can explicitly add reference and const qualifiers; here’s an example:

\begin{cpp}
operator const auto&() const { /* ... */ }
\end{cpp}

\mySubsubsection{15.8.2.}{Solving Ambiguity Problems with Explicit Conversion Operators}

Writing the double conversion operator for the SpreadsheetCell object introduces an ambiguity problem. Consider this line:

\begin{cpp}
SpreadsheetCell cell { 6.6 };
double d1 { cell + 3.4 }; // DOES NOT COMPILE IF YOU DEFINE operator double()
\end{cpp}

This line now fails to compile. It worked before you wrote operator double(), so what’s the problem now? The issue is that the compiler doesn’t know if it should convert cell to a double with operator double() and perform double addition, or convert 3.4 to a SpreadsheetCell with the double constructor and perform SpreadsheetCell addition. Before you wrote operator double(), the compiler had only one choice: convert 3.4 to a SpreadsheetCell with the double constructor and perform SpreadsheetCell addition. However, now the compiler could do either. It doesn’t want to make a choice you might not like, so it refuses to make any choice at all.

The usual pre-C++11 solution to this conundrum is to make the constructor in question explicit so that the automatic conversion using that constructor is prevented (see Chapter 8). However, you don’t want that constructor to be explicit because you generally like the automatic conversion of doubles to SpreadsheetCells. Since C++11, you can solve this problem by making the double conversion operator explicit instead of the constructor:

\begin{cpp}
explicit operator double() const;
\end{cpp}

With this change the following line compiles fine:

\begin{cpp}
double d1 { cell + 3.4 }; // 10
\end{cpp}

The operator auto as discussed in the previous section can also be marked as explicit.

\mySubsubsection{15.8.3.}{Conversions for Boolean Expressions}

Sometimes it is useful to be able to use objects in Boolean expressions. For example, programmers often use pointers in conditional statements like this:

\begin{cpp}
if (ptr != nullptr) { /* Perform some dereferencing action. */ }
\end{cpp}

Sometimes they write shorthand conditions such as this:

\begin{cpp}
if (ptr) { /* Perform some dereferencing action. */ }
\end{cpp}

Other times, you see code as follows:

\begin{cpp}
if (!ptr) { /* Do something. */ }
\end{cpp}

Currently, none of the preceding expressions compile with the Pointer smart pointer class template defined earlier. To make them work, we can add a conversion operator to the class to convert it to a pointer type. Then, the comparisons to nullptr, as well as the object alone in an if statement, will trigger the conversion to the pointer type. The usual pointer type for the conversion operator is void*, because that’s a pointer type with which you cannot do much except test it in Boolean expressions. Here is the implementation:

\begin{cpp}
operator void*() const { return m_ptr; }
\end{cpp}

Now the following code compiles and does what you expect:

\begin{cpp}
void process(const Pointer<SpreadsheetCell>& p)
{
    if (p != nullptr) { println("not nullptr"); }
    if (p != 0)       { println("not 0"); }
    if (p)            { println("not nullptr"); }
    if (!p)           { println("nullptr"); }
}

int main()
{
    Pointer<SpreadsheetCell> smartCell { nullptr };
    process(smartCell);
    println("");

    Pointer<SpreadsheetCell> anotherSmartCell { new SpreadsheetCell { 5.0 } };
    process(anotherSmartCell);
}
\end{cpp}

The output is as follows:

\begin{shell}
nullptr

not nullptr
not 0
not nullptr
\end{shell}

Another alternative is to overload operator bool() as follows instead of operator void*(). After all, you’re using the object in a Boolean expression; why not convert it directly to a bool?

\begin{cpp}
operator bool() const { return m_ptr != nullptr; }
\end{cpp}

The following comparisons still work:

\begin{cpp}
if (p != 0) { println("not 0"); }
if (p)      { println("not nullptr"); }
if (!p)     { println("nullptr"); }
\end{cpp}

However, with operator bool(), the following comparison with nullptr results in a compilation error:

\begin{cpp}
if (p != nullptr) { println("not nullptr"); } // Error
\end{cpp}

This is because nullptr has its own type called nullptr\_t, which is not automatically converted to the integer 0 (false). The compiler cannot find an operator!= that takes a Pointer object and a nullptr\_t object. You could implement such an operator!= as a friend of the Pointer class:

\begin{cpp}
export template <typename T>
class Pointer
{
    public:
        // Omitted for brevity
        template <typename T>
        friend bool operator!=(const Pointer<T>& lhs, std::nullptr_t rhs);
        // Omitted for brevity
};

export template <typename T>
bool operator!=(const Pointer<T>& lhs, std::nullptr_t rhs)
{
    return lhs.m_ptr != rhs;
}
\end{cpp}

However, after implementing this operator!=, the following comparison stops working, because the compiler no longer knows which operator!= to use:

\begin{cpp}
if (p != 0) { println("not 0"); }
\end{cpp}

From this example, you might conclude that the operator bool() technique only seems appropriate for objects that don’t represent pointers and for which conversion to a pointer type really doesn’t make sense. Unfortunately, even then, adding a conversion operator to bool presents some other unanticipated consequences. C++ applies promotion rules to silently convert bool to int whenever the opportunity arises. Therefore, with the operator bool(), the following code compiles and runs:

\begin{cpp}
Pointer<SpreadsheetCell> anotherSmartCell { new SpreadsheetCell { 5.0 } };
int i { anotherSmartCell }; // Converts Pointer to bool to int.
\end{cpp}

That’s usually not behavior that you expect or desire. To prevent such assignments, you could explicitly delete the conversion operators to int, long, long long, and so on. However, this is getting messy. So, many programmers prefer operator void*() instead of operator bool().

As you can see, there is a design element to overloading operators. Your decisions about which operators to overload directly influence the ways in which clients can use your classes.


\noindent
\textbf{WHAT’S IN THIS CHAPTER?}

\begin{itemize}
\item
What operator overloading is

\item
Rationale for overloading operators

\item
Limitations, caveats, and choices in operator overloading

\item
Summary of operators you can, cannot, and should not overload

\item
How to overload unary plus, unary minus, increment, and decrement

\item
How to overload the I/O stream operators (operator<{}< and operator>{}>)

\item
How to overload the subscripting (array index) operator

\item
How to write multidimensional subscripting operators

\item
How to overload the function call operator

\item
How to overload the dereferencing operators (* and ->)

\item
How to write conversion operators

\item
How to overload the memory allocation and deallocation operators

\item
How to define your own user-defined literal operators

\item
The available standard literal operators
\end{itemize}

\noindent
\textbf{WILEY.COM DOWNLOADS FOR THIS CHAPTER}

Please note that all the code examples for this chapter are available as part of this chapter’s code download on the book’s website at \url{www.wiley.com/go/proc++6e} on the Download Code tab.

C++ allows you to redefine the meanings of operators, such as +, -, and =, for your classes. Many object-oriented languages do not provide this capability, so you might be tempted to disregard its usefulness in C++. However, it is instrumental for making your classes behave similarly to built-in types such as ints and doubles. It is even possible to write classes that look like arrays, functions, or pointers.

Chapter 5, “Designing with Classes,” and Chapter 6, “Designing for Reuse,” introduce object-oriented design and operator overloading, respectively. Chapter 8, “Gaining Proficiency with Classes and Objects,” and Chapter 9, “Mastering Classes and Objects,” present the syntax details for objects and for basic operator overloading. This chapter picks up operator overloading where Chapter 9 left off.












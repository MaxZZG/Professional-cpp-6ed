
C++ gives you the ability to redefine the way memory allocation and deallocation work in your programs. You can provide this customization both on the global level and the class level. This capability is most useful when you are worried about memory fragmentation, which can occur if you allocate and deallocate a lot of small objects. For example, instead of going to the default C++ memory allocation each time you need memory, you could write a memory pool allocator that reuses fixed-size chunks of memory. This section explains the subtleties of the memory allocation and deallocation routines and shows you how to customize them. With these tools, you should be able to write your own allocator if the need ever arises.

\begin{myWarning}{WARNING}
Unless you know a lot about memory allocation strategies, attempts to overload the memory allocation routines are rarely worth the trouble. Don’t overload them just because it sounds like a neat idea. Only do so if you have a genuine requirement and the necessary knowledge.
\end{myWarning}

\mySubsubsection{15.9.1.}{How new and delete Really Work}

One of the trickiest aspects of C++ is the details of new and delete. Consider this line of code:

\begin{cpp}
SpreadsheetCell* cell { new SpreadsheetCell {} };
\end{cpp}

The part new SpreadsheetCell\{\} is called the new-expression. It does two things. First, it allocates space for the SpreadsheetCell object by making a call to operator new. Second, it calls the constructor for the object. Only after the constructor has completed does it return the pointer to you.

delete works analogously. Consider this line of code:

\begin{cpp}
delete cell;
\end{cpp}

This line is called the delete-expression. It first calls the destructor for cell and then calls operator delete to free the memory.

You can overload operator new and operator delete to control memory allocation and deallocation, but you cannot overload the new-expression or the delete-expression. Thus, you can customize the actual memory allocation and deallocation, but not the calls to the constructor and destructor.

\mySamllsection{The New-Expression and operator new}

There are six different forms of the new-expression, each of which has a corresponding operator new. Earlier chapters in this book already show four new-expressions: new, new[], new(nothrow), and new(nothrow)[]. The following list shows the corresponding four operator new overloads defined in <new>:

\begin{cpp}
void* operator new(std::size_t size);
void* operator new[](std::size_t size);
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;
\end{cpp}

There are two special new-expressions that don’t do any allocation but invoke the constructor on an already allocated piece of memory. These are called placement new operators (including both single and array forms). They allow you to construct an object in pre-allocated memory like this:

\begin{cpp}
void* ptr { allocateMemorySomehow() };
SpreadsheetCell* cell { new (ptr) SpreadsheetCell {} };
\end{cpp}

The two corresponding operator new overloads for these look as follows; however, the C++ standard forbids you to overload them:

\begin{cpp}
void* operator new(std::size_t size, void* p) noexcept;
void* operator new[](std::size_t size, void* p) noexcept;
\end{cpp}

This feature is a bit obscure, but it’s important to know that it exists. It can come in handy if you want to implement memory pools by reusing memory without freeing it in between. This allows you to construct and destruct instances of an object without re-allocating memory for each new instance. Chapter 29, “Writing Efficient C++,” gives an example of a memory pool implementation.


\mySamllsection{The Delete-Expression and operator delete}

There are only two different forms of the delete-expression that you can call: delete, and delete[]; there are no nothrow or placement forms. However, there are all six overloads of operator delete.
Why the asymmetry? The two nothrow and two placement overloads are used only if an exception is thrown from a constructor. In that case, the operator delete is called that matches the operator new that was used to allocate the memory prior to the constructor call. However, if you delete a pointer normally, delete calls operator delete and delete[] calls operator delete[] (never the nothrow or placement forms). Practically, this doesn’t really matter because the C++ standard says that throwing an exception from delete (for example, from a destructor called by delete) results in undefined behavior. This means delete should never throw an exception anyway, so the nothrow overload of operator delete is superfluous. Also, placement delete should be a no-op, because placement new doesn’t allocate any memory, so there’s nothing to free.

Here are the prototypes for the six operator delete overloads corresponding to the six operator new overloads:

\begin{cpp}
void operator delete(void* ptr) noexcept;
void operator delete[](void* ptr) noexcept;
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* ptr, void*) noexcept;
void operator delete[](void* ptr, void*) noexcept;
\end{cpp}

\mySubsubsection{15.9.2.}{Overloading operator new and operator delete}

You can replace the global operator new and operator delete routines if you want. These functions are called for every new-expression and delete-expression in the program, unless there are more specific routines in individual classes. However, to quote Bjarne Stroustrup, “. . . replacing the global operator new and operator delete is not for the fainthearted” (The C++ Programming Language, third edition, Addison-Wesley, 1997). I don’t recommend it either!

\begin{myWarning}{WARNING}
If you fail to heed my advice and decide to replace the global operator new, keep in mind that you cannot put any code in the operator that makes a call to new because this will cause an infinite recursion. For example, you cannot write a message to the console with print().
\end{myWarning}

A more useful technique is to overload operator new and operator delete for specific classes.
These overloaded operators will be called only when you allocate and deallocate objects of that particular class. Here is an example of a class that overloads the four non-placement forms of operator new and operator delete:

\begin{cpp}
export class MemoryDemo
{
    public:
        virtual ~MemoryDemo() = default;
        void* operator new(std::size_t size);
        void operator delete(void* ptr) noexcept;
        void* operator new[](std::size_t size);
        void operator delete[](void* ptr) noexcept;
        void* operator new(std::size_t size, const std::nothrow_t&) noexcept;
        void operator delete(void* ptr, const std::nothrow_t&) noexcept;
        void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;
        void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
};
\end{cpp}

Here are implementations of these operators that simply write out a message to the standard output and pass the arguments through to calls to the global versions of the operators. Note that nothrow is actually a variable of type nothrow\_t.

\begin{cpp}
void* MemoryDemo::operator new(size_t size)
{
    println("operator new");
    return ::operator new(size);
}
void MemoryDemo::operator delete(void* ptr) noexcept
{
    println("operator delete");
    ::operator delete(ptr);
}
void* MemoryDemo::operator new[](size_t size)
{
    println("operator new[]");
    return ::operator new[](size);
}
void MemoryDemo::operator delete[](void* ptr) noexcept
{
    println("operator delete[]");
    ::operator delete[](ptr);
}
void* MemoryDemo::operator new(size_t size, const nothrow_t&) noexcept
{
    println("operator new nothrow");
    return ::operator new(size, nothrow);
}
void MemoryDemo::operator delete(void* ptr, const nothrow_t&) noexcept
{
    println("operator delete nothrow");
    ::operator delete(ptr, nothrow);
}
void* MemoryDemo::operator new[](size_t size, const nothrow_t&) noexcept
{
    println("operator new[] nothrow");
    return ::operator new[](size, nothrow);
}
void MemoryDemo::operator delete[](void* ptr, const nothrow_t&) noexcept
{
    println("operator delete[] nothrow");
    ::operator delete[](ptr, nothrow);
}
\end{cpp}

Here is some code that allocates and frees objects of this class in several ways:

\begin{cpp}
MemoryDemo* mem { new MemoryDemo{} };
delete mem;
mem = new MemoryDemo[10];
delete [] mem;
mem = new (nothrow) MemoryDemo{};
delete mem;
mem = new (nothrow) MemoryDemo[10];
delete [] mem;
\end{cpp}

Here is the output from running the program:

\begin{shell}
operator new
operator delete
operator new[]
operator delete[]
operator new nothrow
operator delete
operator new[] nothrow
operator delete[]
\end{shell}

These implementations of operator new and operator delete are obviously trivial and not particularly useful. They are intended only to give you an idea of the syntax in case you ever want to implement nontrivial versions of them.

\begin{myWarning}{WARNING}
Whenever you overload operator new, overload the corresponding form of operator delete. Otherwise, memory will be allocated as you specify but freed according to the built-in semantics, which may not be compatible.
\end{myWarning}

It might seem overkill to overload all the various forms of operator new and operator delete. However, it’s generally a good idea to do so to prevent inconsistencies in memory allocations. If you don’t want to provide implementations for certain overloads, you can explicitly delete these using =delete to prevent anyone from using them. See the next section for more information.

\begin{myWarning}{WARNING}
Overload all forms of operator new and operator delete, or explicitly delete overloads that you don’t want to get used, to prevent inconsistencies in the memory allocations.
\end{myWarning}

\mySubsubsection{15.9.3.}{Explicitly Deleting or Defaulting operator new and operator delete}

Chapter 8 shows how you can explicitly delete or default a constructor or assignment operator. Explicitly deleting or defaulting is not limited to constructors and assignment operators. For example, the following class deletes operator new and new[], which means that objects of this class cannot be dynamically allocated using new or new[]:

\begin{cpp}
class MyClass
{
    public:
        void* operator new(std::size_t) = delete;
        void* operator new[](std::size_t) = delete;
        void* operator new(std::size_t, const std::nothrow_t&) noexcept = delete;
        void* operator new[](std::size_t, const std::nothrow_t&) noexcept = delete;
};
\end{cpp}

Using this class as follows results in compilation errors:

\begin{cpp}
MyClass* p1 { new MyClass };
MyClass* p2 { new MyClass[2] };
MyClass* p3 { new (std::nothrow) MyClass };
\end{cpp}

\mySubsubsection{15.9.4.}{Overloading operator new and operator delete with Extra Parameters}

In addition to overloading the standard forms of operator new, you can write your own versions with extra parameters. These extra parameters can be useful for passing various flags or counters to your memory allocation routines. For instance, some runtime libraries use this in debug mode to provide the filename and line number where an object is allocated, so when there is a memory leak, the offending line that did the allocation can be identified.

As an example, here are the prototypes for an additional operator new and operator delete with an extra integer parameter for the MemoryDemo class:

\begin{cpp}
void* operator new(std::size_t size, int extra);
void operator delete(void* ptr, int extra) noexcept;
\end{cpp}

The implementations are as follows:

\begin{cpp}
void* MemoryDemo::operator new(std::size_t size, int extra)
{
    println("operator new with extra int: {}", extra);
    return ::operator new(size);
}
void MemoryDemo::operator delete(void* ptr, int extra) noexcept
{
    println("operator delete with extra int: {}", extra);
    return ::operator delete(ptr);
}
\end{cpp}

When you write an overloaded operator new with extra parameters, the compiler automatically allows the corresponding new-expression. The extra arguments to new are passed with function call syntax (as with nothrow overloads). So, you can now write code like this:

\begin{cpp}
MemoryDemo* memp { new(5) MemoryDemo{} };
delete memp;
\end{cpp}

The output is as follows:

\begin{shell}
operator new with extra int: 5
operator delete
\end{shell}

When you define an operator new with extra parameters, you should also define the corresponding operator delete with the same extra parameters. However, you cannot call this operator delete with extra parameters yourself; it will be called only when you use your operator new with extra parameters and the constructor of your object throws an exception.

\mySubsubsection{15.9.5.}{Overloading operator delete with Size of Memory as Parameter}

An alternate form of operator delete gives you the size of the memory that should be freed as well as the pointer. Simply declare the prototype for operator delete with an extra size parameter.

\begin{myWarning}{WARNING}
If a class declares two overloads of operator delete with one overload taking the size as a parameter and the other doesn’t, the overload without the size parameter will always get called. If you want the overload with the size parameter to be used, write only that overload.
\end{myWarning}

You can replace operator delete with an overload that takes a size for any of the overloads of operator delete independently. Here is the MemoryDemo class definition with the first operator delete modified to take the size of the memory to be deleted:

\begin{cpp}
export class MemoryDemo
{
    public:
        // Omitted for brevity
        void* operator new(std::size_t size);
        void operator delete(void* ptr, std::size_t size) noexcept;
        // Omitted for brevity
};
\end{cpp}

The implementation of this operator delete again simply calls the global operator delete:

\begin{cpp}
void MemoryDemo::operator delete(void* ptr, size_t size) noexcept
{
    println("operator delete with size {}", size);
    ::operator delete(ptr, size);
}
\end{cpp}

This capability is useful only if you are writing a complicated memory allocation and deallocation scheme for your classes.





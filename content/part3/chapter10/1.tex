
第5章中，了解到is-a关系描述了现实世界事物间的层次结构模式。在编程中，需要编写一个建立在另一个类之上或稍微改变另一个类的类时，可以使用这种模式。实现这一目标的一种方式是，从一个类复制代码并将其粘贴到另一个类中。通过更改相关部分或修改代码，可以实现创建一个与原始类略有不同的新类。然而，这种方法会让面向对象开发者感到沮丧和非常烦恼，原因如下：

\begin{itemize}
\item
因为这两个类包含完全独立的代码，原始类的错误修复不会反映在新类中。

\item
编译器不知道两个类之间的关系，所以它们不是多态的（参见第5章）——它们不是同一事物的不同变体。

\item
这种方法没有建立真正的is-a关系。新类与原始类相似，只有相似的代码，而不是同一类型的对象。

\item
原始代码可能无法获得，可能只存在于预编译的二进制格式中，所以复制和粘贴代码可能不可行。
\end{itemize}

毫不奇怪，C++提供了内置支持来定义真正的is-a关系。C++中is-a关系的特征将在下一节描述。

\mySubsubsection{10.1.1.}{扩展类}

在C++中编写类定义时，可以告诉编译器类正在继承、派生或扩展一个已存在的类。这样，类会自动包含原始类的数据成员和成员函数，这个原始类称为父类、基类或超类。扩展一个已存在的类让其（称为子类、派生类或子类）有能力仅描述它与父类的不同之处。 要在C++中扩展一个类，需要在编写类定义时指定要扩展的类。

为了展示继承语法，我们使用了两个类，Base和Derived。别担心——后面会有更有趣的例子。首先，看看Base类的定义：

\begin{cpp}
class Base
{
    public:
        void someFunction() {}
    protected:
        int m_protectedInt { 0 };
    private:
        int m_privateInt { 0 };
};
\end{cpp}

如果想要构建一个新类，称为Derived，继承自Base，可以使用以下语法：

\begin{cpp}
class Derived : public Base
{
    public:
        void someOtherFunction() {}
};
\end{cpp}

Derived是一个完整的类，共享了Base类的特性。现在先别担心public——其含义会在后面进行解释。图10.1展示了Derived和Base之间的简单关系。可以像声明任何其他对象一样声明Derived类型的对象，甚至可以定义一个从Derived继承的第三个类，形成一个类链，如图10.2所示。

\myGraphic{0.2}{content/part3/chapter10/images/1.png}{图 10.1}

\myGraphic{0.25}{content/part3/chapter10/images/2.png}{图 10.2}

Derived不必是Base的唯一派生类。其他类也可以从Base继承，并成为Derived的兄弟类，如图10.3所示。

\myGraphic{0.35}{content/part3/chapter10/images/3.png}{图 10.3}

内部，派生类包含一个基类的实例作为子对象，关系可以表示为图10.4。

\myGraphic{0.3}{content/part3/chapter10/images/4.png}{图 10.4}

\mySamllsection{客户端对继承的看法}

对于客户端或代码的其他部分来说，因为Derived继承自Base，Derived类型的对象也是一个Base类型的对象。所以Base的所有public成员函数和数据成员，以及Derived的所有public成员函数和数据成员都可用。

使用派生类的代码不需要知道，在继承链中哪个类定义了成员函数就可以调用。例如，以下代码调用了Derived对象的两个成员函数，即使其中一个成员函数由Base类定义：

\begin{cpp}
Derived myDerived;
myDerived.someFunction();
myDerived.someOtherFunction();
\end{cpp}

要理解继承只在一个方向上起作用。Derived类与Base类有一个明确的关系，但Base类，对Derived类一无所知，所以Base类型的对象不能访问Derived的成员函数和数据成员，因为Base不是Derived。

以下代码不能编译，因为Base类不包含一个名为someOtherFunction()的public成员函数：

\begin{cpp}
Base myBase;
myBase.someOtherFunction(); // Error! Base doesn't have a someOtherFunction().
\end{cpp}

\begin{myNotic}{NOTE}
从使用对象的角度来看，对象属于其定义的类以及基类。
\end{myNotic}

指向类类型的指针或引用，可以引用声明类类型的对象或其任何派生类的对象，这个棘手的问题会在本章后面详细解释。现在要理解的是，指向Base的指针实际上可以指向Derived对象，引用也是如此。客户端仍然只能访问Base中存在的成员函数和数据成员，但通过这种机制，操作Base的代码也可以操作Derived。

例如，以下代码编译并运行良好，即使看起来类型并不匹配：

\begin{cpp}
Base* base { new Derived {} }; // Create Derived, store in Base pointer.
\end{cpp}

然而，不能通过Base指针调用Derived类的成员函数。以下代码无法工作：

\begin{cpp}
base->someOtherFunction();
\end{cpp}

编译器将其标记为错误，因为尽管对象是Derived类型，确实有someOtherFunction()的定义，但编译器只能将其视为Base类型，而Base类型没有定义someOtherFunction()。

\mySamllsection{派生类对继承的看法}

对于派生类来说，在编写方式或行为方面并没有太大变化。仍可以在派生类中定义成员函数和数据成员，就像在常规类中一样。前面Derived的定义声明了一个名为someOtherFunction()的成员函数，Derived类可以通过添加成员函数来增强Base类。

派生类可以访问其基类中声明的public和protected的成员函数和数据成员，就像是自己的成员一样，从技术上讲确实是。例如，Derived上someOtherFunction()的实现可以利用在Base中，声明为一部分的数据成员m\_protectedInt。访问基类成员与在派生类中声明成员没有什么不同：

\begin{cpp}
void Derived::someOtherFunction()
{
    println("I can access base class data member m_protectedInt.");
    println("Its value is {}", m_protectedInt);
}
\end{cpp}

如果一个类将成员声明为protected，派生类可以访问它们。如果声明为private，派生类则无法访问。以下someOtherFunction()的实现无法编译，因为派生类试图访问基类中的private数据成员：

\begin{cpp}
void Derived::someOtherFunction()
{
    println("I can access base class data member m_protectedInt.");
    println("Its value is {}", m_protectedInt);
    println("The value of m_privateInt is {}", m_privateInt); // Error!
}
\end{cpp}

private访问说明符可以控制潜在的派生类如何与基类交互。

第4章给出了以下规则：所有数据成员都应该是private；如果希望从类外部访问数据成员，请提供公共的getter和setter。现在这个规则可以扩展到protected访问说明符。

\begin{myWarning}{WARNING}
所有数据成员都应该是private。如果希望从类外部访问数据成员，请提供公共的getter和setter；如果只想让派生类访问，请提供protected的getter和setter。
\end{myWarning}

默认将数据成员设为private的原因是，提供了最高级别的封装。可以更改表示数据的方式，同时保持公共和受保护的接口不变。此外，在不直接访问数据成员的情况下，可以在public和protected的setter中轻松添加对输入数据的检查。成员函数也应该默认为private。只公开那些设计为公共的成员函数，如果只想让派生类访问，请将成员函数设为protected。

\begin{myNotic}{NOTE}
从派生类的角度来看，基类中的所有public和protected的数据成员和成员函数都可用。
\end{myNotic}

下表总结了所有三种访问说明符的含义：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{\begin{tabular}[c]{@{}l@{}}访问说明符\end{tabular}} &
\textbf{含义} &
\textbf{何时使用} \\ \hline
\endfirsthead
%
\endhead
%
public &
\begin{tabular}[c]{@{}l@{}}可以调用一个对象的public成员函数\\或访问其public数据成员。
\end{tabular} &
\begin{tabular}[c]{@{}l@{}}希望客户端进行的操作（成员函数）。\\可访问对private和protected数据成\\员进行操作的成员函数（getter和\\setter）。
\end{tabular} \\ \hline
protected &
\begin{tabular}[c]{@{}l@{}}类中的任何成员函数都可以调用protected\\的成员函数和protected的数据成员。派生\\类的成员函数可以访问基类的protected成员。
\end{tabular} &
\begin{tabular}[c]{@{}l@{}}不想让客户端使用的成员函数。
\end{tabular} \\ \hline
private &
\begin{tabular}[c]{@{}l@{}}只有类中的成员函数可以调用private成员\\函数和private数据成员。派生类中的成员\\函数不能访问基类的private成员。
\end{tabular} &
\begin{tabular}[c]{@{}l@{}}默认情况下，一切都应该是private，\\尤其是数据成员。如果只想允许派生\\类访问，可以提供protected的getter\\和setter；如果希望客户端访问，可\\以提供public的getter和setter。
\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{防止继承}

C++允许将一个类标记为final，当尝试继承时将出现编译错误。一个类可以通过在类名后面直接使用final关键字来标记“不可继承”。例如，一个类尝试从下面的Foo类继承，编译器将报错：

\begin{cpp}
class Foo final { };
\end{cpp}

\mySubsubsection{10.1.2.}{重载成员函数}

The main reasons to inherit from a class are to add or replace functionality. The definition of Derived adds functionality to its parent class by providing an additional member function, someOtherFunction(). The other member function, someFunction(), is inherited from Base and behaves in the derived class exactly as it does in the base class. In many cases, you will want to modify the behavior of a class by replacing, or overriding, a member function.

\mySamllsection{ virtual 关键字}

Simply defining a member function from a base class in a derived class does not properly override that member function. To correctly override a member function, we need a new C++ keyword called virtual. Only member functions that are declared as virtual in the base class can be overridden properly by derived classes. The keyword goes at the beginning of a member function declaration as shown in the modified version of Base that follows:

\begin{cpp}
class Base
{
    public:
        virtual void someFunction();
        // Remainder omitted for brevity.
};
\end{cpp}

The same holds for the Derived class. Its member functions should also be marked virtual if you want to override them in further derived classes:

\begin{cpp}
class Derived : public Base
{
    public:
        virtual void someOtherFunction();
};
\end{cpp}

The virtual keyword is not repeated in front of the member function definition, e.g.:

\begin{cpp}
void Base::someFunction()
{
    println("This is Base's version of someFunction().");
}
\end{cpp}

\begin{myWarning}{WARNING}
Attempting to override a non-virtual member function from a base class hides the base class definition, and it will be used only in the context of the derived class.
\end{myWarning}

\mySamllsection{Syntax for Overriding a Member Function}

To override a member function, you redeclare it in the derived class definition exactly as it was declared in the base class, but you add the override keyword and remove the virtual keyword. For example, if you want to provide a new definition for someFunction() in the Derived class, you must first add it to the class definition for Derived, as follows:

\begin{cpp}
class Derived : public Base
{
    public:
        void someFunction() override; // Overrides Base's someFunction()
        virtual void someOtherFunction();
};
\end{cpp}

The new definition of someFunction() is specified along with the rest of Derived’s member functions. Just as with the virtual keyword, you do not repeat the override keyword in the member function definition:

\begin{cpp}
void Derived::someFunction()
{
    println("This is Derived's version of someFunction().");
}
\end{cpp}

If you want, you are allowed to add the virtual keyword in front of overridden member functions, but it’s redundant. Here’s an example:

\begin{cpp}
class Derived : public Base
{
    public:
        virtual void someFunction() override; // Overrides Base's someFunction()
};
\end{cpp}

Once a member function or destructor is marked as virtual, it is virtual for all derived classes even if the virtual keyword is removed from derived classes.

\mySamllsection{A Client’s View of Overridden Member Functions}

With the preceding changes, other code still calls someFunction() the same way it did before. Just as before, the member function could be called on an object of class Base or an object of class Derived. Now, however, the behavior of someFunction() varies based on the class of the object.

For example, the following code works just as it did before, calling Base’s version of someFunction():

\begin{cpp}
Base myBase;
myBase.someFunction(); // Calls Base's version of someFunction().
\end{cpp}

The output of this code is as follows:

\begin{shell}
This is Base's version of someFunction().
\end{shell}

If the code declares an object of class Derived, the other version is automatically called:

\begin{cpp}
Derived myDerived;
myDerived.someFunction(); // Calls Derived's version of someFunction()
\end{cpp}

The output this time is as follows:

\begin{shell}
This is Derived's version of someFunction().
\end{shell}

Everything else about objects of class Derived remains the same. Other member functions that might have been inherited from Base still have the definition provided by Base unless they are explicitly overridden in Derived.

As you learned earlier, a pointer or reference can refer to an object of a class or any of its derived classes. The object itself “knows” the class of which it is actually a member, so the appropriate member function is called as long as it was declared virtual. For example, if you have a Base reference that refers to an object that is really a Derived, calling someFunction() actually calls the derived class’s version, as shown next. This aspect of overriding does not work properly if you omit the virtual keyword in the base class.

\begin{cpp}
Derived myDerived;
Base& ref { myDerived };
ref.someFunction(); // Calls Derived's version of someFunction()
\end{cpp}

Remember that even though a Base reference or pointer knows that it is referring to a Derived instance, you cannot access Derived class members that are not defined in Base. The following code does not compile because a Base reference does not have a member function called someOtherFunction():

\begin{cpp}
Derived myDerived;
Base& ref { myDerived };
myDerived.someOtherFunction(); // This is fine.
ref.someOtherFunction(); // Error
\end{cpp}

This derived class knowledge characteristic is not true for nonpointer or nonreference objects. You can cast or assign a Derived to a Base because a Derived is a Base. However, the object loses any knowledge of the Derived class at that point.

\begin{cpp}
Derived myDerived;
Base assignedObject { myDerived }; // Assigns a Derived to a Base.
assignedObject.someFunction(); // Calls Base's version of someFunction()
\end{cpp}

One way to remember this seemingly strange behavior is to imagine what the objects look like in memory. Picture a Base object as a box taking up a certain amount of memory. A Derived object is a box that is slightly bigger because it has everything a Base has plus a bit more. Whether you have a Derived or Base reference or pointer to a Derived, the box doesn’t change—you just have a new way of accessing it. However, when you cast a Derived into a Base, you are throwing out all the “uniqueness” of the Derived class to fit it into a smaller box.

\begin{myNotic}{NOTE}
Derived classes retain all their data members and member functions when referred to by base class pointers or references. They lose their uniqueness when cast to a base class object. The loss of the derived class’s data members and member functions is called slicing.
\end{myNotic}

\mySamllsection{The override Keyword}

The use of the override keyword is optional, but highly recommended. Without the keyword, it is possible to accidentally create a new (virtual) member function in a derived class instead of overriding a member function from the base class, effectively hiding the member function from the base class. Take the following Base and Derived classes where Derived is properly overriding someFunction(), but is not using the override keyword:

\begin{cpp}
class Base
{
    public:
    virtual void someFunction(double d);
};

class Derived : public Base
{
    public:
    virtual void someFunction(double d);
};
\end{cpp}

You can call someFunction() through a reference as follows:

\begin{cpp}
Derived myDerived;
Base& ref { myDerived };
ref.someFunction(1.1); // Calls Derived's version of someFunction()
\end{cpp}

This correctly calls the overridden someFunction() from the Derived class. Now, suppose you accidentally use an integer parameter instead of a double while overriding someFunction(), as follows:

\begin{cpp}
class Derived : public Base
{
    public:
        virtual void someFunction(int i);
};
\end{cpp}

This code does not override someFunction() from Base, but instead creates a new virtual member function. If you try to call someFunction() through a Base reference as in the following code, someFunction() of Base is called instead of the one from Derived!

\begin{cpp}
Derived myDerived;
Base& ref { myDerived };
ref.someFunction(1.1); // Calls Base's version of someFunction()
\end{cpp}

This type of problem can happen when you start to modify the Base class but forget to update all derived classes. For example, maybe your first version of the Base class has a member function called someFunction() accepting an integer. You then write the Derived class overriding this someFunction() accepting an integer. Later you decide that someFunction() in Base needs a double instead of an integer, so you update someFunction() in the Base class. It could happen that at that time, you forget to update overrides of someFunction() in derived classes to also accept a double instead of an integer. By forgetting this, you are now actually creating a new virtual member function instead of properly overriding the base member function.

You can prevent this situation by using the override keyword as follows:

\begin{cpp}
class Derived : public Base
{
    public:
        void someFunction(int i) override;
};
\end{cpp}

This definition of Derived generates a compilation error, because with the override keyword you are saying that someFunction() is supposed to be overriding a member function from a base class, but the Base class has no someFunction() accepting an integer, only one accepting a double.

The problem of accidentally creating a new member function instead of properly overriding one can also happen when you rename a member function in the base class and forget to rename the overriding member functions in derived classes.

\begin{myWarning}{WARNING}
Always use the override keyword on member functions that are meant to be overriding member functions from a base class.
\end{myWarning}

\mySamllsection{The Truth about virtual}

By now you know that if a member function is not virtual, trying to override it in a derived class will hide the base class’s version of that member function. This section explores how virtual member functions are implemented by the compiler and what their performance impact is, as well as discussing the importance of virtual destructors.

\mySamllsection{How virtual Is Implemented}

To understand how member function hiding is avoided, you need to know a bit more about what the virtual keyword actually does. When a class is compiled in C++, a binary object is created that contains all member functions for the class. In the non-virtual case, the code to transfer control to the appropriate member function is hard-coded directly where the member function is called based on the compile-time type. This is called static binding, also known as early binding.

If the member function is declared virtual, the correct implementation is called through the use of a special area of memory called the vtable, or “virtual table.” Each class that has one or more virtual member functions has a vtable, and every object of such a class contains a pointer to said vtable. This vtable contains pointers to the implementations of the virtual member functions. In this way, when a member function is called on a pointer or reference to an object, its vtable pointer is followed, and the appropriate version of the member function is executed based on the actual type of the object at run time. This is called dynamic binding, also known as late binding. It’s important to remember that this dynamic binding works only when using pointers or references to objects. If you call a virtual member function directly on an object, then that call will use static binding resolved at compile time.

To better understand how vtables make overriding of member functions possible, take the following Base and Derived classes as an example:

\begin{cpp}
class Base
{
    public:
        virtual void func1();
        virtual void func2();
        void nonVirtualFunc();
};

class Derived : public Base
{
    public:
        void func2() override;
        void nonVirtualFunc();
};
\end{cpp}

For this example, assume that you have the following two instances:

\begin{cpp}
Base myBase;
Derived myDerived;
\end{cpp}

Figure 10.5 shows a high-level view of the vtables of both instances. The myBase object contains a pointer to its vtable. This vtable has two entries, one for func1() and one for func2(). Those entries point to the implementations of Base::func1() and Base::func2().

\myGraphic{0.7}{content/part3/chapter10/images/5.png}{图 10.5}

myDerived also contains a pointer to its vtable, which also has two entries, one for func1() and one for func2(). Its func1() entry points to Base::func1() because Derived does not override func1(). On the other hand, its func2() entry points to Derived::func2().

Note that both vtables do not contain any entry for the nonVirtualFunc() member function because that member function is not virtual.

\mySamllsection{The Justification for virtual}

In some languages, such as Java, all member functions are automatically virtual so they can be overridden properly. In C++ that’s not the case. The argument against making everything virtual in C++, and the reason that the keyword was created in the first place, has to do with the overhead of the vtable. To call a virtual member function, the program needs to perform an extra operation by dereferencing the pointer to the appropriate code to execute. This is a miniscule performance hit in most cases, but the designers of C++ thought that it was better, at least at the time, to let the programmer decide if the performance hit was necessary. If the member function was never going to be overridden, there was no need to make it virtual and take the performance hit. However, with today’s CPUs, the performance hit is measured in fractions of a nanosecond, and this will keep getting smaller with future CPUs. In most applications, you will not have a measurable performance difference between using virtual member functions and avoiding them.

Still, in certain specific use cases, the performance overhead might be too costly, and you may need to have an option to avoid the hit. For example, suppose you have a Point class that has a virtual member function. If you have another data structure that stores millions or even billions of Points, calling a virtual member function on each point creates significant overhead. In that case, it’s probably wise to avoid any virtual member functions in your Point class.

There is also a tiny hit to memory usage for each object. In addition to the implementation of the member function, each object also needs a pointer for its vtable, which takes up a tiny amount of space. This is not an issue in the majority of cases. However, sometimes it does matter. Take again the Point class and the container storing billions of Points. In that case, the additional required memory becomes significant.

\mySamllsection{The Need for virtual Destructors}

Destructors should almost always be virtual. Making your destructors non-virtual can easily result in situations in which memory is not freed by object destruction. Only for a class that is marked as final could you make its destructor non-virtual.

For example, if a derived class uses memory that is dynamically allocated in the constructor and deleted in the destructor, it will never be freed if the destructor is never called. Similarly, if your derived class has members that are automatically deleted when an instance of the class is destroyed, such as std::unique\_ptrs, then those members will not get deleted either if the destructor is never called.

As the following code shows, it is easy to “trick” the compiler into skipping the call to the destructor if it is non-virtual:

\begin{cpp}
class Base
{
    public:
        Base() = default;
        ~Base() {}
};

class Derived : public Base
{
    public:
        Derived()
        {
            m_string = new char[30];
            println("m_string allocated");
        }

        ~Derived()
        {
            delete[] m_string;
            println("m_string deallocated");
        }
    private:
        char* m_string;
};

int main()
{
    Base* ptr { new Derived {} }; // m_string is allocated here.
    delete ptr; // ~Base is called, but not ˜Derived because the destructor
                // is not virtual!
}
\end{cpp}

As you can see from the following output, the destructor of the Derived object is never called, that is, the “m\_string deallocated” message is never displayed:

\begin{cpp}
m_string allocated
\end{cpp}

Technically, the behavior of the delete call in the preceding code is undefined by the standard. A C++ compiler could do whatever it wants in such undefined situations. However, most compilers simply call the destructor of the base class, and not the destructor of the derived class.

The fix is to mark the destructor in the base class as virtual. If you don’t need to do any extra work in that destructor but want to make it virtual, you can explicitly default it. Here’s an example:

\begin{cpp}
class Base
{
    public:
        Base() = default;
        virtual ~Base() = default;
};
\end{cpp}

With this change, the output is as expected:

\begin{shell}
m_string allocated
m_string deallocated
\end{shell}

Note that since C++11, the generation of a copy constructor and copy assignment operator is deprecated if the class has a user-declared destructor. Basically, once you have a user-declared destructor, the rule of five kicks in. This means you need to declare a copy constructor, copy assignment operator, move constructor, and move assignment operator, possibly by explicitly defaulting them. This is not done in the examples in this chapter in the interest of keeping them concise and to the point.

\begin{myWarning}{WARNING}
Unless you have a specific reason not to, or the class is marked as final, destructors should be marked as virtual. Constructors cannot and need not be virtual because you always specify the exact class being constructed when creating an object.
\end{myWarning}

Earlier in this chapter it was advised to use the override keyword on member functions that are meant to override base class member functions. It’s also possible to use the override keyword on a destructor. This makes sure that the compiler will trigger an error if the destructor in the base class is not virtual. You can combine virtual, override, and default. Here’s an example:

\begin{cpp}
class Derived : public Base
{
    public:
        virtual ~Derived() override = default;
};
\end{cpp}

\mySamllsection{Preventing Overriding}

Besides marking an entire class as final, C++ also allows you to mark individual member functions as final. Such member functions cannot be overridden in a further derived class. For example, overriding someFunction() from the following Derived class in DerivedDerived results in a compilation error:

\begin{cpp}
class Base
{
    public:
        virtual ~Base() = default;
        virtual void someFunction();
};
class Derived : public Base
{
    public:
        void someFunction() override final;
};
class DerivedDerived : public Derived
{
    public:
        void someFunction() override; // Compilation error.
};
\end{cpp}







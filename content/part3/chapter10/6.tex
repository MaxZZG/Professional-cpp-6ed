
扩展一个类会引发各种问题。可以改变类的哪些特性？不能改变哪些特性？什么是非公有继承？什么是虚基类？这些问题将在这里得到解答。

\mySubsubsection{10.6.1.}{改变覆写成员函数的返回类型}

通常，覆写一个成员函数的原因是改变其实现。然而，有时可能想改变成员函数的其他特性，比如返回类型。

经验法则是使用与基类中，使用的完全相同的成员函数声明或成员函数原型来覆写成员函数。实现可以改变，但原型保持不变。

然而，这并非必须。在C++中，一个覆写的成员函数可以改变其返回类型，只要基类成员函数的返回类型是指向类的指针或引用，而在派生类中，返回类型是指向派生类的指针或引用，即更具体的类。这样的类型称为协变返回类型。当基类和派生类在并行层次结构中处理对象时，这种特性有时非常有用——即另一组与第一个类层次结构相关但稍显次要的类。

例如，一个基本的汽车模拟器。可能有两个类层次结构来模拟不同但明显相关的真实对象。第一个是Car层次结构，基类Car有派生类GasolineCar和ElectricalCar。同样，还有一个类层次结构，基类称为PowerSource，派生类有GasolinePowerSource和ElectricalPowerSource。图10.11显示了这两个类层次结构。

\myGraphic{0.8}{content/part3/chapter10/images/11.png}{图 10.11}

假设电源可以打印自己的类型，而汽油电源有一个成员函数fillTank()，而电力电源有一个成员函数chargeBatteries():

\begin{cpp}
class PowerSource
{
    public:
        virtual void printType() = 0;
};

class GasolinePowerSource : public PowerSource
{
    public:
        void printType() override { println("GasolinePowerSource"); }
        virtual void fillTank() { println("Gasoline tank filled up."); }
};

class ElectricalPowerSource : public PowerSource
{
    public:
        void printType() override { println("ElectricalPowerSource"); }
        virtual void chargeBatteries() { println("Batteries charged."); }
};
\end{cpp}

Car有一个名为getFilledUpPowerSource()的虚成员函数，该函数返回特定汽车的“加满”电源的引用：

\begin{cpp}
class Car
{
    public:
        virtual PowerSource& getFilledUpPowerSource() = 0;
};
\end{cpp}

这是一个纯虚、抽象的成员函数，只有在具体的派生类中提供实现才有意义。由于GasolinePowerSource是PowerSource，所以GasolineCar类可以按以下方式实现这个成员函数：

\begin{cpp}
class GasolineCar : public Car
{
    public:
        PowerSource& getFilledUpPowerSource() override
        {
            m_engine.fillTank();
            return m_engine;
        }
    private:
        GasolinePowerSource m_engine;
};
\end{cpp}

ElectricalCar可以按以下方式实现：

\begin{cpp}
class ElectricalCar : public Car
{
    public:
        PowerSource& getFilledUpPowerSource() override
        {
            m_engine.chargeBatteries();
            return m_engine;
        }
    private:
        ElectricalPowerSource m_engine;
};
\end{cpp}

这些类可以按以下方式进行测试：

\begin{cpp}
GasolineCar gc;
gc.getFilledUpPowerSource().printType();
println("");
ElectricalCar ev;
ev.getFilledUpPowerSource().printType();
\end{cpp}

输出如下：

\begin{shell}
Gasoline tank filled up.
GasolinePowerSource

Batteries charged.
ElectricalPowerSource
\end{shell}

这种实现是可行的，但我们知道GasolineCar的getFilledUpPowerSource()成员函数总是返回GasolinePowerSource，而ElectricalCar总是返回ElectricalPowerSource，可以通过改变返回类型来向使用这些类的用户表明这一点：

\begin{cpp}
class GasolineCar : public Car
{
    public:
    GasolinePowerSource& getFilledUpPowerSource() override
    { /* omitted for brevity */ }
};

class ElectricalCar : public Car
{
    public:
    ElectricalPowerSource& getFilledUpPowerSource() override
    { /* omitted for brevity */ }
};
\end{cpp}

确定是否可以更改重写的成员函数的返回类型的一个好方法是考虑现有代码是否仍然有效，这称为Liskov替换原则（LSP）。在前面的例子中，因为假设getFilledUpPowerSource()成员函数总是返回PowerSource的代码仍然可以编译并正确工作，所以可以更改返回类型。因为ElectricalPowerSource和GasolinePowerSource都是PowerSources，所以可以对getFilledUpPowerSource()返回的PowerSource调用的成员函数，同样可以对getFilledUpPowerSource()返回的ElectricalPowerSource或GasolinePowerSource调用相应的成员函数。

例如，不能将返回类型更改为完全无关的类型，如int\&。以下代码无法编译：

\begin{cpp}
class ElectricalCar : public Car
{
    public:
        int& getFilledUpPowerSource() override // Error!
        { /* omitted for brevity */ }
};
\end{cpp}

这会产生一个编译错误:

\begin{shell}
'ElectricalCar::getFilledUpPowerSource': overriding virtual function return type
differs and is not covariant from 'Car::getFilledUpPowerSource'
\end{shell}

这个例子使用了PowerSource的引用，而不是智能指针。使用，例如shared\_ptr作为返回类型时，更改返回类型不起作用。假设Car::getFilledUpPowerSource()返回shared\_ptr<PowerSource>。因为shared\_ptr是一个类模板，所以不能将ElectricalCar::getFilledUpPowerSource()的返回类型改为shared\_ptr。需要创建了两个shared\_ptr类模板的实例，shared\_ptr<PowerSource>和shared\_ptr<ElectricalPowerSource>。这两个实例化是完全不同的类型，并且彼此没有任何关系。不能将覆写成员函数的返回类型，更改为完全不同的类型。

\mySubsubsection{10.6.2.}{向派生类添加基类虚成员函数的重载}

可以在派生类中添加基类虚成员函数的新重载，可以在派生类中添加一个虚成员函数的新重载，具有新的原型，但继续继承基类的版本。可以使用using声明，明确地在派生类中包含基类成员函数的定义。以下是一个例子：

\begin{cpp}
class Base
{
    public:
        virtual void someFunction();
};

class Derived : public Base
{
    public:
        using Base::someFunction; // Explicitly inherits the Base version.
        virtual void someFunction(int i); // Adds a new overload of someFunction().
        virtual void someOtherFunction();
};
\end{cpp}

\begin{myNotic}{NOTE}
在派生类中找到与基类中成员函数同名，但参数列表不同的成员函数的情况很罕见。
\end{myNotic}

\mySubsubsection{10.6.3.}{继承的构造函数}

前一节中，看到了使用using声明来明确包含基类中成员函数定义的示例。这适用于普通类成员函数，也适用于构造函数，允许从基类继承构造函数。看看Base和Derived类的定义：

\begin{cpp}
class Base
{
    public:
        virtual ~Base() = default;
        Base() = default;
        explicit Base(int i) {}
};

class Derived : public Base
{
    public:
        explicit Derived(int i) : Base(i) {}
};
\end{cpp}

Derived构造函数所做的唯一事情是，将其参数传递给Base构造函数。

只能使用Base提供的构造函数来构造Base对象，要么是默认构造函数，要么是接受一个int的构造函数。另一方面，构造Derived对象只能通过提供的Derived构造函数，需要一个整数作为参数。不能使用Base类的默认构造函数来构造Derived对象：

\begin{cpp}
Base base { 1 }; // OK, calls integer Base ctor.
Derived derived1 { 2 }; // OK, calls integer Derived ctor.
Derived derived2; // Error, Derived does not have a default ctor.
\end{cpp}

由于Derived构造函数只是将其参数传递给Base构造函数，并没有做其他事情，所以可以在Derived类中通过using声明显式继承Base构造函数：

\begin{cpp}
class Derived : public Base
{
    public:
        using Base::Base;
};
\end{cpp}

using声明继承了Base的所有构造函数，所以可以这样构造Derived对象：

\begin{cpp}
Derived derived1 { 2 }; // OK, calls inherited integer Base ctor.
Derived derived2; // OK, calls inherited default Base ctor.
\end{cpp}

派生类中的继承构造函数，具有与基类构造函数相同的访问说明符（public、protected或private）。在基类中显式删除的继承构造函数，也会在派生类中删除。

\mySamllsection{隐藏继承的构造函数}

派生类可以定义一个参数列表与基类中继承的构造函数相同。这种情况下，派生类的构造函数优先于继承的构造函数。以下示例中，Derived类继承了Base类的所有构造函数，使用using声明。然而，由于Derived类定义了自己的一个单参数类型为float的构造函数，隐藏了Base类中参数类型为float的继承构造函数。

\begin{cpp}
class Base
{
    public:
        virtual ~Base() = default;
        Base() = default;
        explicit Base(std::string_view str) {}
        explicit Base(float f) {}
};

class Derived : public Base
{
    public:
        using Base::Base;
        explicit Derived(float f) {} // Hides inherited float Base ctor.
};
\end{cpp}

有了这个定义，可以创建Derived对象：

\begin{cpp}
Derived derived1 { "Hello" }; // OK, calls inherited string_view Base ctor.
Derived derived2 { 1.23f }; // OK, calls float Derived ctor.
Derived derived3; // OK, calls inherited default Base ctor.
\end{cpp}

使用using声明从基类继承构造函数时，有一些限制。

\begin{itemize}
\item
当从基类继承一个构造函数时，就继承了所有构造函数。不可能只继承基类构造函数的一个子集。

\item
当继承构造函数时，其与基类中访问权限相同(直接继承)，不受using声明下的访问权限的限制。
\end{itemize}

\mySamllsection{继承构造函数和多重继承}

继承构造函数的另一个限制与多重继承有关。如果另一个基类有一个与第一个基类参数列表相同的构造函数，那么不可能从第一个基类继承构造函数，这会导致歧义。为了解决这个问题，派生类需要显式定义冲突的构造函数。例如，以下Derived类尝试从Base1和Base2继承所有构造函数，这导致了浮点数构造函数的歧义。

\begin{cpp}
class Base1
{
    public:
        virtual ~Base1() = default;
        Base1() = default;
        explicit Base1(float f) {}
};

class Base2
{
    public:
        virtual ~Base2() = default;
        Base2() = default;
        explicit Base2(std::string_view str) {}
        explicit Base2(float f) {}
};

class Derived : public Base1, public Base2
{
    public:
        using Base1::Base1;
        using Base2::Base2;
        explicit Derived(char c) {}
};

int main()
{
    Derived d { 1.2f }; // Error, ambiguity.
}
\end{cpp}

Derived中的第一个using声明继承了Base1的所有构造函数，所以Derived有以下构造函数：

\begin{cpp}
Derived(float f); // Inherited from Base1.
\end{cpp}

Derived中的第二个using声明尝试从Base2继承所有构造函数，所以Derived得到了第二个Derived(float)构造函数。问题通过在Derived类中显式声明冲突的构造函数来解决，如下所示：

\begin{cpp}
class Derived : public Base1, public Base2
{
    public:
        using Base1::Base1;
        using Base2::Base2;
        explicit Derived(char c) {}
        explicit Derived(float f) {}
};
\end{cpp}

Derived类现在显式声明了一个单参数类型为float的构造函数，解决了歧义。Derived类中也接受浮点数参数的显式构造函数仍然可以在初始化器中转发调用Base1和Base2的构造函数，如下所示：

\begin{cpp}
Derived::Derived(float f) : Base1 { f }, Base2 { f } {}
\end{cpp}

\mySamllsection{数据成员的初始化}

使用继承的构造函数时，请确保所有数据成员都正确初始化。例如，以下Base和Derived的新定义。这些定义在所有情况下，都没有正确初始化m\_int数据成员。

\begin{cpp}
class Base
{
    public:
        virtual ~Base() = default;
        explicit Base(std::string_view str) : m_str { str } {}
    private:
        std::string m_str;
};

class Derived : public Base
{
    public:
        using Base::Base;
        explicit Derived(int i) : Base { "" }, m_int { i } {}
    private:
        int m_int;
};
\end{cpp}

可以像这样创建一个Derived对象：

\begin{cpp}
Derived s1 { 2 };
\end{cpp}

这调用了Derived(int)构造函数，初始化Derived类的m\_int数据成员，并用空字符串调用Base构造函数初始化了Base类的m\_str数据成员。

因为Base构造函数在Derived类中继承，也可以像这样构造一个Derived对象：

\begin{cpp}
Derived s2 { "Hello World" };
\end{cpp}

这调用Derived类中的继承Base构造函数，这个继承的Base构造函数只初始化Base类的m\_str，并没有初始化Derived类的m\_int，使其处于未初始化状态。这种情况下，解决方案是在类中使用成员初始化器，这在第8章中介绍过。

以下代码使用类内成员初始化器将m\_int初始化为0。当然，Derived(int)构造函数仍然可以改变这个值，并初始化m\_int为构造参数i。

\begin{cpp}
class Derived : public Base
{
    public:
        using Base::Base;
        explicit Derived(int i) : Base { "" }, m_int { i } {}
    private:
        int m_int { 0 };
};
\end{cpp}

\mySubsubsection{10.6.4.}{重写成员函数的特殊情况}

重写一个成员函数时，有几个特殊情况需要注意。本节概述了可能遇到的情况。

\mySamllsection{静态基类成员函数}

在C++中，不能重写一个静态成员函数。大部分情况下，这就是需要知道的全部。

首先，一个成员函数不能同时是静态和虚的。如果在派生类中有与基类中静态成员函数同名,且具有相同参数列表的静态成员函数，这样其实是两个独立的成员函数。

以下代码展示了两个类都有名为beStatic()的静态成员函数。这两个成员函数没有任何关系。

\begin{cpp}
class BaseStatic
{
    public:
    static void beStatic() { println("BaseStatic being static."); }
};

class DerivedStatic : public BaseStatic
{
    public:
    static void beStatic() { println("DerivedStatic keepin' it static."); }
};
\end{cpp}

因为静态成员函数属于其类，所以使用这两个不同类名调用同名的成员函数会调用各自的成员函数。

\begin{cpp}
BaseStatic::beStatic();
DerivedStatic::beStatic();
\end{cpp}

输出的结果是：

\begin{shell}
BaseStatic being static.
DerivedStatic keepin' it static.
\end{shell}

只要通过类名访问成员函数，一切都非常合理。当涉及到对象时，行为就不那么清晰了。在C++中，可以使用对象调用静态成员函数，但由于成员函数是静态的，没有this指针，也没有访问对象本身，所以等价于通过其类名调用。参考前面的示例类，可以写如下代码，但结果可能令人惊讶。

\begin{cpp}
DerivedStatic myDerivedStatic;
BaseStatic& ref { myDerivedStatic };
myDerivedStatic.beStatic();
ref.beStatic();
\end{cpp}

第一次调用beStatic()显然是DerivedStatic的版本，因为明确地在声明为DerivedStatic的对象上调用。第二次调用可能不会按预期的工作。对象是一个BaseStatic引用，但它引用一个DerivedStatic对象，调用的是BaseStatic的beStatic()版本。原因是C++在调用静态成员函数时不关心对象实际上是什么，只关心编译时的类型。这种情况下，类型是一个对BaseStatic的引用。

前面的示例输出的结果：

\begin{shell}
DerivedStatic keepin' it static.
BaseStatic being static.
\end{shell}

\begin{myNotic}{NOTE}
静态成员函数按定义它们的类名进行作用域限定，但不适用于特定对象的成员函数。当调用静态成员函数时，由正常的名称解析可以确定相应的函数版本。当成员函数通过对象调用时，对象实际上并不参与调用，除了在编译时确定类型。
\end{myNotic}

\mySamllsection{重载基类成员函数}

当通过指定名称和一组参数来覆写一个成员函数时，编译器隐式隐藏了基类中具有相同名称的其他实例。如果已经用给定名称覆写了一个成员函数，就可能有意覆写所有具有该名称的成员函数，但这应该视为是一个错误。考虑一下——为什么要改变一个成员函数的部分重载版本呢？考虑以下Derived类，它覆写了一个成员函数，但而没有覆盖其相关联的重载：

\begin{cpp}
class Base
{
    public:
        virtual ~Base() = default;
        virtual void overload() { println("Base's overload()"); }
        virtual void overload(int i) { println("Base's overload(int i)"); }
};

class Derived : public Base
{
    public:
        void overload() override { println("Derived's overload()"); }
};
\end{cpp}

如果尝试在Derived对象上调用接受int参数的overload()，代码将无法编译，因为它没有被显式覆写。

\begin{cpp}
Derived myDerived;
myDerived.overload(2); // Error! No matching member function for overload(int).
\end{cpp}

然而，可以从Derived对象访问这个成员函数，只需要一个指向Base对象的指针或引用。

\begin{cpp}
Derived myDerived;
Base& ref { myDerived };
ref.overload(7);
\end{cpp}

C++中隐藏未实现的重载成员函数只是表面现象。明确声明为派生类实例的对象不会使这些成员函数可用，但简单的类型转换到基类就可以使它们可用。

当只想改变其中一个时，使用using声明可以节省覆写所有重载的麻烦。在以下代码中，Derived类定义使用Base的一个overload()，并显式覆写了另一个：

\begin{cpp}
class Derived : public Base
{
    public:
        using Base::overload;
        void overload() override { println("Derived's overload()"); }
};
\end{cpp}

using声明存在一些风险。假设Base中添加了第三个overload()成员函数，应该在Derived中覆写。因为有using声明，这些现在不会检测为错误，Derived类的开发者已经明确表示，“我愿意接受父类中这个成员函数的所有重载。”

\begin{myNotic}{NOTE}
为了在覆写基类成员函数时避免难以发现的错误，最好也覆写该成员函数的所有重载。
\end{myNotic}

\mySamllsection{The Base Class Member Function Is private}

There’s absolutely nothing wrong with overriding a private member function. Remember that the access specifier for a member function determines who is able to call the member function. Just because a derived class can’t call its parent’s private member functions doesn’t mean it can’t override them. In fact, the template member function pattern is a common pattern in C++ that is implemented by overriding private member functions. It allows derived classes to define their own “uniqueness” that is referenced in the base class. Note that, for example, Java and C\# only allow overriding public and protected member functions, not private member functions.

For example, the following class is part of a car simulator that estimates the number of miles the car can travel based on its gas mileage and the amount of fuel left. The getMilesLeft() member function is the template member function. Usually, template member functions are not virtual. They typically define some algorithmic skeleton in a base class, calling virtual member functions to query for information. A derived class can then override these virtual member functions to change aspects of the algorithm without having to modify the algorithm in the base class itself.

\begin{cpp}
export class MilesEstimator
{
    public:
        virtual ~MilesEstimator() = default;
        int getMilesLeft() const { return getMilesPerGallon() * getGallonsLeft(); }
        virtual void setGallonsLeft(int gallons) { m_gallonsLeft = gallons; }
        virtual int getGallonsLeft() const { return m_gallonsLeft; }
    private:
        int m_gallonsLeft { 0 };
        virtual int getMilesPerGallon() const { return 20; }
};
\end{cpp}

The getMilesLeft() member function performs a calculation based on the results of two of its own member functions: getGallonsLeft() which is public, and getMilesPerGallon() which is private. The following code uses the MilesEstimator to calculate how many miles can be traveled with two gallons of gas:

\begin{cpp}
MilesEstimator myMilesEstimator;
myMilesEstimator.setGallonsLeft(2);
println("Normal estimator can go {} more miles.",
    myMilesEstimator.getMilesLeft());
\end{cpp}

The output of this code is as follows:

\begin{shell}
Normal estimator can go 40 more miles.
\end{shell}

To make the simulator more interesting, you may want to introduce different types of vehicles, perhaps a more efficient car. The existing MilesEstimator assumes that all cars get 20 miles per gallon, but this value is returned from a separate member function specifically so that a derived class can override it. Such a derived class is shown here:

\begin{cpp}
export class EfficientCarMilesEstimator : public MilesEstimator
{
    private:
        int getMilesPerGallon() const override { return 35; }
};
\end{cpp}

By overriding this one private member function, the new class completely changes the behavior of existing, unmodified, public member functions in the base class. The getMilesLeft() member function in the base class automatically calls the overridden version of the private getMilesPerGallon() member function. An example using the new class is shown here:

\begin{cpp}
EfficientCarMilesEstimator myEstimator;
myEstimator.setGallonsLeft(2);
println("Efficient estimator can go {} more miles.",
        myEstimator.getMilesLeft());
\end{cpp}

This time, the output reflects the overridden functionality:

\begin{shell}
Efficient estimator can go 70 more miles.
\end{shell}

\begin{myNotic}{NOTE}
Overriding private and protected member functions is a good way to change certain features of a class without a major overhaul.
\end{myNotic}


\mySamllsection{The Base Class Member Function Has Default Arguments}

An overridden member function in a derived class can have different default arguments than in the base class. The arguments that are used depend on the declared type of the variable, not the underlying object. The following is a simple example of a derived class that provides a different default argument in an overridden member function:

\begin{cpp}
class Base
{
    public:
        virtual ~Base() = default;
        virtual void go(int i = 2) { println("Base's go with i={}", i); }
};

class Derived : public Base
{
    public:
        void go(int i = 7) override { println("Derived's go with i={}", i); }
};
\end{cpp}

If go() is called on a Derived object, Derived’s version of go() is executed with the default argument of 7. If go() is called on a Base object, Base’s version of go() is called with the default argument of 2. However (and this is the weird part), if go() is called on a Base pointer or Base reference that really points to a Derived object, Derived’s version of go() is called but with Base’s default argument of 2. This behavior is shown in the following example:

\begin{cpp}
Base myBase;
Derived myDerived;
Base& myBaseReferenceToDerived { myDerived };
myBase.go();
myDerived.go();
myBaseReferenceToDerived.go();
\end{cpp}

The output of this code is as follows:

\begin{shell}
Base's go with i=2
Derived's go with i=7
Derived's go with i=2
\end{shell}

The reason for this behavior is that C++ uses the compile-time type of the expression to bind default arguments, not the run-time type. Default arguments are not “inherited” in C++. If the Derived class in this example failed to provide a default argument for go() as its parent did, it would not be possible to call go() on a Derived object without passing an argument to it.

\begin{myNotic}{NOTE}
When overriding a member function that has a default argument, you should provide a default argument as well, and it should probably be the same value. It is recommended to use a named constant for default values so that the same named constant can be used in derived classes.
\end{myNotic}

\mySamllsection{The Base Class Member Function Has a Different Access Specification}

There are two ways you may want to change the access specification of a member function: you could try to make it more restrictive or less restrictive. Neither case makes much sense in C++, but there are a few legitimate reasons for attempting to do so.

To enforce tighter restrictions on a member function (or on a data member for that matter), there are two approaches you can take. One way is to change the access specifier for the entire base class. This approach is described later in this chapter. The other approach is simply to redefine the access in the derived class, as illustrated in the Shy class that follows:

\begin{cpp}
class Gregarious
{
    public:
        virtual void talk() { println("Gregarious says hi!"); }
};

class Shy : public Gregarious
{
    protected:
        void talk() override { println("Shy reluctantly says hello."); }
};
\end{cpp}

The protected version of talk() in Shy properly overrides the Gregarious::talk() member function. Any client code that attempts to call talk() on a Shy object gets a compilation error:

\begin{cpp}
Shy myShy;
myShy.talk(); // Error! Attempt to access protected member function.
\end{cpp}

However, the member function is not fully protected. One only has to obtain a Gregarious reference or pointer to access the member function that you thought was protected:

\begin{cpp}
Shy myShy;
Gregarious& ref { myShy };
ref.talk();
\end{cpp}

The output of this code is as follows:

\begin{shell}
Shy reluctantly says hello.
\end{shell}

This proves that making the member function protected in the derived class did override the member function (because the derived class version is correctly called), but it also proves that the protected access can’t be fully enforced if the base class makes it public.

\begin{myNotic}{NOTE}
There is no reasonable way (or good reason) to restrict access to a public base class member function.
\end{myNotic}

\begin{myNotic}{NOTE}
The previous example redefined the member function in the derived class because it wants to display a different message. If you don’t want to change the implementation but instead only want to change the access specification of a member function, the preferred way is to simply add a using declaration in the derived class definition with the desired access specification.
\end{myNotic}

It is much easier (and makes more sense) to lessen access restrictions in derived classes. The simplest way is to provide a public member function in the derived class that calls a protected member function from the base class, as shown here:

\begin{cpp}
class Secret
{
    protected:
        virtual void dontTell() { println("I'll never tell."); }
};

class Blabber : public Secret
{
    public:
        virtual void tell() { dontTell(); }
};
\end{cpp}

A client calling the public tell() member function of a Blabber object effectively accesses the protected member function of the Secret class. Of course, this doesn’t really change the access specification of dontTell(); it just provides a public way of accessing it.

You can also override dontTell() explicitly in Blabber and give it new behavior with public access. This makes a lot more sense than reducing the access specification because it is entirely clear what happens with a reference or pointer to the base class. For example, suppose that Blabber actually makes the dontTell() member function public:

\begin{cpp}
class Blabber : public Secret
{
    public:
        void dontTell() override { println("I'll tell all!"); }
};
\end{cpp}

Now you can call dontTell() on a Blabber object:

\begin{cpp}
myBlabber.dontTell(); // Outputs "I'll tell all!"
\end{cpp}

If you don’t want to change the implementation of the overridden member function but only change the access specification, then you can use a using declaration. Here’s an example:

\begin{cpp}
class Blabber : public Secret
{
    public:
        using Secret::dontTell;
};
\end{cpp}

This also allows you to call dontTell() on a Blabber object, but this time the output will be “I’ll never tell”:

\begin{cpp}
myBlabber.dontTell(); // Outputs "I'll never tell."
\end{cpp}

In both previous cases, however, the protected member function in the base class stays protected because any attempts to call Secret’s dontTell() member function through a Secret pointer or reference will not compile:

\begin{cpp}
Blabber myBlabber;
Secret& ref { myBlabber };
Secret* ptr { &myBlabber };
ref.dontTell(); // Error! Attempt to access protected member function.
ptr->dontTell(); // Error! Attempt to access protected member function.
\end{cpp}

\begin{myNotic}{NOTE}
The only useful way to change a member function’s access specification is by providing a less restrictive accessor to a protected member function.
\end{myNotic}

\mySubsubsection{10.6.5.}{Copy Constructors and Assignment Operators in Derived Classes}

Chapter 9 explains that providing a copy constructor and assignment operator is a must when you have dynamically allocated memory in a class. When defining a derived class, you need to be careful about copy constructors and operator=.

If your derived class does not have any special data (pointers, usually) that require a nondefault copy constructor or operator=, you don’t need to have one, regardless of whether the base class has one. If your derived class omits the copy constructor or operator=, a default copy constructor or operator= will be provided for the data members specified in the derived class, and the base class copy constructor or operator= will be used for the data members specified in the base class.

On the other hand, if you do specify a copy constructor in the derived class, you need to explicitly call the parent copy constructor, as shown in the following code. If you do not do this, the default constructor (not the copy constructor!) will be used for the parent portion of the object.

\begin{cpp}
class Base
{
    public:
        virtual ~Base() = default;
        Base() = default;
        Base(const Base& src) { }
};

class Derived : public Base
{
    public:
        Derived() = default;
        Derived(const Derived& src) : Base { src } { }
};
\end{cpp}

Similarly, if the derived class overrides operator=, it is almost always necessary to call the parent’s version of operator= as well. The only case where you wouldn’t do this would be if there was some bizarre reason why you only wanted part of the object assigned when an assignment took place. The following code shows how to call the parent’s assignment operator from the derived class:

\begin{cpp}
Derived& Derived::operator=(const Derived& rhs)
{
    if (&rhs == this) { return *this; }
    Base::operator=(rhs); // Calls parent's operator=.
    // Do necessary assignments for derived class.
    return *this;
}
\end{cpp}

\begin{myWarning}{WARNING}
If your derived class does not specify its own copy constructor or operator=, the base class functionality continues to work. However, if the derived class does provide its own copy constructor or operator=, it needs to explicitly call the base class versions.
\end{myWarning}


\begin{myNotic}{NOTE}
When you need copy functionality in an inheritance hierarchy, a common idiom employed by professional C++ developers is to implement a polymorphic clone() member function, because relying on the standard copy constructor and copy assignment operators is not sufficient. The polymorphic clone() idiom is discussed in Chapter 12, “Writing Generic Code with Templates.”
\end{myNotic}

\mySubsubsection{10.6.6.}{Run-Time Type Facilities}

Relative to other object-oriented languages, C++ is very compile-time oriented. As you learned earlier, overriding member functions works because of a level of indirection between a member function and its implementation, not because the object has built-in knowledge of its own class.

There are, however, features in C++ that provide a run-time view of an object. These features are commonly grouped together under a feature set called run-time type information (RTTI). RTTI provides a number of useful features for working with information about an object’s class membership. One such feature is dynamic\_cast(), which allows you to safely convert between types within an object-oriented hierarchy; this was discussed earlier in this chapter. Using dynamic\_cast() on a class without a vtable, that is, without any virtual member functions, causes a compilation error.

A second RTTI feature is the typeid operator, which lets you query for types at run time. The result of applying the operator is a reference to an std::type\_info object, defined in <typeinfo>. The type\_info class has a member function called name() returning the compiler-dependent name of the type. The typeid operator behaves as follows:

\begin{itemize}
\item
typeid(type): Results in a reference to a type\_info object representing the given type.

\item
typeid(expression)
\begin{itemize}
\item
If evaluating expression results in a polymorphic type, then expression is evaluated and the result of the typeid operator is a reference to a type\_info object representing the dynamic type of the evaluated expression.

\item
Otherwise, expression is not evaluated, and the result is a reference to a type\_info object representing the static type.
\end{itemize}
\end{itemize}

For the most part, you shouldn’t ever need to use typeid because any code that is conditionally executed based on the type of the object would be better handled with, for example, virtual member functions.

The following code uses typeid to print a message based on the type of the object:

\begin{cpp}
class Animal { public: virtual ~Animal() = default; };
class Dog : public Animal {};
class Bird : public Animal {};

void speak(const Animal& animal)
{
    if (typeid(animal) == typeid(Dog)) {
        println("Woof!");
    } else if (typeid(animal) == typeid(Bird)) {
        println("Chirp!");
    }
}
\end{cpp}

Whenever you see code like this, you should immediately consider reimplementing the functionality as a virtual member function. In this case, a better implementation would be to declare a virtual member function called speak() in the Animal base class. Dog would override the member function to print "Woof!", and Bird would override it to print "Chirp!". This approach better fits objectoriented programming, where functionality related to objects is given to those objects.

\begin{myWarning}{WARNING}
 The typeid operator works correctly only if the class has at least one virtual member function, that is, when the class has a vtable. Additionally, the typeid operator strips reference and const qualifiers from its argument.
\end{myWarning}

One possible use case of the typeid operator is for logging and debugging purposes. The following code makes use of typeid for logging. The logObject() function takes a “loggable” object as a parameter. The design is such that any object that can be logged inherits from the Loggable class and supports a member function called getLogMessage().

\begin{cpp}
class Loggable
{
    public:
        virtual ~Loggable() = default;
        virtual string getLogMessage() const = 0;
};

class Foo : public Loggable
{
    public:
        string getLogMessage() const override { return "Hello logger."; }
};

void logObject(const Loggable& loggableObject)
{
    print("{}: ", typeid(loggableObject).name());
    println("{}", loggableObject.getLogMessage());
}
\end{cpp}

logObject() first prints the name of the object’s class to the console, followed by its log message.
This way, when you read the log later, you can see which object was responsible for every written line. Here is the output generated by Microsoft Visual C++ 2022 when logObject() is called with an instance of Foo:

\begin{shell}
class Foo: Hello logger.
\end{shell}

As you can see, the name returned by the typeid operator is “class Foo”. However, this name depends on your compiler. For example, if you compile and run the same code with GCC, the output is as follows:

\begin{cpp}
3Foo: Hello logger.
\end{cpp}

\begin{myNotic}{NOTE}
If you are using typeid for purposes other than logging and debugging, consider changing your design, for example, by using virtual member functions.
\end{myNotic}

\mySubsubsection{10.6.7.}{Non-public Inheritance}

In all previous examples, parent classes were always listed using the public keyword. You may be wondering if a parent can be private or protected. In fact, it can, though neither is as common as public. If you don’t specify any access specifier for the parent, then it is private inheritance for a class, and public inheritance for a struct.

Declaring the relationship with the parent to be protected means that all public member functions and data members from the base class become protected in the context of the derived class. Similarly, specifying private inheritance means that all public and protected member functions and data members of the base class become private in the derived class.

There are a handful of reasons why you might want to uniformly degrade the access level of the parent in this way, but most reasons imply flaws in the design of the hierarchy. Some programmers abuse this language feature, often in combination with multiple inheritance, to implement “components” of a class. Instead of making an Airplane class that contains an engine data member and a fuselage data member, they make an Airplane class that is a protected engine and a protected fuselage. In this way, the Airplane doesn’t look like an engine or a fuselage to client code (because everything is protected), but it is able to use all of that functionality internally.

\begin{myNotic}{NOTE}
Non-public inheritance is rare, and I recommend using it cautiously, if for no other reason than that most programmers are not familiar with it.
\end{myNotic}

\mySubsubsection{10.6.8.}{Virtual Base Classes}

Earlier in this chapter, you learned about ambiguous base classes, a situation that arises when multiple parents each have a parent in common, as shown again in Figure 10.12. The solution recommended earlier was to make sure that the shared parent doesn’t have any functionality of its own. That way, its member functions can never be called, and there is no ambiguity problem.

\myGraphic{0.3}{content/part3/chapter10/images/12.png}{图 10.12}

C++ has another mechanism, called virtual base classes, for addressing this problem if you do want the shared parent to have its own functionality. If the shared parent is marked as a virtual base class, there will not be any ambiguity. The following code adds a sleep() member function, including an implementation, to the Animal base class, and modifies the Dog and Bird classes to inherit from Animal as a virtual base class. Without using a virtual base class, a call to sleep() on a DogBird object would be ambiguous and would generate a compiler error because DogBird would have two subobjects of class Animal, one coming from Dog and one coming from Bird. However, when Animal is inherited virtually, DogBird has only one subobject of class Animal, so there will be no ambiguity with calling sleep().

\begin{cpp}
class Animal
{
    public:
        virtual void eat() = 0;
        virtual void sleep() { println("zzzzz...."); }
};

class Dog : public virtual Animal
{
    public:
        virtual void bark() { println("Woof!"); }
        void eat() override { println("The dog ate."); }
};

class Bird : public virtual Animal
{
    public:
        virtual void chirp() { println("Chirp!"); }
        void eat() override { println("The bird ate."); }
};

class DogBird : public Dog, public Bird
{
    public:
        void eat() override { Dog::eat(); }
};

int main()
{
    DogBird myConfusedAnimal;
    myConfusedAnimal.sleep(); // Not ambiguous because of virtual base class.
}
\end{cpp}

Be careful with constructors in such class hierarchies. For example, the following code adds some data members to the different classes, adds constructors to initialize those data members, and, for reasons explained after the code snippet, adds a protected default constructor to Animal.

\begin{cpp}
class Animal
{
    public:
        explicit Animal(double weight) : m_weight { weight } {}
        virtual double getWeight() const { return m_weight; }
    protected:
        Animal() = default;
    private:
        double m_weight { 0.0 };
};
class Dog : public virtual Animal
{
    public:
        explicit Dog(double weight, string name)
            : Animal { weight }, m_name { move(name) } {}
    private:
        string m_name;
};
class Bird : public virtual Animal
{
    public:
        explicit Bird(double weight, bool canFly)
            : Animal { weight }, m_canFly { canFly } {}
    private:
        bool m_canFly { false };
};

class DogBird : public Dog, public Bird
{
    public:
        explicit DogBird(double weight, string name, bool canFly)
            : Dog { weight, move(name) }, Bird { weight, canFly } {}
};

int main()
{
    DogBird dogBird { 22.33, "Bella", true };
    println("Weight: {}", dogBird.getWeight());
}
\end{cpp}

When you run this code, the output is unexpected:

\begin{cpp}
Weight: 0
\end{cpp}

It seems that the given weight of 22.33 when constructing the DogBird in main() is lost. Why? This code is using a virtual Animal base class; hence, a DogBird instance has only one Animal subobject. The DogBird constructor calls the constructors of both Dog and Bird, which both forward to their Animal base class constructor. This would mean that Animal is constructed twice. This is not allowed. In such cases, the compiler disables the call to the Animal constructor in the Dog and Bird constructors when it’s being called from a derived class’s constructor and, instead, calls a default constructor of the Animal base class, thus the need for the protected default constructor in Animal. All this means that the most derived class itself is responsible for calling a constructor of the shared base class. A correct implementation is as follows:

\begin{cpp}
class Animal { /* Same as before. */ };

class Dog : public virtual Animal
{
    public:
        explicit Dog(double weight, string name)
            : Animal { weight }, m_name { move(name) } {}
    protected:
        explicit Dog(string name) : m_name { move(name) } {}
    private:
        string m_name;
};

class Bird : public virtual Animal
{
    public:
        explicit Bird(double weight, bool canFly)
            : Animal { weight }, m_canFly { canFly } {}
    protected:
        explicit Bird(bool canFly) : m_canFly { canFly } {}
    private:
        bool m_canFly { false };
};

class DogBird : public Dog, public Bird
{
    public:
        explicit DogBird(double weight, string name, bool canFly)
            : Animal { weight }, Dog { move(name) }, Bird { canFly } {}
};
\end{cpp}

In this implementation, protected single-argument constructors are added to Dog and Bird. They are protected as they should be used only by derived classes. Client code is allowed to construct Dogs and Birds only using the two-argument constructors.

After these changes, the output is correct:

\begin{shell}
Weight: 22.33
\end{shell}

\begin{myNotic}{NOTE}
Virtual base classes are a great way to avoid ambiguity in class hierarchies. The only drawback is that many C++ programmers are unfamiliar with the concept.
\end{myNotic}











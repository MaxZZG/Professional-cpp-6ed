通过解决下面的练习，可以练习本章讨论的内容。所有练习的解决方案都可以在本书的网站\url{www.wiley.com/go/proc++6e}下载到源码。若在练习中卡住了，可以考虑先重读本章的部分内容，试着自己找到答案，再在从网站上寻找解决方案。

\begin{itemize}
\item
\textbf{练习 12-1}: 编写一个名为 KeyValuePair 的类模板，有两个模板类型参数：Key 和 Value。该类应有两个privae数据成员来存储键和值。提供一个接受键和值的构造函数，并添加适当的 getters 和 setters。在 main() 函数中创建几个实例，尝试使用类模板参数推导。

\item
\textbf{练习 12-2}: 在练习 12-1 的 KeyValuePair 类模板中，支持所有类型的键和值模板类型参数。例如，以下示例将类模板实例化为 std::string 作为键和值的类型：

\begin{cpp}
KeyValuePair<std::string, std::string> kv { "John Doe", "New York" };
\end{cpp}

使用 const char* 作为模板类型参数会导致数据成员的类型为 const char*，这并不是我们想要的。

为 const char* 键和值编写一个类模板特化，将给定的字符串转换为 std::string。

\item
\textbf{练习 12-3}: 使用练习 12-1 的解决方案，并对其进行适当修改，只允许整数类型作为键的类型，只允许浮点类型作为值的类型。

\item
\textbf{练习 12-4}: 编写一个名为 concat() 的函数模板，有两个模板类型参数和两个函数参数 t1 和 t2。该函数首先将 t1 和 t2 转换为字符串，然后返回这两个字符串的拼接。在这个练习中，只关注 std::to\_string() 支持的类型。创建并使用一个适当的类模板概念，以确保函数模板的用户不会使用它来处理不支持的类型。尝试不使用模板关键字来编写函数模板。

\item
\textbf{练习 12-5}: concat() 函数模板仅适用于 std::to\_string() 支持的类型。在这个练习中，修改解决方案，使其也能处理字符串，以及任何组合。

\item
\textbf{练习 12-6}: 使用本章前面提到的原始 Find() 函数模板，并为类型 T 添加适当的约束。
\end{itemize}
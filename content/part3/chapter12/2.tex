
类模板定义了一组类定义的蓝图（即模板），其中一些变量的类型、成员函数的返回类型、或成员函数的参数类型，指定为模板类型参数。类模板类似于建筑蓝图，允许编译器通过用具体类型，替换模板类型参数来构建（也称为实例化）具体的类定义。

类模板主要用于存储对象的容器或数据结构，我们已经在本书的早些部分中多次使用过类模板，例如std::vector、unique\_ptr、string等。本节通过一个运行示例，即Grid容器，来讨论如何编写自己的类模板。为了保持示例的长度合理性，并且简单到足以说明具体点，章节的不同部分会为Grid容器添加不同的特性，但这些特性后续不会使用。

\mySubsubsection{12.2.1.}{编写类模板}

假设想创建一个通用的游戏板类，可以作为棋盘、跳棋板、井字棋板，或其他二维游戏板使用。为了使其通用，应该能够存储棋子、跳棋子、井字棋子，或其他类型游戏的棋子。

\mySamllsection{不使用模板}

不使用模板时，构建通用GameBoard的最佳方法是，利用多态性来存储通用的GamePiece对象。然后，可以让每种游戏的对象继承自GamePiece类。例如，棋类游戏中，ChessPiece派生于GamePiece类。通过多态性，编写来存储GamePieces的GameBoard，也可以存储ChessPieces。因为可能需要复制游戏板，所以GameBoard需要能够复制GamePieces。这种实现利用了多态性，因此一种解决方案是在GamePiece基类中添加纯虚的clone()成员函数，派生类必须实现它，以返回一个具体GamePiece的副本。以下是GamePiece的基本接口：

\begin{cpp}
export class GamePiece
{
    public:
        virtual ~GamePiece() = default;
        virtual std::unique_ptr<GamePiece> clone() const = 0;
};
\end{cpp}

GamePiece是一个抽象基类。具体的类，如ChessPiece，从GamePiece派生并实现clone()成员函数：

\begin{cpp}
class ChessPiece : public GamePiece
{
    public:
        std::unique_ptr<GamePiece> clone() const override
        {
            // Call the copy constructor to copy this instance
            return std::make_unique<ChessPiece>(*this);
        }
};
\end{cpp}

一个GameBoard代表一个二维网格，存储GamePieces在GameBoard中的选项可以是unique\_ptr的vector。然而，这不是最优的数据表示，因为数据将在内存中碎片化呈现。更好的是将棋子表示为线性化存储。将二维坐标，例如(x,y)，转换为一维位置很容易，公式为x+y*width。

\begin{cpp}
export class GameBoard
{
    public:
        explicit GameBoard(std::size_t width = DefaultWidth,
            std::size_t height = DefaultHeight);
        GameBoard(const GameBoard& src); // copy constructor
        virtual ~GameBoard() = default; // virtual defaulted destructor
        GameBoard& operator=(const GameBoard& rhs); // assignment operator

        // Explicitly default a move constructor and move assignment operator.
        GameBoard(GameBoard&& src) = default;
        GameBoard& operator=(GameBoard&& src) = default;

        std::unique_ptr<GamePiece>& at(std::size_t x, std::size_t y);
        const std::unique_ptr<GamePiece>& at(std::size_t x, std::size_t y) const;

        std::size_t getHeight() const { return m_height; }
        std::size_t getWidth() const { return m_width; }

        static constexpr std::size_t DefaultWidth { 10 };
        static constexpr std::size_t DefaultHeight { 10 };

        void swap(GameBoard& other) noexcept;
    private:
        void verifyCoordinate(std::size_t x, std::size_t y) const;

        std::vector<std::unique_ptr<GamePiece>> m_cells;
        std::size_t m_width { 0 }, m_height { 0 };
};
export void swap(GameBoard& first, GameBoard& second) noexcept;
\end{cpp}

此实现中，at() 函数返回给定位置的游戏棋子的引用。GameBoard 类作为二维数组的抽象，应当提供数组访问语义，即返回位置对象的引用。客户端代码不应存储此引用以备将来使用，当 m\_cells 需要调整大小时，该引用可能会失效。相反，客户端代码应在使用位置信息之前直接调用 at()，这遵循了标准库 vector 类的设计哲学。

\begin{myNotic}{NOTE}
此实现提供了两个版本的 at() 函数；一个返回非常量引用，另一个返回常量引用。
\end{myNotic}

\CXXTwentythreeLogo{-40}{-60}

\begin{myNotic}{NOTE}
从 C++23 开始，可以为 GameBoard 类提供多维下标运算符。通过提供这样的运算符，客户端可以编写 myGameBoard[x,y] 来代替 myGameBoard.at(x,y)，以获取位置 (x,y) 处的棋子。第 15 章中介绍了此运算符。
\end{myNotic}

以下是成员函数定义。注意，此实现使用了复制并交换（copy-and-swap）习语作为赋值运算符，以及 Scott Meyers 的 const\_cast() 模式来避免代码重复，两者都在第 9 章中介绍过。

\begin{cpp}
GameBoard::GameBoard(size_t width, size_t height)
    : m_width { width }, m_height { height }
{
    m_cells.resize(m_width * m_height);
}
GameBoard::GameBoard(const GameBoard& src)
    : GameBoard { src.m_width, src.m_height }
{
    // The ctor-initializer of this constructor delegates first to the
    // non-copy constructor to allocate the proper amount of memory.

    // The next step is to copy the data.
    for (size_t i { 0 }; i < m_cells.size(); ++i) {
        if (src.m_cells[i]) {
            m_cells[i] = src.m_cells[i]->clone();
        }
    }
}

void GameBoard::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= m_width) {
        throw out_of_range {
            format("x ({}) must be less than width ({}).", x, m_width) };
    }
    if (y >= m_height) {
        throw out_of_range {
            format("y ({}) must be less than height ({}).", y, m_height) };
    }
}

void GameBoard::swap(GameBoard& other) noexcept
{
    std::swap(m_width, other.m_width);
    std::swap(m_height, other.m_height);
    std::swap(m_cells, other.m_cells);
}

void swap(GameBoard& first, GameBoard& second) noexcept
{
    first.swap(second);
}

GameBoard& GameBoard::operator=(const GameBoard& rhs)
{
    // Copy-and-swap idiom
    GameBoard temp { rhs }; // Do all the work in a temporary instance.
    swap(temp); // Commit the work with only non-throwing operations.
    return *this;
}

const unique_ptr<GamePiece>& GameBoard::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x + y * m_width];
}

unique_ptr<GamePiece>& GameBoard::at(size_t x, size_t y)
{
    return const_cast<unique_ptr<GamePiece>&>(as_const(*this).at(x, y));
}
\end{cpp}

这个 GameBoard 类工作得相当不错：

\begin{cpp}
GameBoard chessBoard { 8, 8 };
auto pawn { std::make_unique<ChessPiece>() };
chessBoard.at(0, 0) = std::move(pawn);
chessBoard.at(0, 1) = std::make_unique<ChessPiece>();
chessBoard.at(0, 1) = nullptr;
\end{cpp}

\mySamllsection{模板Grid类}

上一节中的 GameBoard 类不错，但还不够。一个问题是不能使用 GameBoard 来按值存储元素，其存储的是指针。另一个更严重的问题是与类型安全有关，GameBoard 中的每个单元格存储 unique\_ptr<GamePiece>。即使存储 ChessPieces，当使用 at() 请求某个棋子位置时，会得到一个 unique\_ptr<GamePiece>，所以必须将检索到的 GamePiece 向下转为 ChessPiece，才能使用 ChessPiece 的特定功能。此外，没有任何东西能阻止在 GameBoard 中混合所有类型的 GamePiece 派生对象。例如，不仅有 ChessPiece，还有 TicTacToePiece：

\begin{cpp}
class TicTacToePiece : public GamePiece
{
    public:
        std::unique_ptr<GamePiece> clone() const override
        {
            // Call the copy constructor to copy this instance
            return std::make_unique<TicTacToePiece>(*this);
        }
};
\end{cpp}

使用上一节的多态解决方案，可以在单个GameBoard上存储井字棋棋子和国际象棋棋子：

\begin{cpp}
GameBoard gameBoard { 8, 8 };
gameBoard.at(0, 0) = std::make_unique<ChessPiece>();
gameBoard.at(0, 1) = std::make_unique<TicTacToePiece>();
\end{cpp}

这个问题的麻烦在于，需要以某种方式记住某个位置上存储了什么，以便在调用 at() 时进行正确的向下转型。

GameBoard 的另一个缺点是不能用来存储基本类型，如 int 或 double，因为单元格中存储的类型必须派生自 GamePiece。

如果能编写一个通用 Grid 类模板，可以用来存储 ChessPiece、SpreadsheetCell、int、double 等就好了。在 C++ 中，可以通过编写一个类模板来实现这一点，类模板是类定义的蓝图。在类模板中，并非所有的类型都已知。然后客户端通过指定他们想要使用的类型来实例化模板，这称为泛型编程。泛型编程的最大优点是类型安全。在实例化的类定义，及其成员函数中使用的类型是具体类型，而不是像上一节多态解决方案中的抽象基类类型。

先看看如何编写一个 Grid 类模板定义。

\mySamllsection{Grid类模板定义}

为了理解类模板，先了解其语法。以下示例展示了如何将 GameBoard 类修改为参数化的 Grid 类模板。请注意，名称已从 GameBoard 更改为 Grid。Grid 也应该能够与 int 和 double 等原始类型一起使用。这就是为什么我选择使用值语义，而不是 GameBoard 实现中使用的多态指针语义来实现这个解决方案。m\_cells 容器存储实际对象，而不是指针。与指针语义相比，使用值语义的缺点是不能有真正的空单元格；也就是说，单元格必须始终包含某些值。使用指针语义，空单元格存储的是 nullptr。幸运的是，第 1 章中介绍的 std::optional 此时派上了用场，其允许使用值语义，同时仍有一种表示空单元格的方式。

\begin{cpp}
export template <typename T>
class Grid
{
    public:
        explicit Grid(std::size_t width = DefaultWidth,
            std::size_t height = DefaultHeight);
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and copy assignment operator.
        Grid(const Grid& src) = default;
        Grid& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and move assignment operator.
        Grid(Grid&& src) = default;
        Grid& operator=(Grid&& rhs) = default;

        std::optional<T>& at(std::size_t x, std::size_t y);
        const std::optional<T>& at(std::size_t x, std::size_t y) const;

        std::size_t getHeight() const { return m_height; }
        std::size_t getWidth() const { return m_width; }

        static constexpr std::size_t DefaultWidth { 10 };
        static constexpr std::size_t DefaultHeight { 10 };
    private:
        void verifyCoordinate(std::size_t x, std::size_t y) const;

        std::vector<std::optional<T>> m_cells;
        std::size_t m_width { 0 }, m_height { 0 };
};
\end{cpp}

现在已经看到了完整的类模板定义，再从第一行开始看起。

\begin{cpp}
export template <typename T>
\end{cpp}

这第一行说明以下类定义是一个模板，用于一个类型 T，并且它正在从模块中导出。 "template <typename T>" 部分称为模板头，模板和 typename 都是 C++ 的关键字。模板“参数化”类型，就像函数“参数化”值一样，就像在函数中使用参数名来代表调用者将传递的参数一样，在模板中使用模板类型参数名（如 T）来代表调用者将作为模板类型参数传递的类型。T 的名称没有什么特别的，可以使用想要的名称。通常，当使用单个类型时，称为 T，但这只是惯例而已，就像将索引数组的整数称为 i 或 j 一样。模板指定符适用于整个语句，即类模板定义。

\begin{myNotic}{NOTE}
由于历史原因，可以使用关键字 class，而不是 typename 来指定模板类型参数。因此，许多书籍和现有程序使用如下语法：template <class T>。在这个上下文中使用 class 这个词是有问题的，因为它暗示类型必须是类，这并不正确。类型可以是类、结构体、联合体、语言的原始类型，如 int 或 double 等。为了避免这种混淆，本书使用 typename。
\end{myNotic}

之前的 GameBoard 类中，m\_cells 数据成员是一个指针vector，这需要特殊代码进行复制——因此需要复制构造函数和复制赋值运算符。Grid 类中，m\_cells 是一个optional的vector，所以编译器生成的复制构造函数和赋值运算符就足够了。然而，正如第 8 章中解释的那样，当有一个用户声明的析构函数，编译器隐式生成复制构造函数或复制赋值运算符就会过时，所以 Grid 类模板显式默认它们，还显式默认了移动构造函数和移动赋值运算符。以下是显式默认的复制赋值运算符：

\begin{cpp}
Grid& operator=(const Grid& rhs) = default;
\end{cpp}

rhs 参数的类型不再是 const GameBoard\&，而是 const Grid\&。在类定义内部，编译器在需要时将 Grid 解释为 Grid<T>，也可以显式使用 Grid<T>：

\begin{cpp}
Grid<T>& operator=(const Grid<T>& rhs) = default;
\end{cpp}

然而，在类定义外部，必须使用 Grid<T>。当编写一个类模板时，以前的类名（Grid）实际上是模板名。想要谈论实际的 Grid 类或类型时，必须使用模板 ID，即 Grid<T>，这是 Grid 类模板为特化类型（如 int、SpreadsheetCell 或 ChessPiece）的实例化。

因为 m\_cells 不再存储指针，而是可选值，所以 at() 成员函数现在返回 optional<T> ，而不是 unique\_ptr。也就是说，值可以是类型 T 的值，也可以为空：

\begin{cpp}
std::optional<T>& at(std::size_t x, std::size_t y);
const std::optional<T>& at(std::size_t x, std::size_t y) const;
\end{cpp}

\mySamllsection{定义Grid类模板的成员函数}

对于 Grid 类模板，模板头 <typename T> 必须出现在每个成员函数定义之前。构造函数如下所示：

\begin{cpp}
template <typename T>
Grid<T>::Grid(std::size_t width, std::size_t height)
    : m_width { width }, m_height { height }
{
    m_cells.resize(m_width * m_height);
}
\end{cpp}

\begin{myNotic}{NOTE}
模板的成员函数定义,必须对任何使用该类模板的客户端代码可见。这限制了此类成员函数定义可以放置的位置。通常，只是简单地放在类模板定义本身的同一个文件中。关于绕过此限制的一些方法,将在本章后面讨论。
\end{myNotic}

请注意，:: 之前的名称是 Grid<T>，而不是 Grid。构造函数的主体与 GameBoard 构造函数相同，其余的成员函数定义也与 GameBoard 类中的相应部分相似：

\begin{cpp}
template <typename T>
void Grid<T>::verifyCoordinate(std::size_t x, std::size_t y) const
{
    if (x >= m_width) {
        throw std::out_of_range {
            std::format("x ({}) must be less than width ({}).", x, m_width) };
    }
    if (y >= m_height) {
        throw std::out_of_range {
            std::format("y ({}) must be less than height ({}).", y, m_height) };
    }
}

template <typename T>
const std::optional<T>& Grid<T>::at(std::size_t x, std::size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x + y * m_width];
}

template <typename T>
std::optional<T>& Grid<T>::at(std::size_t x, std::size_t y)
{
    return const_cast<std::optional<T>&>(std::as_const(*this).at(x, y));
}
\end{cpp}

\begin{myNotic}{NOTE}
如果类模板成员函数的实现需要,为某个模板类型参数提供默认值，例如 T，那么可以使用 T\{\} 语法。T\{\} 在 T 是类类型时调用对象的默认构造函数，或者在 T 是原始类型时生成零,这种语法称为零初始化语法。这是为类型未知，但需要合理默认值的变量提供了默认值。
\end{myNotic}

\mySamllsection{使用 Grid 模板}

当想要创建 Grid 对象时，不能单独使用 Grid 作为类型；必须指定要存储在该 Grid 中的类型。为特定类型创建类模板的具体实例，称为模板实例化：

\begin{cpp}
Grid<int> myIntGrid; // Declares a grid that stores ints,
// using default arguments for the constructor.
Grid<double> myDoubleGrid { 11, 11 }; // Declares an 11x11 Grid of doubles.

myIntGrid.at(0, 0) = 10;
int x { myIntGrid.at(0, 0).value_or(0) };

Grid<int> grid2 { myIntGrid }; // Copy constructor
Grid<int> anotherIntGrid;
anotherIntGrid = grid2; // Assignment operator
\end{cpp}

注意，myIntGrid、grid2 和 anotherIntGrid 的类型是 Grid<int>。不能在这些网格中存储 SpreadsheetCells 或 ChessPieces；如果尝试这样做，编译器将报错。

还要注意 value\_or() 的使用。at() 成员函数返回一个可选引用，可以包含一个值或没有值。value\_or() 如果有值，则返回 optional 中的值；否则，返回传递给 value\_or() 的参数。

指定类型很重要；以下两行都无法通过编译：

\begin{cpp}
Grid test; // WILL NOT COMPILE
Grid<> test; // WILL NOT COMPILE
\end{cpp}

第一行，编译器会产生类似“使用类模板需要模板参数列表”的错误。第二行，会报“模板参数太少”的错误。

如果想要声明一个接受 Grid 对象的函数，必须将存储在该网格中的类型作为 Grid 类型的一部分进行指定：

\begin{cpp}
void processIntGrid(Grid<int>& grid) { /* Body omitted for brevity */ }
\end{cpp}

或者，可以使用本章后面讨论的函数模板，编写一个对网格中元素类型参数化的函数。

Grid 类模板可以存储不仅仅是 int。例如，可以实例化一个存储 SpreadsheetCell 的 Grid：

\begin{cpp}
Grid<SpreadsheetCell> mySpreadsheet;
SpreadsheetCell myCell { 1.234 };
mySpreadsheet.at(3, 4) = myCell;
\end{cpp}

也可以存储指针类型：

\begin{cpp}
Grid<const char*> myStringGrid;
myStringGrid.at(2, 2) = "hello";
\end{cpp}

指定的类型甚至可以是另一个模板类型：

\begin{cpp}
Grid<vector<int>> gridOfVectors;
vector<int> myVector { 1, 2, 3, 4 };
gridOfVectors.at(5, 6) = myVector;
\end{cpp}

还可以在堆区动态分配 Grid 对象：

\begin{cpp}
auto myGridOnFreeStore { make_unique<Grid<int>>(2, 2) }; // 2x2 Grid on free store.
myGridOnFreeStore->at(0, 0) = 10;
int x { myGridOnFreeStore->at(0, 0).value_or(0) };
\end{cpp}


\mySubsubsection{12.2.2.}{How the Compiler Processes Templates}

To understand the intricacies of templates, you need to learn how the compiler processes template code. When the compiler encounters class template member function definitions, it performs syntax checking, but doesn’t actually compile the templates. It can’t compile template definitions because it doesn’t know for which types they will be used. It’s impossible for a compiler to generate code for something like x = y without knowing the types of x and y. This syntax-checking step is the first step in the two-phase name lookup process.

The second step in the two-phase name lookup process happens when the compiler encounters an instantiation of the template, such as Grid<int>. At that moment, the compiler writes code for an int version of the Grid template by replacing each T in the class template definition with int. When the compiler encounters a different instantiation of the template, such as Grid<SpreadsheetCell>, it writes another version of the Grid class for SpreadsheetCells. The compiler just writes the code

that you would write if you didn’t have template support in the language and had to write separate classes for each element type. There’s no magic here; templates just automate an annoying process. If you don’t instantiate a class template for any types in your program, then the class template member function definitions are never compiled.

This instantiation process explains why you need to use the Grid<T> syntax in various places in your definition. When the compiler instantiates the template for a particular type, such as int, it replaces T with int, so that Grid<int> is the type.

\mySamllsection{Selective/Implicit Instantiation}

For implicit class template instantiations such as the following:

\begin{cpp}
Grid<int> myIntGrid;
\end{cpp}

the compiler always generates code for all virtual member functions of the class template. However, for non-virtual member functions, the compiler generates code only for those non-virtual member functions that are actually called. For example, given the earlier Grid class template, suppose that you write this code (and only this code) in main():

\begin{cpp}
Grid<int> myIntGrid;
myIntGrid.at(0, 0) = 10;
\end{cpp}

The compiler generates only the zero-argument constructor, the destructor, and the non-const at() member function for an int version of Grid. It does not generate other member functions like the copy constructor, the assignment operator, or getHeight(). This is called selective instantiation.


\mySamllsection{Explicit Instantiation}

The danger exists that there are compilation errors in some class template member functions that go unnoticed with implicit instantiations. Unused member functions of class templates can contain syntax errors, as these will not be compiled. This makes it hard to test all code for syntax errors. You can force the compiler to generate code for all member functions, virtual and non-virtual, by using explicit template instantiations. Here’s an example:

\begin{cpp}
template class Grid<string>;
\end{cpp}

\begin{myNotic}{NOTE}
Explicit template instantiations help with finding errors, as they force all your class template member functions to be compiled even when unused.
\end{myNotic}

When using explicit template instantiations, don’t just try to instantiate the class template with basic types like int, but try it with more complicated types like string, if those are accepted by the class template.

\mySamllsection{Template Requirements on Types}

When you write code that is independent of types, you must assume certain things about those types. For example, in the Grid class template, you assume that the element type (represented by T) is destructible, copy/move constructible, and copy/move assignable.

When the compiler attempts to instantiate a template with types that do not support all the operations used by class template member functions that are called, the code will not compile, and the error messages will often be quite obscure. However, even if the types you want to use don’t support the operations required by all the member functions of the class template, you can exploit selective instantiation to use some member functions but not others.

You can use concepts to write requirements for template parameters that the compiler can interpret and validate. The compiler can generate more readable errors if the template arguments passed to instantiate a template do not satisfy these requirements. Concepts are discussed later in this chapter.

\mySubsubsection{12.2.3.}{Distributing Template Code Between Files}

With class templates, both the class template definition and the member function definitions must be available to the compiler from any source file that uses them. There are several mechanisms to accomplish this.

\mySamllsection{Member Function Definitions in Same File as Class Template Definition}

You can place the member function definitions directly in the module interface file where you define the class template itself. When you import this module in another source file where you use the template, the compiler will have access to all the code it needs. This mechanism is used for the previous Grid implementation.

\mySamllsection{Member Function Definitions in Separate File}

Alternatively, you can place the class template member function definitions in a separate module interface partition file. You then also need to put the class template definition in its own module interface partition. For example, the primary module interface file for the Grid class template could look like this:

\begin{cpp}
export module grid;

export import :definition;
export import :implementation;
\end{cpp}

This imports and exports two module interface partitions: definition and implementation. The class template definition is defined in the definition partition:

\begin{cpp}
export module grid:definition;

import std;

export template <typename T> class Grid { ... };
\end{cpp}

The implementations of the member functions are in the implementation partition, which also needs to import the definition partition because it needs the Grid class template definition:

\begin{cpp}
export module grid:implementation;

import :definition;
import std;

export template <typename T>
Grid<T>::Grid(std::size_t width, std::size_t height)
    : m_width { width }, m_height { height }
{ /* ... */ }
// Remainder omitted for brevity.
\end{cpp}

\mySubsubsection{12.2.4.}{Template Parameters}

In the Grid example, the Grid class template has one template parameter: the type that is stored in the grid. When you write the class template, you specify the parameter list inside the angle brackets, like this:

\begin{cpp}
template <typename T>
\end{cpp}

This parameter list is similar to the parameter list of functions. As with functions, you can write a class template with as many template parameters as you want. Additionally, these parameters don’t have to be types, and they can have default values.

\mySamllsection{Non-type Template Parameters}

Non-type template parameters are “normal” parameters such as ints and pointers—the kind of parameters which you’re familiar with from functions. However, non-type template parameters can only be integral types (char, int, long, and so on), enumerations, pointers, references, std::nullptr\_t, auto, auto\&, auto*, floating-point types, and class types. The latter, however, come with a lot of limitations, not further discussed in this text. Remember that templates are instantiated at compile time; hence, arguments for non-type template parameters are evaluated at compile time. That means such arguments must be literals or compile-time constants.

In the Grid class template, you could use non-type template parameters to specify the height and width of the grid instead of specifying them in the constructor. The principal advantage of using nontype template parameters instead of constructor parameters is that the values are known before the code is compiled. Recall that the compiler generates code for template instantiations by substituting the template parameters before compiling. Thus, you can use a normal two-dimensional array in the following implementation instead of a linearized representation using a vector that is dynamically resized. Here is the new class template definition with the changes highlighted:

\begin{cpp}
export template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
class Grid
{
    public:
        Grid() = default;
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and copy assignment operator.
        Grid(const Grid& src) = default;
        Grid& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and move assignment operator.
        Grid(Grid&& src) = default;
        Grid& operator=(Grid&& rhs) = default;

        std::optional<T>& at(std::size_t x, std::size_t y);
        const std::optional<T>& at(std::size_t x, std::size_t y) const;

        std::size_t getHeight() const { return HEIGHT; }
        std::size_t getWidth() const { return WIDTH; }

    private:
        void verifyCoordinate(std::size_t x, std::size_t y) const;

        std::optional<T> m_cells[WIDTH][HEIGHT];
};
\end{cpp}

The template parameter list now has three parameters: the type of objects stored in the grid, and the width and height of the grid. The width and height are used to create a two-dimensional array to store the objects. Here are the class template member function definitions:

\begin{cpp}
template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
void Grid<T, WIDTH, HEIGHT>::verifyCoordinate(std::size_t x, std::size_t y) const
{
    if (x >= WIDTH) {
        throw std::out_of_range {
            std::format("x ({}) must be less than width ({}).", x, WIDTH) };
    }
    if (y >= HEIGHT) {
        throw std::out_of_range {
            std::format("y ({}) must be less than height ({}).", y, HEIGHT) };
    }
}

template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(
    std::size_t x, std::size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x][y];
}

template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(std::size_t x, std::size_t y)
{
    return const_cast<std::optional<T>&>(std::as_const(*this).at(x, y));
}
\end{cpp}

Note that wherever you previously specified Grid<T> you must now specify Grid<T,WIDTH,HEIGHT> to specify the three template parameters.

You can instantiate this template and use it as follows:

\begin{cpp}
Grid<int, 10, 10> myGrid;
Grid<int, 10, 10> anotherGrid;
myGrid.at(2, 3) = 42;
anotherGrid = myGrid;
println("{}", anotherGrid.at(2, 3).value_or(0));
\end{cpp}

This code seems great, but unfortunately, there are more restrictions than you might initially expect. First, you can’t use a non-constant integer to specify the height or width. The following code doesn’t compile:

\begin{cpp}
size_t height { 10 };
Grid<int, 10, height> testGrid; // DOES NOT COMPILE
\end{cpp}

If you define height as a constant, it compiles:

\begin{cpp}
const size_t height { 10 };
Grid<int, 10, height> testGrid; // Compiles and works
\end{cpp}

constexpr functions with the correct return type also work. For example, if you have a constexpr function returning a size\_t, you can use it to initialize the height template parameter:

\begin{cpp}
constexpr size_t getHeight() { return 10; }
...
Grid<double, 2, getHeight()> myDoubleGrid;
\end{cpp}

A second restriction might be more significant. Now that the width and height are template parameters, they are part of the type of each grid. That means Grid<int,10,10> and Grid<int,10,11> are two different types. You can’t assign an object of one type to an object of the other, and variables of one type can’t be passed to functions that expect variables of another type.

\begin{myNotic}{NOTE}
Non-type template parameters become part of the type specification of instantiated objects.
\end{myNotic}

\mySamllsection{Default Values for Template Parameters}

If you continue the approach of making height and width template parameters, you might want to provide defaults for the height and width non-type template parameters just as you did previously in the constructor of the Grid<T> class template. C++ allows you to provide defaults for template parameters with a similar syntax. While you are at it, you could also provide a default for the T type parameter. Here is the class definition:

\begin{cpp}
export template <typename T = int, std::size_t WIDTH = 10, std::size_t HEIGHT = 10>
class Grid
{
    // Remainder is identical to the previous version
};
\end{cpp}

You don’t specify the default values for T, WIDTH, and HEIGHT in the template header for the member function definitions. For example, here is the implementation of at():

\begin{cpp}
template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(
    std::size_t x, std::size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x][y];
}
\end{cpp}

With these changes, you can instantiate a Grid without any template parameters, with only the element type, the element type and the width, or the element type, width, and height:

\begin{cpp}
Grid<> myIntGrid;
Grid<int> myGrid;
Grid<int, 5> anotherGrid;
Grid<int, 5, 5> aFourthGrid;
\end{cpp}

Note that if you don’t specify any class template parameters, you still need to specify an empty set of angle brackets. For example, the following does not compile!

\begin{cpp}
Grid myIntGrid;
\end{cpp}

The rules for default arguments in class template parameter lists are the same as for functions; that is, you can provide defaults for parameters in order starting from the right.

\mySamllsection{Class Template Argument Deduction}

With class template argument deduction, the compiler can automatically deduce the template type parameters from the arguments passed to a class template constructor.

For example, the Standard Library has a class template called std::pair, defined in <utility> and introduced in Chapter 1. A pair stores exactly two values of two possibly different types, which you normally would have to specify as the template type parameters. Here’s an example:

\begin{cpp}
pair<int, double> pair1 { 1, 2.3 };
\end{cpp}

To avoid having to write the template type parameters explicitly, a helper function template called std::make\_pair() is available. Details of writing your own function templates are discussed later in this chapter. Function templates have always supported the automatic deduction of template type parameters based on the arguments passed to the function template. Thus, make\_pair() is capable of automatically deducing the template type parameters based on the values passed to it. For example, the compiler deduces pair<int, double> for the following call:

\begin{cpp}
auto pair2 { make_pair(1, 2.3) };
\end{cpp}

With class template argument deduction (CTAD), such helper function templates are no longer necessary. The compiler now automatically deduces the template type parameters based on the arguments passed to a constructor. For the pair class template, you can simply write the following code:

\begin{cpp}
pair pair3 { 1, 2.3 }; // pair3 has type pair<int, double>
\end{cpp}

Of course, this works only when all template type parameters of a class template either have default values or are used as parameters in the constructor so that they can be deduced.

Note that an initializer is required for CTAD to work. The following is illegal:

\begin{cpp}
pair pair4;
\end{cpp}

A lot of the Standard Library classes support CTAD, for example, vector, array, and so on.

\begin{myNotic}{NOTE}
This type deduction is disabled for std::unique\_ptr and shared\_ptr. You pass a T* to their constructors, which means that the compiler would have to choose between deducing <T> or <T[]>, a dangerous choice to get wrong. So, just remember that for unique\_ptr and shared\_ptr, you need to keep using make\_unique() and make\_shared().
\end{myNotic}

\mySamllsection{User-Defined Deduction Guides}

You can also write your own user-defined deduction guides to help the compiler. These allow you to write rules for how the template type parameters have to be deduced. The following is an example demonstrating their use.

Suppose you have this SpreadsheetCell class template:

\begin{cpp}
template <typename T>
class SpreadsheetCell
{
    public:
        explicit SpreadsheetCell(T t) : m_content { move(t) } { }
        const T& getContent() const { return m_content; }
    private:
        T m_content;
};
\end{cpp}

Thanks to CTAD, you can create a SpreadsheetCell with an std::string type. The deduced type is SpreadsheetCell<string>:

\begin{cpp}
string myString { "Hello World!" };
SpreadsheetCell cell { myString };
\end{cpp}

However, if you pass a const char* to the SpreadsheetCell constructor, then type T is deduced as const char*, which is not what you want! You can create the following user-defined deduction guide to make sure T is deduced as std::string when passing a const char* as argument to the constructor:

\begin{cpp}
SpreadsheetCell(const char*) -> SpreadsheetCell<std::string>;
\end{cpp}

This guide has to be defined outside the class definition but inside the same namespace as the SpreadsheetCell class.

The general syntax is as follows. The explicit keyword is optional and behaves the same as explicit for constructors. Such deduction guides are, more often than not, templates as well.

\begin{cpp}
template <...>
explicit TemplateName(Parameters) -> DeducedTemplate<...>;
\end{cpp}

\mySubsubsection{12.2.5.}{Member Function Templates}

C++ allows you to parametrize individual member functions of a class. Such member functions are called member function templates and can be inside a normal class or in a class template. When you write a member function template, you are actually writing many different versions of that member function for many different types. Member function templates are useful for assignment operators and copy constructors in class templates.

\begin{myWarning}{WARNING}
Virtual member functions and destructors cannot be member function templates.
\end{myWarning}

Consider the original Grid template with only one template parameter: the element type. You can instantiate grids of many different types, such as ints and doubles:

\begin{cpp}
Grid<int> myIntGrid;
Grid<double> myDoubleGrid;
\end{cpp}

However, Grid<int> and Grid<double> are two different types. If you write a function that takes an object of type Grid<double>, you cannot pass a Grid<int>. Even though you know that the elements of an int grid could be copied to the elements of a double grid, because ints can be converted into doubles, you cannot assign an object of type Grid<int> to one of type Grid<double> or construct a Grid<double> from a Grid<int>. Neither of the following two lines compiles:

\begin{cpp}
myDoubleGrid = myIntGrid; // DOES NOT COMPILE
Grid<double> newDoubleGrid { myIntGrid }; // DOES NOT COMPILE
\end{cpp}

The problem is that the copy constructor and assignment operator for the Grid template are as follows:

\begin{cpp}
Grid(const Grid& src);
Grid& operator=(const Grid& rhs);
\end{cpp}

which are equivalent to:

\begin{cpp}
Grid(const Grid<T>& src);
Grid<T>& operator=(const Grid<T>& rhs);
\end{cpp}

The Grid copy constructor and operator= both take a reference to a const Grid<T>. When you instantiate a Grid<double> and try to call the copy constructor and operator=, the compiler generates member functions with these prototypes:

\begin{cpp}
Grid(const Grid<double>& src);
Grid<double>& operator=(const Grid<double>& rhs);
\end{cpp}

There are no constructors or operator= that take a Grid<int> within the generated Grid<double> class.

Luckily, you can rectify this oversight by adding parametrized versions of the copy constructor and assignment operator to the Grid class template to generate member functions that will convert from one grid type to another. Here is the new Grid class template definition:

\begin{cpp}
export template <typename T>
class Grid
{
    public:
        template <typename E>
        Grid(const Grid<E>& src);

        template <typename E>
        Grid& operator=(const Grid<E>& rhs);

        void swap(Grid& other) noexcept;

        // Omitted for brevity
};
\end{cpp}

The original copy constructor and copy assignment operator cannot be removed. The compiler will not call these new parametrized copy constructor and parametrized copy assignment operator if E equals T.

Examine the new parametrized copy constructor first:

\begin{cpp}
template <typename E>
Grid(const Grid<E>& src);
\end{cpp}

You can see that there is another template header with a different typename, E (short for “element”). The class is parametrized on one type, T, and the new copy constructor is additionally parametrized on a different type, E. This twofold parametrization allows you to copy grids of one type to another. Here is the definition of the new copy constructor:

\begin{cpp}
template <typename T>
template <typename E>
Grid<T>::Grid(const Grid<E>& src)
    : Grid { src.getWidth(), src.getHeight() }
{
    // The ctor-initializer of this constructor delegates first to the
    // non-copy constructor to allocate the proper amount of memory.

    // The next step is to copy the data.
    for (std::size_t i { 0 }; i < m_width; ++i) {
        for (std::size_t j { 0 }; j < m_height; ++j) {
            at(i, j) = src.at(i, j);
        }
    }
}
\end{cpp}

As you can see, you must declare the class template header (with the T parameter) before the member template header (with the E parameter). You can’t combine them like this:

\begin{cpp}
template <typename T, typename E> // Wrong for nested template constructor!
Grid<T>::Grid(const Grid<E>& src)
\end{cpp}

In addition to the extra template header before the constructor definition, note that you must use the public accessor member functions getWidth(), getHeight(), and at() to access the elements of src. That’s because the object you’re copying to is of type Grid<T>, and the object you’re copying from is of type Grid<E>. They are not the same type, so you must use public member functions.

The swap() member function is straightforward:

\begin{cpp}
template <typename T>
void Grid<T>::swap(Grid& other) noexcept
{
    std::swap(m_width, other.m_width);
    std::swap(m_height, other.m_height);
    std::swap(m_cells, other.m_cells);
}
\end{cpp}

The parametrized assignment operator takes a const Grid<E>\& but returns a Grid<T>\&:

\begin{cpp}
template <typename T>
template <typename E>
Grid<T>& Grid<T>::operator=(const Grid<E>& rhs)
{
    // Copy-and-swap idiom
    Grid<T> temp { rhs }; // Do all the work in a temporary instance.
    swap(temp); // Commit the work with only non-throwing operations.
    return *this;
}
\end{cpp}

The implementation of this assignment operator uses the copy-and-swap idiom introduced in Chapter 9. The swap() member function can only swap Grids of the same type, but that’s OK because this parametrized assignment operator first converts a given Grid<E> to a Grid<T> called temp using the parametrized copy constructor. Afterward, it uses the swap() member function to swap this temporary Grid<T> with this, which is also of type Grid<T>.

\mySamllsection{Member Function Templates with Non-type Template Parameters}

A major problem with the earlier Grid class template with integer template parameters for HEIGHT and WIDTH is that the height and width become part of the types. This restriction prevents you from assigning a grid with one height and width to a grid with a different height and width. In some cases, however, it’s desirable to assign or copy a grid of one size to a grid of a different size. Instead of making the destination object a perfect clone of the source object, you would copy only those elements from the source array that fit in the destination array, padding the destination array with default values if the source array is smaller in either dimension. With member function templates for the assignment operator and copy constructor, you can do exactly that, thus allowing assignment and copying of different-sized grids. Here is the class definition:

\begin{cpp}
export template <typename T, std::size_t WIDTH = 10, std::size_t HEIGHT = 10>
class Grid
{
    public:
        Grid() = default;
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and move assignment operator.
        Grid(Grid&& src) = default;
        Grid& operator=(Grid&& rhs) = default;

        template <typename E, std::size_t WIDTH2, std::size_t HEIGHT2>
        Grid(const Grid<E, WIDTH2, HEIGHT2>& src);
        template <typename E, std::size_t WIDTH2, std::size_t HEIGHT2>
        Grid& operator=(const Grid<E, WIDTH2, HEIGHT2>& rhs);

        void swap(Grid& other) noexcept;

        std::optional<T>& at(std::size_t x, std::size_t y);
        const std::optional<T>& at(std::size_t x, std::size_t y) const;

        std::size_t getHeight() const { return HEIGHT; }
        std::size_t getWidth() const { return WIDTH; }

    private:
        void verifyCoordinate(std::size_t x, std::size_t y) const;

        std::optional<T> m_cells[WIDTH][HEIGHT];
};
\end{cpp}

This new definition includes member function templates for the copy constructor and assignment operator, plus a helper member function swap(). Note that the non-parametrized copy constructor and assignment operator are explicitly defaulted (because of the user-declared destructor). They simply copy or assign m\_cells from the source to the destination, which is exactly the semantics you want for two grids of the same size.

Here is the parametrized copy constructor:

\begin{cpp}
template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
template <typename E, std::size_t WIDTH2, std::size_t HEIGHT2>
Grid<T, WIDTH, HEIGHT>::Grid(const Grid<E, WIDTH2, HEIGHT2>& src)
{
    for (std::size_t i { 0 }; i < WIDTH; ++i) {
        for (std::size_t j { 0 }; j < HEIGHT; ++j) {
            if (i < WIDTH2 && j < HEIGHT2) {
                m_cells[i][j] = src.at(i, j);
            } else {
                m_cells[i][j].reset();
            }
        }
    }
}
\end{cpp}

Note that this copy constructor copies only WIDTH and HEIGHT elements in the x and y dimensions, respectively, from src, even if src is bigger than that. If src is smaller in either dimension, the std::optional objects in the extra spots are reset using the reset() member function.

Here are the implementations of swap() and operator=:


\begin{cpp}
template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
void Grid<T, WIDTH, HEIGHT>::swap(Grid& other) noexcept
{
    std::swap(m_cells, other.m_cells);
}
template <typename T, std::size_t WIDTH, std::size_t HEIGHT>
template <typename E, std::size_t WIDTH2, std::size_t HEIGHT2>
Grid<T, WIDTH, HEIGHT>& Grid<T, WIDTH, HEIGHT>::operator=(
    const Grid<E, WIDTH2, HEIGHT2>& rhs)
{
    // Copy-and-swap idiom
    Grid<T, WIDTH, HEIGHT> temp { rhs }; // Do all the work in a temp instance.
    swap(temp); // Commit the work with only non-throwing operations.
    return *this;
}
\end{cpp}


\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{Using Member Function Templates with Explicit Object Parameters to Avoid Code Duplication}

Our running example of the Grid class template with a single template type parameter T contains two overloads of an at() member function, const and non-const. As a reminder:

\begin{cpp}
export template <typename T>
class Grid
{
    public:
        std::optional<T>& at(std::size_t x, std::size_t y);
        const std::optional<T>& at(std::size_t x, std::size_t y) const;
        // Remainder omitted for brevity
};
\end{cpp}

Their implementations use Scott Meyers’ const\_cast() pattern to avoid code duplication:

\begin{cpp}
template <typename T>
const std::optional<T>& Grid<T>::at(std::size_t x, std::size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x + y * m_width];
}

template <typename T>
std::optional<T>& Grid<T>::at(std::size_t x, std::size_t y)
{
    return const_cast<std::optional<T>&>(std::as_const(*this).at(x, y));
}
\end{cpp}

Although there is no code duplication, you still need to define both the const and non-const overloads explicitly. Starting with C++23, you can use an explicit object parameter (see Chapter 8) to avoid having to provide the two overloads explicitly. The trick is to turn the at() member function into a member function template where the type of the explicit object parameter self is itself a template type parameter, Self, and thus deduced automatically. This feature is called deducing this. Here is such a declaration:

\begin{cpp}
export template <typename T>
class Grid
{
    public:
        template <typename Self>
        auto&& at(this Self&& self, std::size_t x, std::size_t y);
        // Remainder omitted for brevity
};
\end{cpp}

The implementation uses a forwarding reference, Self\&\&; see the following note. Such a forwarding reference can bind to Grid<T>\&, const Grid<T>\&, and Grid<T>\&\&.

\begin{myNotic}{NOTE}
A reference of type Self\&\& is only a forwarding reference when it is used as a parameter for a function or member function template with Self as one of its template type parameters. If a class member function has a Self\&\& parameter, but with Self a template type parameter of the class and not of the member function itself, then that Self\&\& is not a forwarding reference, but just an rvalue reference. That’s because at the time the compiler starts processing that member function with a Self\&\& parameter, the class template parameter Self has already been resolved to a concrete type, for example int, and at that time, that member function parameter type has already been replaced with int\&\&.
\end{myNotic}

Here is the implementation. Remember from Chapter 8 that in the body of a member function using an explicit object parameter, you need to use the explicit object parameter, self in this case, to get access to the object; there is no this pointer.

\begin{cpp}
template <typename T>
template <typename Self>
auto&& Grid<T>::at(this Self&& self, std::size_t x, std::size_t y)
{
    self.verifyCoordinate(x, y);
    return std::forward_like<Self>(self.m_cells[x + y * self.m_width]);
}
\end{cpp}

The implementation uses std::forward\_like<Self>(x) introduced in C++23. This returns a reference to x with similar properties as Self\&\&. Thus, since the type of the elements of m\_cells is optional<T>, the following holds:

\begin{itemize}
\item
If Self\&\& is bound to a Grid<T>\&, the return type will be an optional<T>\&.

\item
If Self\&\& is bound to a const Grid<T>\&, the return type will be a const optional<T>\&.

\item
If Self\&\& is bound to a Grid<T>\&\&, the return type will be an optional<T>\&\&.
\end{itemize}

To summarize, with a combination of member function templates, explicit object parameters, forwarding references, and forward\_like(), it becomes possible to declare and define just a single member function template that provides both const and non-const instantiations.

\mySubsubsection{12.2.6.}{Class Template Specialization}

You can provide alternate implementations of class templates for specific types. For example, you might decide that the Grid behavior for const char*s (C-style strings) doesn’t make sense. A Grid<const char*> will store its elements in a vector<optional<const char*>{}>. The copy constructor and assignment operator will perform shallow copies of this const char* pointer type. For const char*s, it makes more sense to do a deep copy of strings. The easiest solution for this is to write an alternative implementation specifically for const char*s, which converts them to C++ strings and stores them in a vector<optional<string>{}>.

Alternate implementations of templates are called template specializations. You might find the syntax to be a little weird at first. When you write a class template specialization, you must specify that it’s based on a template and that you are writing a version of the template for a particular type. Here is the syntax for a const char* specialization for Grid. For this implementation, the original Grid class template is moved to a module interface partition called main, while the specialization is in a module interface partition called string.


\begin{cpp}
export module grid:string;
import std;
// When the template specialization is used, the original template must be
// visible too.
import :main;

export template <>
class Grid<const char*>
{
    public:
        explicit Grid(std::size_t width = DefaultWidth,
            std::size_t height = DefaultHeight);
        virtual ~Grid() = default;

        // Explicitly default a copy constructor and assignment operator.
        Grid(const Grid& src) = default;
        Grid& operator=(const Grid& rhs) = default;

        // Explicitly default a move constructor and assignment operator.
        Grid(Grid&& src) = default;
        Grid& operator=(Grid&& rhs) = default;

        std::optional<std::string>& at(std::size_t x, std::size_t y);
        const std::optional<std::string>& at(std::size_t x, std::size_t y) const;

        std::size_t getHeight() const { return m_height; }
        std::size_t getWidth() const { return m_width; }

        static constexpr std::size_t DefaultWidth { 10 };
        static constexpr std::size_t DefaultHeight { 10 };

    private:
        void verifyCoordinate(std::size_t x, std::size_t y) const;

        std::vector<std::optional<std::string>> m_cells;
        std::size_t m_width { 0 }, m_height { 0 };
};
\end{cpp}

Note that you don’t refer to any type variable, such as T, in the specialization: you work directly with const char*s and strings. One obvious question at this point is why this class still has a template header. That is, what good is the following syntax?

\begin{cpp}
template <>
class Grid<const char*>
\end{cpp}

This syntax tells the compiler that this class is a const char* specialization of the Grid class template. Suppose that you didn’t use that syntax and just tried to write this:

\begin{cpp}
class Grid
\end{cpp}

The compiler wouldn’t let you do that because there is already a class template named Grid (the original class template). Only by specializing it can you reuse the name. The main benefit of specializations is that they can be invisible to the user. When a user creates a Grid of ints or SpreadsheetCells, the compiler generates code from the original Grid template. When the user creates a Grid of const char*s, the compiler uses the const char* specialization. This can all be “behind the scenes.”

The primary module interface file simply imports and exports both module interface partitions:

\begin{cpp}
export module grid;

export import :main;
export import :string;
\end{cpp}

The specialization can be tested as follows:

\begin{cpp}
Grid<int> myIntGrid; // Uses original Grid template.
Grid<const char*> stringGrid1 { 2, 2 }; // Uses const char* specialization.

const char* dummy { "dummy" };
stringGrid1.at(0, 0) = "hello";
stringGrid1.at(0, 1) = dummy;
stringGrid1.at(1, 0) = dummy;
stringGrid1.at(1, 1) = "there";

Grid<const char*> stringGrid2 { stringGrid1 };
\end{cpp}

When you specialize a class template, you don’t “inherit” any code; specializations are not like derivations. You must rewrite the entire implementation of the class. There is no requirement that you provide member functions with the same names or behavior. As an example, the const char* specialization of Grid implements the at() member functions by returning an optional<string>, not an optional<const char*>. As a matter of fact, you could write a completely different class with no relation to the original. Of course, that would abuse the template specialization ability, and you shouldn’t do it without good reason. Here are the implementations for the member functions of the const char* specialization. Unlike in the class template definition, you do not repeat the template header, template<>, before each member function definition.

\begin{cpp}
Grid<const char*>::Grid(std::size_t width, std::size_t height)
: m_width { width }, m_height { height }
{
    m_cells.resize(m_width * m_height);
}

void Grid<const char*>::verifyCoordinate(std::size_t x, std::size_t y) const
{
    if (x >= m_width) {
        throw std::out_of_range {
            std::format("x ({}) must be less than width ({}).", x, m_width) };
    }
    if (y >= m_height) {
        throw std::out_of_range {
            std::format("y ({}) must be less than height ({}).", y, m_height) };
    }
}

const std::optional<std::string>& Grid<const char*>::at(
std::size_t x, std::size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x + y * m_width];
}

std::optional<std::string>& Grid<const char*>::at(std::size_t x, std::size_t y)
{
    return const_cast<std::optional<std::string>&>(
    std::as_const(*this).at(x, y));
}
\end{cpp}

This section discussed how to use class template specialization to write a special implementation for a class template, with all template type parameters replaced with specific types. This is called full template specialization. Such a full class template specialization is no longer a class template itself but a class definition. Chapter 26, “Advanced Templates,” continues the discussion of class template specialization with a more advanced feature called partial specialization.

\mySubsubsection{12.2.7.}{Deriving from Class Templates}

You can inherit from class templates. If the derived class inherits from the template itself, it must be a template as well. Alternatively, you can derive from a specific instantiation of the class template, in which case your derived class does not need to be a template. As an example of the former, suppose you decide that the generic Grid class doesn’t provide enough functionality to use as a game board. Specifically, you would like to add a move() member function to the game board that moves a piece from one location on the board to another. Here is the class definition for the GameBoard template:

\begin{cpp}
import grid;

export template <typename T>
class GameBoard : public Grid<T>
{
    public:
        // Inherit constructors from Grid<T>.
        using Grid<T>::Grid;

        void move(std::size_t xSrc, std::size_t ySrc,
            std::size_t xDest, std::size_t yDest);
};
\end{cpp}

This GameBoard template derives from the Grid template and thereby inherits all its functionality. You don’t need to rewrite at(), getHeight(), or any of the other member functions. You also don’t need to add a copy constructor, operator=, or destructor, because you don’t have any dynamically allocated memory in GameBoard. Additionally, GameBoard explicitly inherits the constructors from the base class, Grid<T>. Inheriting constructors from base classes is explained in Chapter 10, “Discovering Inheritance Techniques.”

The inheritance syntax looks normal, except that the base class is Grid<T>, not Grid. The reason for this syntax is that the GameBoard template doesn’t really derive from the generic Grid template.

Rather, each instantiation of the GameBoard template for a specific type derives from the Grid instantiation for that same type. For example, if you instantiate a GameBoard with a ChessPiece type, then the compiler generates code for a Grid<ChessPiece> as well. The : public Grid<T> syntax says that this class inherits from whatever Grid instantiation makes sense for the T type parameter.

Here is the implementation of the move() member function:

\begin{cpp}
template <typename T>
void GameBoard<T>::move(std::size_t xSrc, std::size_t ySrc,
    std::size_t xDest, std::size_t yDest)
{
    Grid<T>::at(xDest, yDest) = std::move(Grid<T>::at(xSrc, ySrc));
    Grid<T>::at(xSrc, ySrc).reset(); // Reset source cell
    // Or:
    // this->at(xDest, yDest) = std::move(this->at(xSrc, ySrc));
    // this->at(xSrc, ySrc).reset();
}
\end{cpp}

\begin{myNotic}{NOTE}
Although some compilers don’t enforce it, the C++ name lookup rules require you to use the this pointer or Grid<T>:: to refer to data members and member functions in a base class template. Hence, we use Grid<T>::at() instead of just at().
\end{myNotic}

You can use the GameBoard template as follows:

\begin{cpp}
GameBoard<ChessPiece> chessboard { 8, 8 };
ChessPiece pawn;
chessBoard.at(0, 0) = pawn;
chessBoard.move(0, 0, 0, 1);
\end{cpp}

\begin{myNotic}{NOTE}
Of course, if you want to override member functions from Grid, you will have to mark them virtual in the Grid class template.
\end{myNotic}

\mySubsubsection{12.2.8.}{Inheritance vs. Specialization}

Some programmers find the distinction between template inheritance and template specialization confusing. The following table summarizes the differences:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
&
\textbf{INHERITANCE} &
\textbf{SPECIALIZATION} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Reuses code?} &
\begin{tabular}[c]{@{}l@{}}Yes: Derived classes contain all base\\ class data members and member\\ functions.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}No: You must rewrite\\ all required code in the\\ specialization.\end{tabular} \\ \hline
\textbf{Reuses name?} &
\begin{tabular}[c]{@{}l@{}}No: The derived class name must be\\ different from the base class name.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Yes: The specialization must\\ have the same name as\\ the original.\end{tabular} \\ \hline
\textbf{\begin{tabular}[c]{@{}l@{}}Supports\\ polymorphism?\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}Yes: Objects of the derived class can\\ stand in for objects of the base class.\end{tabular} &
\begin{tabular}[c]{@{}l@{}}No: Each instantiation of\\ a template for a type is a\\ different type.\end{tabular} \\ \hline
\end{longtable}

\begin{myNotic}{NOTE}
Use inheritance for extending implementations and for polymorphism. Use specialization for customizing implementations for particular types.
\end{myNotic}

\mySubsubsection{12.2.9.}{Alias Templates}

Chapter 1 introduces the concept of type aliases and typedefs. They allow you to give other names to specific types. To refresh your memory, you could, for example, write the following type alias to give a second name to type int:

\begin{cpp}
using MyInt = int;
\end{cpp}

Similarly, you can use a type alias to give another name to a class template. Suppose you have the following class template:

\begin{cpp}
template <typename T1, typename T2>
class MyClassTemplate { /* ... */ };
\end{cpp}

You can define the following type alias in which you specify both class template type parameters:

\begin{cpp}
using OtherName = MyClassTemplate<int, double>;
\end{cpp}

A typedef can also be used instead of such a type alias.

Additionally, it’s also possible to specify only some of the types and keep the other types as template type parameters. This is called an alias template. Here’s an example:

\begin{cpp}
template <typename T1>
using OtherName = MyClassTemplate<T1, double>;
\end{cpp}

This is something you cannot do with a typedef.











The stream metaphor takes a bit of getting used to. At first, streams may seem more complex than traditional C-style I/O, such as printf(). In reality, they seem complicated initially only because there is a deeper metaphor behind streams than there is behind printf(). Don’t worry, though: after a few examples, everything will be clear.

\mySubsubsection{13.1.1.}{What Is a Stream, Anyway?}

Chapter 1, “A Crash Course in C++ and the Standard Library,” compares the cout stream to a laundry chute for data. You throw some variables down the stream, and they are written to the user’s screen, or console. More generally, all streams can be viewed as data chutes. Streams vary in their direction and their associated source or destination. For example, the cout stream that you are already familiar with is an output stream, so its direction is “out.” It writes data to the console, so its associated destination is “console.” The c in cout does not stand for “console” as you might expect but stands for “character” as it’s a character-based stream. There is another standard stream called cin that accepts input from the user. Its direction is “in,” and its associated source is “console.” As with cout, the c in cin stands for “character.” Both cout and cin are predefined instances of streams available in the std namespace. The following table gives a brief description of all predefined streams defined in <iostream>.

Streams can be buffered or unbuffered. The difference between them is that a buffered stream does not immediately send the data to the destination. Instead, it buffers, that is collects, incoming data and then sends it in blocks. An unbuffered stream, on the other hand, immediately sends the data to the destination. Buffering is usually done to improve performance, as certain destinations, such as files, perform better when writing bigger blocks at once. Note that you can always force a buffered stream to send all its currently buffered data to the destination by flushing its buffer using the flush() member function. Buffering and flushing is discussed in a bit more detail later in this chapter.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{STREAM} & \textbf{DESCRIPTION}                                          \\ \hline
\endfirsthead
%
\endhead
%
cin             & An input stream, reads data from the “input console”          \\ \hline
cout            & A buffered output stream, writes data to the “output console” \\ \hline
cerr & \begin{tabular}[c]{@{}l@{}}An unbuffered output stream, writes data to the “error console,” which is often the\\ same as the “output console”\end{tabular} \\ \hline
clog            & A buffered version of cerr                                    \\ \hline
\end{longtable}

Remember from Chapter 1 that std::print() and println() by default print to cout but that you can pass a stream as first argument to these functions if you want to print to a different stream, for example:

\begin{cpp}
println(cerr, "This is an error printed to cerr.");
\end{cpp}

There are also wide-character, wchar\_t versions available of these streams that have names starting with w: wcin, wcout, wcerr, and wclog. Wide characters can be used to work with languages that have more characters than, for example, English, such as Chinese. Wide characters are discussed in Chapter 21, “String Localization and Regular Expressions.”

\begin{myNotic}{NOTE}
Every input stream has an associated source. Every output stream has an associated destination.
\end{myNotic}

Another important aspect of streams is that they include data but also have a current position. The current position is the position in the stream where the next read or write operation will take place.

\begin{myNotic}{NOTE}
Graphical user interface applications normally do not have a console; that is, if you write something to cout, the user will not see it. If you are writing a library, you should never assume the existence of cout, cin, cerr, or clog because you never know whether your library will be used in a console or a GUI application.
\end{myNotic}

\mySubsubsection{13.1.2.}{Stream Sources and Destinations}

Streams as a concept can be applied to any object that accepts data or emits data. You could write a stream-based network class or stream-based access to a Musical Instrument Digital Interface (MIDI) instrument. In C++, there are four common sources and destinations for streams: consoles, files, strings, and fixed buffer arrays. Fixed buffer array support is introduced with C++23.

You have already seen many examples of user, or console, streams. Console input streams make programs interactive by allowing input from the user at run time. Console output streams provide feedback to the user and output results.

File streams, as the name implies, read data from and write data to a filesystem. File input streams are useful for reading configuration data and saved files or for batch processing file-based data. File output streams are useful for saving state and providing output. If you are familiar with C-style input and output, then file streams subsume the functionality of the C functions fprintf(), fwrite(), and fputs() for output, and fscanf(), fread(), and fgets() for input. As these C-style functions are not recommended in C++, they are not further discussed.

String streams are an application of the stream metaphor to the string type. With a string stream, you can treat character data just as you would treat any other stream. For the most part, this is merely a handy syntax for functionality that could be handled through member functions on the string class. However, using stream syntax provides opportunities for optimization and can be far more convenient and more efficient than direct use of the string class. String streams subsume the functionality of sprintf(), sprintf\_s(), sscanf(), and other forms of C-style string-formatting functions, not further discussed in this C++ book.

The streams working with fixed buffer arrays allow you to use the stream metaphor on any block of memory, independently of how memory for that buffer was allocated.

The rest of this section deals with console streams (cin and cout). Examples of file, string, and fixed buffer array streams are provided later in this chapter. Other types of streams, such as printer output or network I/O, are often platform dependent, so they are not covered in this book.

\mySubsubsection{13.1.3.}{Output with Streams}

Output using streams is introduced in Chapter 1. This section briefly revisits some of the basics and introduces material that is more advanced.

\mySamllsection{Output Basics}

Output streams are defined in <ostream>. There is also <iostream>, which in turn includes the functionality for both input streams and output streams. <iostream> also declares all predefined stream instances: cout, cin, cerr, clog, and the wide versions.

The <{}< operator is the simplest way to use output streams. C++ basic types, such as ints, pointers, doubles, and characters, can be output using <{}<. In addition, the C++ string class is compatible with <{}<, and C-style strings are properly output as well. The following are some examples of using <{}<:

\begin{cpp}
int i { 7 };
cout << i << endl;

char ch { 'a' };
cout << ch << endl;

string myString { "Hello World." };
cout << myString << endl;
\end{cpp}

The output is as follows:

\begin{shell}
7
a
Hello World.
\end{shell}

The cout stream is the built-in stream for writing to the console, or standard output. You can “chain” uses of <{}< together to output multiple pieces of data. This is because operator<{}< returns a reference to the stream as its result, so you can immediately use <{}< again on the same stream. Here is an example:

\begin{cpp}
int j { 11 };
cout << "The value of j is " << j << "!" << endl;
\end{cpp}

The output is as follows:

\begin{shell}
The value of j is 11!
\end{shell}

C++ streams correctly parse C-style escape sequences, such as strings that contain \verb|\|n. You can also use std::endl to start a new line. The difference between using \verb|\|n and endl is that \verb|\|n just starts a new line while endl also flushes the buffer. Watch out with endl because too many flushes might hurt performance. The following example uses endl to output and flush several lines of text with just one line of code:

\begin{cpp}
cout << "Line 1" << endl << "Line 2" << endl << "Line 3" << endl;
\end{cpp}

The output is as follows:

\begin{shell}
Line 1
Line 2
Line 3
\end{shell}

\begin{myWarning}{WARNING}
 endl flushes the destination buffer, so use it judiciously in performance critical code, such as tight loops.
\end{myWarning}

\mySamllsection{Member Functions of Output Streams}

The <{}< operator is, without a doubt, the most useful part of output streams. However, there is additional functionality to be explored. If you look through the contents of <ostream>, you’ll see many lines of overloaded definitions of the <{}< operator to support outputting all kinds of different data types. You’ll also find some useful public member functions.

\mySamllsection{put() and write()}

put() and write() are raw output member functions. Instead of taking an object or variable that has some defined behavior for output, put() accepts a single character, while write() accepts a character array. The data passed to these member functions is output as is, without any special formatting or processing. For example, the following code snippet shows how to output a C-style string to the console without using the <{}< operator:

\begin{cpp}
const char* test { "hello there" };
cout.write(test, strlen(test));
\end{cpp}

The next snippet shows how to write a single character to the console by using the put() member function:

\begin{cpp}
cout.put('a');
\end{cpp}

\mySamllsection{flush()}

When you write to an output stream, the stream does not necessarily write the data to its destination right away. Most output streams buffer, or accumulate, data instead of writing it out as soon as it comes in. This is usually done to improve performance. Certain stream destinations, such as files, are much more performant if data is written in larger blocks, instead of, for example, character by character. The stream flushes, or writes out, the accumulated data, when one of the following conditions occurs:

\begin{itemize}
\item
An endl manipulator is encountered.

\item
The stream goes out of scope and is destructed.

\item
The stream buffer is full.

\item
You explicitly tell the stream to flush its buffer.

\item
Input is requested from a corresponding input stream (that is, when you make use of cin for input, cout will flush). In the section “File Streams,” you will learn how to establish this type of link.
\end{itemize}

One way to explicitly tell a stream to flush is to call its flush() member function, as in the following code:

\begin{cpp}
cout << "abc";
cout.flush(); // abc is written to the console.
cout << "def";
cout << endl; // def is written to the console.
\end{cpp}

\begin{myNotic}{NOTE}
Not all output streams are buffered. The cerr stream, for example, does not buffer its output.
\end{myNotic}

\mySamllsection{Handling Output Errors}

Output errors can arise in a variety of situations. Perhaps you are trying to open a non-existing file. Maybe a disk error has prevented a write operation from succeeding, for example, because the disk is full. None of the streams’ code you have seen up until this point has considered these possibilities, mainly for brevity. However, it is vital that you address any error conditions that occur.

When a stream is in its normal usable state, it is said to be “good.” The good() member function can be called directly on a stream to determine whether the stream is currently good:

\begin{cpp}
if (cout.good()) {
    cout << "All good" << endl;
}
\end{cpp}

good() provides an easy way to obtain basic information about the validity of the stream, but it does not tell you why the stream is unusable. There is a member function called bad() that provides a bit more information. If bad() returns true, it means that a fatal error has occurred (as opposed to any nonfatal condition like end-of-file, eof()). Another member function, fail(), returns true if the most recent operation has failed; however, it doesn’t say anything about the next operation, which can either succeed or fail as well. For example, after calling flush() on an output stream, you could call fail() to make sure the flush was successful:

\begin{cpp}
cout.flush();
if (cout.fail()) {
    cerr << "Unable to flush to standard out" << endl;
}
\end{cpp}

Streams have a conversion operator to convert to type bool. This conversion operator returns the same as calling !fail(). So, the previous code snippet can be rewritten as follows:

\begin{cpp}
cout.flush();
if (!cout) {
    cerr << "Unable to flush to standard out" << endl;
}
\end{cpp}

Important to know is that both good() and fail() return false if the end-of-file is reached. The relation is as follows: good() == (!fail() \&\& !eof()).

You can also tell the streams to throw exceptions when a failure occurs. You then write a catch handler to catch ios\_base::failure exceptions, on which you can use the what() member function to get a description of the error, and the code() member function to get the error code. However, whether or not you get useful information depends on the Standard Library implementation that you use.

\begin{cpp}
cout.exceptions(ios::failbit | ios::badbit | ios::eofbit);
try {
    cout << "Hello World." << endl;
} catch (const ios_base::failure& ex) {
    cerr << "Caught exception: " << ex.what()
    << ", error code = " << ex.code() << endl;
}
\end{cpp}

To reset the error state of a stream, use clear():

\begin{cpp}
cout.clear();
\end{cpp}

Error checking is performed less frequently for console output streams than for file output or input streams. The member functions discussed here apply for other types of streams as well and are revisited later as each type is discussed.


\mySamllsection{Output Manipulators}

One of the unusual features of streams is that you can throw more than just data down the chute. C++ streams also recognize manipulators, objects that make a change to the behavior of the stream instead of, or in addition to, providing data for the stream to work with.

You have already seen one manipulator: endl. The endl manipulator encapsulates data and behavior. It tells the stream to output an end-of-line sequence and to flush its buffer. The following is a non-exhaustive list of some other useful manipulators, many of which are defined in <ios> and <iomanip>. An example after this list shows how to use them:

\begin{itemize}
\item
boolalpha and noboolalpha: Tells the stream to output bool values as true and false (boolalpha) or 1 and 0 (noboolalpha). The default is noboolalpha.

\item
hex, oct, and dec: Outputs numbers in hexadecimal, octal, and base 10, respectively.

\item
fixed, scientific, and defaultfloat: Outputs fractional numbers using fixed, scientific, or default formatting, respectively.

\item
setprecision: Sets the number of decimal places that are output for fractional numbers using fixed or scientific formatting, or else the total number of digits to output. This is a parameterized manipulator (meaning that it takes an argument).

\item
setw: Sets the field width for outputting data. This is a parameterized manipulator.

\item
setfill: Sets a character as the new fill character for the stream. The fill character pads output according to the width set by setw. This is a parameterized manipulator.

\item
showpoint and noshowpoint: Forces the stream to always or never show the decimal point for floating-point numbers with no fractional part.

\item
put\_money: A parameterized manipulator that writes a formatted monetary value to a stream.

\item
put\_time: A parameterized manipulator that writes a formatted time to a stream.

\item
quoted: A parameterized manipulator that encloses a given string with quotes and escapes embedded quotes.
\end{itemize}

All of these manipulators stay in effect for subsequent output to the stream until they are reset, except setw, which is active for only the next single output. The following example uses several of these manipulators to customize its output:

\begin{cpp}
// Boolean values
bool myBool { true };
cout << "This is the default: " << myBool << endl;
cout << "This should be true: " << boolalpha << myBool << endl;
cout << "This should be 1: " << noboolalpha << myBool << endl;

// Simulate println-style "{:6}" with streams
int i { 123 };
println("This should be ' 123': {:6}", i);
cout << "This should be ' 123': " << setw(6) << i << endl;

// Simulate println-style "{:0>6}" with streams
println("This should be '000123': {:0>6}", i);
cout << "This should be '000123': " << setfill('0') << setw(6) << i << endl;

// Fill with *
cout << "This should be '***123': " << setfill('*') << setw(6) << i << endl;
// Reset fill character
cout << setfill(' ');

// Floating-point values
double dbl { 1.452 };
double dbl2 { 5 };
cout << "This should be ' 5': " << setw(2) << noshowpoint << dbl2 << endl;
cout << "This should be @@1.452: " << setw(7) << setfill('@') << dbl << endl;
// Reset fill character
cout << setfill(' ');

// Instructs cout to start formatting numbers according to your location.
// Chapter 21 explains the details of the imbue() call and the locale object.
cout.imbue(locale { "" });

// Format numbers according to your location
cout << "This is 1234567 formatted according to your location: " << 1234567
     << endl;

// Monetary value. What exactly a monetary value means depends on your
// location. For example, in the USA, a monetary value of 120000 means 120000
// dollar cents, which is 1200.00 dollars.
cout << "This should be a monetary value of 120000, "
     << "formatted according to your location: "
     << put_money("120000") << endl;

// Date and time
time_t t_t { time(nullptr) }; // Get current system time.
tm t { *localtime(&t_t) }; // Convert to local time.
cout << "This should be the current date and time "
     << "formatted according to your location: "
     << put_time(&t, "%c") << endl;

// Quoted string
cout << "This should be: \"Quoted string with \\\"embedded quotes\\\".\": "
     << quoted("Quoted string with \"embedded quotes\".") << endl;
\end{cpp}

\begin{myNotic}{NOTE}
With Microsoft Visual C++, this example might give you a security-related error or warning on the call to localtime(). You can either switch to using localtime\_s() or temporarily disable this warning using a \#pragma. See the downloadable source code archive.
\end{myNotic}

If you don’t care for the concept of manipulators, you can usually get by without them. Streams provide much of the same functionality through equivalent member functions like precision(). For example, take the following line:

\begin{cpp}
cout << "This should be '1.2346': " << setprecision(5) << 1.23456789 << endl;
\end{cpp}

This can be converted to use a member function call as follows. The advantage of the member function calls is that they return the previous value, allowing you to restore it, if needed.

\begin{cpp}
cout.precision(5);
cout << "This should be '1.2346': " << 1.23456789 << endl;
\end{cpp}

For a detailed description of all stream member functions and manipulators, consult your favorite Standard Library Reference.

\mySubsubsection{13.1.4.}{Input with Streams}

Input streams provide a simple way to read in structured or unstructured data. In this section, the techniques for input are discussed within the context of cin, the console input stream.

\mySamllsection{Input Basics}

There are two easy ways to read data by using an input stream. The first is an analog of the <{}< operator that outputs data to an output stream. The corresponding operator for reading data is >{}>. When you use >{}> to read data from an input stream, the variable you provide is the storage for the received value. For example, the following program reads one word from the user and puts it into a string. Then the string is output back to the console:

\begin{cpp}
string userInput;
cin >> userInput;
println("User input was {}.", userInput);
\end{cpp}

By default, the >{}> operator tokenizes values according to whitespace. For example, if a user runs the previous program and enters hello there as input, only the characters up to the first whitespace character (the space character in this instance) are captured into the userInput variable. The output would be as follows:

\begin{shell}
User input was hello.
\end{shell}

One solution to include whitespace in the input is to use get(), which is discussed later in this chapter.

\begin{myNotic}{NOTE}
Whitespace characters in C++ are space (' '), form feed ('\verb|\|f'), line feed ('\verb|\|n'), carriage return ('\verb|\|r'), horizontal tab ('\verb|\|t'), and vertical tab ('\verb|\|v').
\end{myNotic}

The >{}> operator works with different variable types, just like the <{}< operator. For example, to read an integer, the code differs only in the type of the variable:

\begin{cpp}
int userInput;
cin >> userInput;
println("User input was {}.", userInput);
\end{cpp}

You can use input streams to read in multiple values, mixing and matching types as necessary. For example, the following function, an excerpt from a restaurant reservation system, asks the user for a last name and the number of people in their party:

\begin{cpp}
void getReservationData()
{
    string guestName;
    int partySize;
    print("Name and number of guests: ");
    cin >> guestName >> partySize;
    println("Thank you, {}.", guestName);
    if (partySize > 10) {
        println("An extra gratuity will apply.");
    }
}
\end{cpp}

Remember that the >{}> operator tokenizes values according to whitespace, so getReservationData() does not allow you to enter a name with whitespace. A solution using unget() is discussed later in this chapter. Note also that the first use of cout does not explicitly flush the buffer using endl or flush(), but still, the text will be written to the console because the use of cin immediately flushes the cout buffer; they are linked together in this way.

\begin{myNotic}{NOTE}
If you get confused between <{}< and >{}>, just think of the angles as pointing toward their destination. In an output stream, <{}< points toward the stream itself because data is being sent to the stream. In an input stream, >{}> points toward the variables because data is being stored.
\end{myNotic}

\mySamllsection{Handling Input Errors}

Input streams have a number of member functions to detect unusual circumstances. Most of the error conditions related to input streams occur when there is no data available to read. For example, the end of the stream (referred to as end-of-file, even for non–file streams) may have been reached. The most common way of querying the state of an input stream is to access it within a conditional statement. For example, the following loop keeps looping as long as cin remains in a good state. This pattern takes advantage of the fact that evaluating an input stream within a conditional context results in true only if the stream is not in any error state. Encountering an error causes the stream to evaluate to false. The underlying details of the conversion operations required to implement such behavior are explained in Chapter 15, “Overloading C++ Operators.”

\begin{cpp}
while (cin) { ... }
\end{cpp}

You can input data at the same time:

\begin{cpp}
while (cin >> ch) { ... }
\end{cpp}

The good(), bad(), and fail() member functions can be called on input streams, just as on output streams. There is also an eof() member function that returns true if the stream has reached its end. Similar as for output streams, both good() and fail() return false if the end-of-file is reached. The relation is again as follows: good() == (!fail() \&\& !eof()).

You should get into the habit of checking the stream state after reading data so that you can recover from bad input.

The following program shows a common pattern for reading data from a stream and handling errors. The program reads numbers from standard input and displays their sum once end-of-file is reached. Note that in command-line environments, the end-of-file is indicated by the user typing a particular character. In Unix and Linux, it is Control+D; in Windows it is Control+Z, both followed by Enter. The exact character is operating-system dependent, so you will need to know what your operating system requires.

\begin{cpp}
println("Enter numbers on separate lines to add.");
println("Use Control+D followed by Enter to finish (Control+Z in Windows).");
int sum { 0 };

if (!cin.good()) {
    println(cerr, "Standard input is in a bad state!");
    return 1;
}

while (!cin.bad()) {
    int number;
    cin >> number;
    if (cin.good()) {
        sum += number;
    } else if (cin.eof()) {
        break; // Reached end-of-file.
    } else if (cin.fail()) {
        // Failure!
        cin.clear(); // Clear the failure state.
        string badToken;
        cin >> badToken; // Consume the bad input.
        println(cerr, "WARNING: Bad input encountered: {}", badToken);
    }
}
println("The sum is {}.", sum);
\end{cpp}

Here is some example output of this program. The \^{}Z characters in the output appear when Control+Z is pressed.

\begin{shell}
Enter numbers on separate lines to add.
Use Control+D followed by Enter to finish (Control+Z in Windows).
12
test
WARNING: Bad input encountered: test
3
^Z
The sum is 6.
\end{shell}

\mySamllsection{Input Member Functions}

Just like output streams, input streams have several member functions that allow a lower level of access than the functionality provided by the more common >> operator.

\mySamllsection{get()}

The get() member function allows raw input of data from a stream. The simplest version of get() returns the next character in the stream, though other versions exist that read multiple characters at once. get() is most commonly used to avoid the automatic tokenization that occurs with the >{}> operator. For example, the following function reads a name, which can be made up of several words, from an input stream until the end of the stream is reached:

\begin{cpp}
string readName(istream& stream)
{
    string name;
    while (stream) { // Or: while (!stream.fail()) {
        int next { stream.get() };
        if (!stream || next == std::char_traits<char>::eof())
        break;
        name += static_cast<char>(next);// Append character.
    }
    return name;
}
\end{cpp}

There are several interesting observations to make about this readName() function:

\begin{itemize}
\item
Its parameter is a reference-to-non-const to an istream, not a reference-to-const. The member functions that read in data from a stream will change the actual stream (most notably, its position), so they are not const member functions. Thus, you cannot call them on a reference-to-const.

\item
The return value of get() is stored in an int, not in a char, because get() can return special non-character values such as std::char\_traits<char>::eof() (end-of-file).

\item
Newline and other escape characters that are read by get() will appear in the string returned by readName(). If the Ctrl+D or Ctrl+Z isn’t done at the beginning of a line, they too will appear in the returned string.
\end{itemize}

readName() is a bit strange because there are two ways to get out of the loop: either the stream can get into a failed state or the end of the stream is reached. A more common pattern for reading from a stream uses a different version of get() that takes a reference to a character and returns a reference to the stream. Evaluating an input stream within a conditional context results in true only if the stream is not in any error state. The following version of the same function is a bit more concise:

\begin{cpp}
string readName(istream& stream)
{
    string name;
    char next;
    while (stream.get(next)) {
        name += next;
    }
    return name;
}
\end{cpp}

\mySamllsection{unget()}

For most purposes, the correct way to think of an input stream is as a one-way chute. Data falls down the chute and into variables. The unget() member function breaks this model in a way by allowing you to push data back up the chute.

A call to unget() causes the stream to back up by one position, essentially putting the previous character read back on the stream. You can use the fail() member function to see whether unget() was successful or not. For example, unget() can fail if the current position is at the beginning of the stream.

The getReservationData() function shown earlier in this chapter did not allow you to enter a name with whitespace. The following code uses unget() to allow whitespace in the name. The code reads character by character and checks whether the character is a digit or not. If the character is not a digit, it is added to guestName. If it is a digit, the character is put back into the stream using unget(), the loop is stopped, and the >> operator is used to input an integer, partySize. The noskipws input manipulator tells the stream not to skip whitespace; that is, whitespace is read like any other characters.

\begin{cpp}
void getReservationData()
{
    print("Name and number of guests: ");
    string guestName;
    int partySize { 0 };
    // Read characters until we find a digit
    char ch;
    cin >> noskipws;
    while (cin >> ch) {
        if (isdigit(ch)) {
            cin.unget();
            if (cin.fail()) { println(cerr, "unget() failed."); }
            break;
        }
        guestName += ch;
    }
    // Read partySize, if the stream is not in error state
    if (cin) { cin >> partySize; }
    if (!cin) {
        println(cerr, "Error getting party size.");
        return;
    }

    println("Thank you '{}', party of {}.", guestName, partySize);
    if (partySize > 10) {
        println("An extra gratuity will apply.");
    }
}
\end{cpp}


\mySamllsection{putback()}

The putback() member function, like unget(), lets you move backward by one character in an input stream. The difference is that putback() takes the character being placed back on the stream as a parameter. Here is an example:

\begin{cpp}
char c;
cin >> c;
println("Retrieved {}.", c);

cin.putback('e'); // 'e' will be the next character read off the stream.
println("Called putback('e').");

while (cin >> c) { println("Retrieved {}.", c); }
\end{cpp}

The output can be as follows:

\begin{shell}
wow
Retrieved w.
Called putback('e').
Retrieved e.
Retrieved o.
Retrieved w.
\end{shell}

\mySamllsection{peek()}

The peek() member function allows you to preview the next value that would be returned if you were to call get(). To take the chute metaphor perhaps a bit too far, you could think of it as looking up the chute without a value actually falling down it.

peek() is ideal for any situation where you need to look ahead before reading a value. For example, the following code implements getReservationData() that allows whitespace in the name, but uses peek() instead of unget():

\begin{cpp}
void getReservationData()
{
    print("Name and number of guests: ");
    string guestName;
    int partySize { 0 };
    // Read characters until we find a digit.
    cin >> noskipws;
    while (true) {
        // 'peek' at next character.
        char ch { static_cast<char>(cin.peek()) };
        if (!cin) { break; }
        if (isdigit(ch)) {
            // Next character will be a digit, so stop the loop.
            break;
        }
        // Next character will be a non-digit, so read it.
        cin >> ch;
        if (!cin) { break; }
        guestName += ch;
    }
    // Read partySize, if the stream is not in error state.
    if (cin) { cin >> partySize; }
    if (!cin) {
        println(cerr, "Error getting party size.");
        return;
    }

    println("Thank you '{}', party of {}.", guestName, partySize);
    if (partySize > 10) {
        println("An extra gratuity will apply.");
    }
}
\end{cpp}

\mySamllsection{getline()}

Obtaining a single line of data from an input stream is so common that a member function exists to do it for you. The getline() member function fills a character buffer with a line of data up to the specified size. This specified size includes the \verb|\|0 character. Thus, the following code reads a maximum of BufferSize-1 characters from cin or until an end-of-line sequence is read:

\begin{cpp}
char buffer[BufferSize] { 0 };
cin.getline(buffer, BufferSize);
\end{cpp}

When getline() is called, it reads a line from the input stream, up to and including the end-of-line sequence. However, the end-of-line character or characters do not appear in the string. Note that the end-of-line sequence is platform dependent. For example, it can be \verb|\|r\verb|\|n, \verb|\|n, or \verb|\|n\verb|\|r.

There is a form of get() that performs the same operation as getline(), except that it leaves the newline sequence in the input stream.

There is also a non-member function called std::getline() that can be used with C++ strings. It is defined in <string> and is in the std namespace. It takes a stream and a string reference. The advantage of using this version of getline() is that it doesn’t require you to specify the size of any buffer.

\begin{cpp}
string myString;
getline(cin, myString);
\end{cpp}

Both the getline() member function and the std::getline() function accept an optional delimiter as last parameter. The default delimiter is \verb|\|n. By changing this delimiter, these functions can be used to read in multiple lines of text until a given delimiter is reached. For example, the following code reads in multiple lines of text until it reads an @ character:

\begin{cpp}
print("Enter multiple lines of text. "
      "Use an @ character to signal the end of the text.\n> ");
string myString;
getline(cin, myString, '@');
println("Read text: \"{}\"", myString);
\end{cpp}

Here is a possible output:

\begin{shell}
Enter multiple lines of text. Use an @ character to signal the end of the text.
> This is some
text on multiple
lines.@
Read text: "This is some
text on multiple
lines."
\end{shell}


\mySamllsection{Input Manipulators}

Just as for output streams, input streams support a number of input manipulators. You’ve already seen one, noskipws, which tells an input stream not to skip any whitespace characters. The following list shows other built-in input manipulators available to you that allow you to customize the way data is read:

\begin{itemize}
\item
boolalpha and noboolalpha: If boolalpha is used, the string false will be interpreted as the Boolean value false; anything else will be treated as the Boolean value true. If noboolalpha is set, zero will be interpreted as false, anything else as true. The default is noboolalpha.

\item
dec, hex, and oct: Reads numbers in decimal base 10, hexadecimal, or octal notation, respectively. For example, the decimal base 10 number 207 is cf in hexadecimal, and 317 in octal notation.

\item
skipws and noskipws: Tells the stream to either skip whitespace when tokenizing or to read in whitespace as its own token. The default is skipws.

\item
ws: A handy manipulator that simply skips over the current series of whitespace at the current position in the stream.

\item
get\_money: A parameterized manipulator that reads a monetary value from a stream.

\item
get\_time: A parameterized manipulator that reads a formatted time from a stream.

\item
quoted: A parameterized manipulator that reads a string enclosed with quotes and in which embedded quotes are escaped. An example of this manipulator is shown later in this chapter.
\end{itemize}

Input is locale aware. For example, the following code enables your system locale for cin. Locales are discussed in Chapter 21:

\begin{cpp}
cin.imbue(locale { "" });
int i;
cin >> i;
\end{cpp}

If your system locale is U.S. English, you can enter 1,000 and it will be parsed as 1000. If you enter 1.000, it will be parsed as 1. On the other hand, if your system locale is Dutch Belgium, you can enter 1.000 to get the value of 1000, but entering 1,000 will result in 1. In both cases, you can also just enter 1000 without any digit separators to get the value 1000.

\mySubsubsection{13.1.5.}{Input and Output with Objects}



\mySubsubsection{13.1.6.}{Custom Manipulators}

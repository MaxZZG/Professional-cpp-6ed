
As one of the most arcane parts of C++, templates are a good way for interviewers to separate the C++ novices from the pros. While most interviewers will forgive you for not remembering some of the advanced template syntax, you should go into an interview knowing the basics.

\mySubsubsection{A.11.1.}{Things to Remember}

\begin{itemize}
\item
How to use a class or function template

\item
How to write a simple class or function template

\item
The abbreviated function template syntax

\item
Function template argument deduction

\item
Class template argument deduction (CTAD)

\item
Alias templates and why using is better than typedef

\item
The ideas behind concepts, and their basic use

\item
What variadic templates and fold-expressions are

\item
The ideas behind template metaprogramming

\item
Type traits and what they can be used for
\end{itemize}

\mySubsubsection{A.11.2.}{Types of Questions}

Many interview questions start out with a simple problem and gradually add complexity. Often, interviewers have an endless amount of complexity that they are prepared to add, and they simply want to see how far you get. For example, an interviewer might begin a problem by asking you to create a class that provides sequential access to a fixed number of ints. Next, the class will need to grow to accommodate an arbitrary number of elements. Then, it will need to work with arbitrary data types, which is where templates come in. From there, the interviewer could take the problem in a number of directions, asking you to use operator overloading to provide array-like syntax or continuing down the template path by asking you to provide a default type for the template type parameters or to put type constraints on them. However, most interviewers understand that the template syntax can be difficult and will forgive you for syntactical errors.

The interviewer might ask you high-level questions related to template metaprogramming to find out whether you have heard about it. While explaining, you could give a small example such as calculating the factorial of a number at compile time. Donâ€™t worry if the syntax is not entirely correct. As long as you explain what it is supposed to do, you should be fine.










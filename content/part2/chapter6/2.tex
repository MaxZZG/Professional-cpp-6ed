
可重用代码的两个主要目标：

\begin{itemize}
\item
首先，是通用性，可以在不同的应用程序域中使用。具有特定场景的应用程序组件，难以在其他程序中重用。

\item
其次，可重用代码也易于使用，不需要花费大量时间来理解其接口或功能。开发者能够轻松地将它整合到自己的应用程序中。
\end{itemize}

向客户交付库的方式也很重要。可以以源代码形式交付，客户只需将源代码整合到他们的项目中。另一种选择是以静态库的形式交付二进制文件，他们将这些库链接到他们的应用程序中，或者以动态链接库 (.dll) 的形式交付给 Windows 客户，或者以共享对象 (.so) 的形式交付给 Linux 客户。这些交付机制中的每一种都可能对设计可重用代码的方式有一些限制。

\begin{myNotic}{NOTE}
本章使用术语“客户”来指代使用接口的开发者。不要将“客户”与运行程序的用户混淆。本章还会使用短语“客户代码”来指代使用接口的代码。
\end{myNotic}

而设计可重用代码的最重要策略是抽象。

\mySubsubsection{6.2.1.}{抽象}

抽象的关键是有效地将接口与实现分离。实现是编写的代码，用于完成任务，接口是其他人使用你的代码的方式。在 C 中，描述库中函数的头文件是一个接口。在面向对象编程中，公共可访问的类成员函数和类属性集合是类的接口。然而，好的接口应该只包含公共成员函数。类的属性永远不应该公开，但可以通过公共成员函数（也称为 getter 和 setter）获取。

第 4 章介绍了抽象原则，并通过电视机的类比，展示了可以通过其接口使用电视，而无需了解其内部工作原理。同样，当设计代码时，应该清楚地分离接口和实现。这种分离使得代码更易于使用，主要是因为客户端不需要了解内部实现细节。

使用抽象对客户也有好处，因为他们不需要了解实现细节，就可以利用提供的功能。对于设计者也有好处，可以修改底层代码，而无需改变代码的接口。因此，可以提供升级和修复补丁，而不需要客户更改其使用方式。对于动态链接库，客户甚至可能不需要重新构建他们的可执行文件。因为作为库编写者，可以明确指定接口中期望的交互和提供支持的功能。清晰的接口和实现分离将防止客户以未预期的方法使用库，否则可能会导致意外的行为和错误。

\begin{myWarning}{WARNING}
设计接口时，不要向客户暴露实现细节。
\end{myWarning}

有时库需要客户端代码将从接口返回的信息保留下来，以便传递给另一个接口。这种信息有时称为句柄，通常用于在调用之间记住特定实例的状态。例如OpenGL，一个 2D/3D 渲染库。OpenGL 的许多函数返回和处理句柄，由类型 GLuint 表示。例如，如果使用 OpenGL 函数 glGenBuffers() 来创建一个缓冲区，会将缓冲区作为 GLuint 句柄返回。无论何时想调用另一个函数来对那个缓冲区执行某些操作，都必须将 GLuint 句柄传递给那个函数。

如果库设计需要一个句柄，不要暴露其内部细节。将这个句柄变成一个不透明的类，开发者不能直接访问也不可以通过公共的 getter 或 setter 访问内部数据成员。不要要求客户端代码修改这个句柄内部的变量。一个糟糕设计的例子是要求在一个所谓的不可见句柄中设置一个特定结构成员，以打开错误日志。

\begin{myNotic}{NOTE}
不幸的是，C++ 在编写类时就不友好于良好的抽象原则。语法要求公共接口和非公共（私有或受保护）数据成员和成员函数组合在一起，在一个类定义中，会向客户端暴露了类的某些内部实现细节。第 9 章描述了一些技术，以绕过这一点，以提供干净的接口。
\end{myNotic}

抽象是如此重要，以至于应该指导整个设计。在做的每一个决定中，都要问自己选择是否符合抽象原则。站在客户的立场上，确定是否在接口中要求了解内部实现。

使用抽象设计可重用代码时，应该关注以下几点：

\begin{itemize}
\item
首先，必须正确地组织代码。将使用哪种类层次结构？使用模板吗？如何将代码划分为子系统？

\item
其次，必须设计接口。
\end{itemize}

这两个主题将在接下来的部分中讨论。

\mySubsubsection{6.2.2.}{重用结构化代码}

必须在设计的所有层面上考虑重用，从单个函数、类，到整个库和框架，所有这些不同的层面都称为组件。以下策略将帮助你正确地组织代码，所有策略都集中在代码的通用性上。设计可重用代码的第二个方面，即提供易用性，更多与接相关的口设计，将在本章的后面部分讨论。

\mySamllsection{避免组合不相关或逻辑上分离的概念}

当设计一个组件时，应该专注于单个任务或一组任务，努力实现高内聚，这称为单一职责原则（SRP）。不要组合不相关的概念，例如：随机数生成器和 XML 解析器。

即使不是专门为重用设计代码，也要记住这个策略。整个程序很少单独重用，但程序的片段或子系统会直接整合到其他应用程序中，或者被稍加修改以适应不同的用途。因此，将逻辑上分离的功能划分为可以独立重用的独立组件，每个这样的组件都应该有明确的责任。

这个策略模仿了实际设计原则中的离散、可互换的部件。例如，编写一个 Car 类，并将所有发动机的属性和行为都放在其中。然而，发动机是可分离的组件，它们与其他汽车方面没有联系。发动机可以从一辆汽车上取下并放入另一辆汽车。一个适当的设计，应该包括一个包含所有与发动机相关的功能的 Engine 类。然后，Car 实例只需包含 Engine 类的实例。

\mySamllsection{将程序划分为逻辑子系统}

应该设计子系统作为可以独立重用的离散组件，努力实现低耦合。例如，如果正在设计一个网络游戏，应该将网络和图形用户界面方面分开。这样，可以不带其他组件而重用其中一个组件。例如，可能想写一个非网络游戏，可以重用图形界面子系统，而不需要网络方面。同样，可以设计一个对等文件共享程序，可以重用网络子系统，而不需要图形用户界面功能。

确保为每个子系统遵循抽象原则。将每个子系统视为一个小型库，必须提供连贯且易于使用的接口。即使是唯一使用这些小型库的开发者，也会从良好设计的接口和实现中受益，这些接口和实现将逻辑上分离的功能分离出来。

\mySamllsection{使用类层次结构来分离逻辑概念}

除了将程序划分为逻辑子系统之外，还应该避免在类层面上组合不相关的概念。例如，想为自动驾驶汽车编写一个类。决定从一个基本的汽车类开始，并直接将其自动驾驶逻辑合并进去。然而，如果只想在程序中编写一个非自动驾驶汽车呢？与自动驾驶相关的所有逻辑都无用，并且可能会使程序链接到它本可以避免的库，例如视觉库、LIDAR 库等。一个可能的解决方案是创建一个类层次结构（在第 5 章中介绍），其中自动驾驶汽车是通用汽车的派生类。这样，可以在不需自动驾驶功能的程序中使用汽车基类。图 6.1 显示了这种层次结构。

\myGraphic{0.2}{content/part2/chapter6/images/1.png}{图 6.1}

这种策略在有两个逻辑概念时（例如，自动驾驶和汽车）效果很好。当有三个或更多的概念时，就会变得更加复杂。例如，假设想提供卡车和汽车，每种都可以是自动驾驶或不自动驾驶。从逻辑上讲，卡车和汽车都是车辆的一种特例，因此它们可以是车辆类的派生类，如图 6.2 所示。

\myGraphic{0.4}{content/part2/chapter6/images/2.png}{图 6.2}

同样，自动驾驶类可以是非自动驾驶类的派生类，不能使用线性层次结构提供这些分离。一种可能性是将自动驾驶方面作为一个混合类，上一章展示了在 C++ 中使用多重继承实现混合类的一种方式。例如，一个 PictureButton 可以从 Image 类和 Clickable 混合类同时继承。然而，对于自动驾驶设计，最好使用一种不同的混合实现，即类模板。

这个例子在类模板语法上跳得有点远，该语法在第 12 章中进行了详细讨论，但这些细节对于理解这个讨论并不重要。第 10 章详细讨论了继承；然而，这些细节对于理解这个例子并不重要。目前，只需要知道以下语法完成了从基类进行继承/派生：

\begin{cpp}
class Derived : public Base {};
\end{cpp}

SelfDrivable混合类模板可以这样定义:

\begin{cpp}
template <typename T>
class SelfDrivable : public T
{
};
\end{cpp}

这个 SelfDrivable 混合类模板提供了实现自动驾驶功能所需的所有必要算法。有了这个 SelfDrivable 混合类模板，就可以为实例化汽车和卡车，如下所示：


\begin{cpp}
SelfDrivable<Car> selfDrivingCar;
SelfDrivable<Truck> selfDrivingTruck;
\end{cpp}

这两行代码的结果是编译器使用 SelfDrivable 混合类模板创建了两个实例。在第一个实例中，类模板中所有的 T 都使用 Car 替换，因此从 Car 派生；在第二个实例中，所有的 T 都使用 Truck 替换，因此从 Truck 派生。

这个解决方案需要编写四个不同的类（Vehicle、Car、Truck 和 SelfDrivable），但需要功能分离上下功夫。

同样，应该在任何设计层面上避免组合不相关的概念，即努力实现高内聚。例如，在成员函数层面，一个成员函数不应该执行逻辑上不相关的事情，混合修改（set）和检查（get）等。

\mySamllsection{使用聚合分离逻辑概念}

聚合，在第 5 章中讨论，模拟了 has-a 关系：对象包含其他对象以执行其功能的某些方面。如第 5 章所述，如果有选择，应优先使用 has-a 关系而不是 is-a 关系。

例如，想编写一个 FamilyTree 类来存储家庭成员。显然，树数据结构是存储此信息的理想选择。不需要将树结构代码直接集成到 FamilyTree 类中，应该编写一个单独的 Tree 类。然后，FamilyTree 类可以包含并使用一个 Tree 实例。从面向对象的角度来说，FamilyTree 中有 Tree。使用这种技术，树数据结构可以更容易地在其他程序中重用。

\mySamllsection{消除用户界面的依赖}

如果是一个数据操作库，希望将数据操作与用户界面分开，则永远不应该假设库将在哪种类型的用户界面中使用。库不应该使用任何标准控制台输出和输入功能，例如 std::println() 或 cin，因为如果库在图形用户界面上下文中使用，这样做可能没有意义。例如，基于 Windows 的 GUI 应用程序通常不会有控制台 I/O。如果认为该库只会在基于 GUI 的应用程序中使用，仍然不应该弹出任何类型的消息框或其他类型的通知给最终用户，因为这是客户端代码的责任。客户端代码决定如何向用户显示消息。这些依赖不仅导致可重用性差，而且还阻止客户端代码正确响应错误，例如，以静默方式处理它。

模型-视图-控制器（MVC）模式，在第 4 章中介绍，用于将存储数据与可视化数据分开。根据这个模式，模型可以放在库中，而客户端代码可以提供视图和控制器。

\mySamllsection{使用模板进行泛型数据结构和算法的设计}

C++ 有一个概念叫做模板，允许创建相对于类型或类的泛型结构。例如，编写了一段用于整数数组的代码。如果后来想使用双精度浮点数数组，需要重新编写并复制所有代码以使其与双精度浮点数一起工作。模板的概念是类型成为规格的一个参数，可以创建一个可以处理任何类型的单一代码体。模板允许编写适用于任何类型的数据结构和算法。

这个概念的最简单例子是第 1 章中介绍的 std::vector 类，是 C++ 标准库的一部分。要创建一个整数vector， std::vector<int>；要创建一个双精度浮点数vector，std::vector<double>。模板编程一般来说非常强大，也会非常复杂。幸运的是，可以创建一些简单的模板用法，根据类型参数化。

在可能的情况下，应该为数据结构和算法使用泛型设计，而不是为特定程序编码特定的细节。不要编写只能存储书对象的平衡二叉树结构。使它变得通用，以便它可以存储任何类型的对象。这样，可以在书店、音乐店、操作系统或任何需要平衡二叉树的地方使用它。这种策略是标准库的基础，提供了适用于任何类型的泛型数据结构和算法。

同时，请记住，实现泛型数据结构需要比非泛型实现花费更多的时间。需要更多地考虑需求，并且需要更广泛地测试泛型实现，因为它可以处理许多不同的类型。如果数据结构特定于某些用例，这写努力可能不会带来回报，最好从简单的非泛型实现开始。

\mySamllsection{为什么模板比其他泛型编程技术更好}

模板并不是编写泛型数据结构的唯一方式。另一种方法，尽管已经过时且不再推荐，是使用 void* 指针存储特定类型。客户端可以通过将其转换为 void* 来存储任何他们想要的东西。然而，这种方法的主要问题是类型不安全：容器无法检查或强制存储元素的类型。可以将任何类型转换为 void* 来存储在结构中，当从数据结构中移除指针时，必须将它们转换回实际可用的东西。由于没有检查，结果可能是灾难性的。想象一下，一个开发者通过首先将其转换为 void* 来在数据结构中存储指向 int 的指针，但另一个开发者认为它们是指向 Process 对象的指针。第二个程序员将盲目地将 void* 指针转换为 Process* 指针，并尝试将其当作 Process* 对象。显然，程序不会按预期工作。

相反，在泛型的非模板数据结构中，可以直接使用 void* 指针，但也可以使用从 C++17 开始提供的 std::any 类。any 类在第 24 章中进行了讨论，但在这里只需要知道你可以在 any 类的实例中存储任何类型的对象。std::any 的底层实现确实在某些情况下使用 void* 指针，但它也记录了存储的类型，因此一切都保持类型安全。

另一种方法是为特定类编写数据结构。通过多态，该类的任何派生类都可以存储在该结构中。Java 采取了这种方法的一个极端：指定每个类直接或间接从 Object 类派生。早期版本的 Java 中的容器存储 Object，因此可以存储任何类型的对象。然而，这种方法也不是类型安全的。当从容器中移除一个对象时，必须记住它是什么，并将其向下转换为适当的类型。向下转换意味着将对象转换为类层次结构中的更具体类，即在层次结构中向下转换。

相比之下，模板在使用正确时是类型安全的。每个模板实例只存储一个类型。如果的程序尝试在同一个模板实例中存储不同类型的对象，程序将无法编译。此外，模板允许编译器为每个模板实例生成高度优化的代码。与基于 void* 和 std::any 的数据结构相比，模板还可以避免在自由存储上分配，因此性能更好。最新版本的 Java 支持与 C++ 模板类似的安全泛型概念。

\begin{myNotic}{NOTE}
模板是泛型编程的理想选择。它们是类型安全的，并且为每个模板实例生成了高度优化的代码。
\end{myNotic}

\mySamllsection{Problems with Templates}

Templates are not perfect. First of all, their syntax might be confusing, especially for someone who has not used them before. Second, templates require homogeneous data structures, in which you can store only objects of the same type in a single structure. That is, if you write a class template for a balanced binary tree, you can create one tree object to store Process objects and another tree object to store ints. You can’t store both ints and Processes in the same tree. This restriction is a direct result of the type-safe nature of templates.

Another possible disadvantage of templates is called code bloat: an increased size of the final binary code. Highly specialized code for each template instantiation takes more code than slightly slower generic code. Usually, however, code bloat is not so much of a problem these days.

\mySamllsection{Templates vs. Inheritance}

Programmers sometimes find it tricky to decide whether to use templates or inheritance. The following are some tips to help you make the decision.

Use templates when you want to provide identical functionality for different types. For example, if you want to write a generic sorting algorithm that works on any type, use a function template. If you want to create a container that can store any type, use a class template. The key concept is that the class- or function template treats all types the same. However, if required, templates can be specialized for specific types to treat those types differently. Template specialization is discussed in Chapter 12.

When you want to provide different behaviors for related types, use inheritance. For example, in a shape-drawing application, use inheritance to support different shapes such as a circle, a square, a line, and so on. The specific shapes then derive from, for example, a Shape base class.

Another difference between templates and inheritance is that templates are processed at compile time; thus, all involved types must be known at compile time. This results in compile-time polymorphism. With inheritance, you get run-time polymorphism.

Note that you can combine inheritance and templates. You could write a class template that derives from a base class template. Chapter 12 covers the details of the template syntax.

\mySamllsection{Provide Appropriate Checks and Safeguards}

When you design code with reuse in mind, you need to pay special attention to make sure the code is safe for use in different use cases, not just the use case at hand.

There are two opposite styles for designing safe code. The optimal programming style is probably using a healthy mix of both of them. The first is called design-by-contract, which means that the documentation for a function or a class represents a contract with a detailed description of what the responsibility of the client code is and what the responsibility of your function or class is. There are three important aspects of design-by-contract: preconditions, postconditions, and invariants. Preconditions list the conditions that client code must satisfy before calling a function. Postconditions list the conditions that must be satisfied by the function when it has finished executing. Finally, invariants list the conditions that must be satisfied during the whole execution of the function.

Design-by-contract is often used in the Standard Library. For example, std::vector defines a contract for using the array notation to get a certain element from a vector. The contract states that no bounds checking is performed, but that this is the responsibility of the client code. In other words, a precondition for using array notation to get elements from a vector is that the given index is valid.
This is done to increase performance for client code that knows their indices are within bounds.

The second style is that you design your functions and classes to be as safe as possible. The most important aspect of this guideline is to perform error checking in your code. For example, if your random number generator requires a seed to be in a specific range, don’t just trust the user to pass a valid seed. Check the value that is passed in, and reject the call if it is invalid. As a second example, next to the design-by-contract array notation for retrieving an element from a vector, it also defines an at() member function to get a specific element while performing bounds checking. If the user provides an invalid index, at() throws an exception. So, client code can choose whether it uses the array notation without bounds checking, or at() with bounds checking.

As an analogy, consider an accountant who prepares income tax returns. When you hire an accountant, you provide them with all your financial information for the year. The accountant uses this information to fill out forms from the IRS(The Internal Revenue Service (IRS) administers and enforces U.S. federal tax laws.). However, the accountant does not blindly fill out your information on the form, but instead makes sure the information makes sense. For example, if you own a house but forget to specify the property tax you paid, the accountant will remind you to supply that information. Similarly, if you say that you paid \$12,000 in mortgage interest but made only \$15,000 gross income, the accountant might gently ask you if you provided the correct numbers (or at least recommend more affordable housing).

You can think of the accountant as a “program” where the input is your financial information and the output is an income tax return. However, the value added by an accountant is not just that they fill out the forms. You also choose to employ an accountant because of the checks and safeguards that they provide. Similarly in programming, you could provide as many checks and safeguards as possible in your implementations.

There are several techniques and language features that help you to write safe code and to incorporate checks and safeguards in your programs. To report errors to client code, you can for example return an error code, a distinct value like false or nullptr, or an std::optional as introduced in Chapter 1. Alternatively, you can throw an exception to notify client code of any errors. Chapter 14, “Handling Errors,” covers exceptions in detail.

\mySamllsection{Design for Extensibility}

You should strive to design your classes in such a way that they can be extended by deriving another class from them, but they should be closed for modification; that is, the behavior should be extendable without you having to modify its implementation. This is called the open/closed principle (OCP).

As an example, suppose you start implementing a drawing application. The first version should only support squares. Your design contains two classes: Square and Renderer. The former contains the definition of a square, such as the length of its sides. The latter is responsible for drawing the squares.
You come up with something as follows:

\begin{cpp}
class Square { /* Details not important for this example. */ };

class Renderer
{
    public:
    void render(const vector<Square>& squares)
    {
        for (auto& square : squares) { /* Render this square object... */ }
    }
};
\end{cpp}

Next, you add support for circles, so you create a Circle class:

\begin{cpp}
class Circle { /* Details not important for this example. */ };
\end{cpp}

To be able to render circles, you have to modify the render() member function of the Renderer class. You decide to change it as follows:

\begin{cpp}
void Renderer::render(const vector<Square>& squares,
    const vector<Circle>& circles)
{
    for (auto& square : squares) { /* Render this square object... */ }
    for (auto& circle : circles) { /* Render this circle object... */ }
}
\end{cpp}

While doing this, you feel there is something wrong, and you are correct! To extend the functionality to add support for circles, you have to modify the current implementation of render(), so it’s not closed for modifications.

Your design in this case could use inheritance. Here is a possible design using inheritance:

\begin{cpp}
class Shape
{
    public:
    virtual void render() = 0;
};

class Square : public Shape
{
    public:
    void render() override { /* Render square... */ }
    // Other members not important for this example.
};

class Circle : public Shape
{
    public:
    void render() override { /* Render circle... */ }
    // Other members not important for this example.
};

class Renderer
{
    public:
    void render(const vector<Shape*>& objects)
    {
        for (auto* object : objects) { object->render(); }
    }
};
\end{cpp}

With this design, if you want to add support for a new type of shape, you just need to write a new class that derives from Shape and that implements the render() member function. You don’t need to modify anything in the Renderer class. So, this design can be extended without having to modify the existing code; that is, it’s open for extension and closed for modification.

\mySubsubsection{6.2.3.}{Design Usable Interfaces}

In addition to abstracting and structuring your code appropriately, designing for reuse requires you to focus on the interface with which programmers interact. Even if you have the most beautiful and most efficient implementation, your library will not be any good if it has a wretched interface.

Note that every component in your program should have good interfaces, even if you don’t intend them to be used in multiple programs. First, you never know when something will be reused. Second, a good interface is important even for the first use, especially if you are programming in a group and other programmers must use the code you design and write.

In C++, a class’s properties and member functions can each be public, protected, or private. Making a property or member function public means that any code can access it; protected means that only the class itself and its derived classes can access it; private is a stricter control, which means that not only is the property or member function locked for other code, but even derived classes don’t have access. Note that access specifiers are at the class level, not at the object level. This means that a member function of a class can access, for example, private properties or private member functions of other objects of the same class.

Designing the exposed interface is all about choosing what to make public. You should view the exposed interface design as a process. The main purpose of interfaces is to make the code easy to use, but some interface techniques can help you follow the principle of generality as well.

\mySamllsection{Consider the Audience}

The first step in designing an exposed interface is to consider whom you are designing it for. Is your audience another member of your team? Is this an interface that you will personally be using? Is it something that a programmer external to your company will use? Perhaps a customer or an offshore contractor? In addition to determining who will be coming to you for help with the interface, this should shed some light on some of your design goals.

If the interface is for your own use, you probably have more freedom to iterate on the design. As you’re making use of the interface, you can change it to suit your own needs. However, you should keep in mind that roles on an engineering team change, and it is quite likely that, someday, others will be using this interface as well.

Designing an interface for other internal programmers to use is slightly different. In a way, your interface becomes a contract with them. For example, if you are implementing the data store component of a program, others are depending on that interface to support certain operations. You will need to find out all of the things that the rest of the team wants your class to do. Do they need versioning? What types of data can they store?

When designing interfaces for an external customer, ideally the external customer should be involved in specifying what functionality your interfaces expose, just as when designing interfaces for internal customers. You’ll need to consider both the specific features they want as well as what customers might want in the future. The terminology used in the interface will have to correspond to the terms that the customer is familiar with, and the documentation will have to be written with that audience in mind. Inside jokes, codenames, and programmer slang should be left out of your design.

Whether your interface is for internal programmers or external customers, the interface is a contract. If the interface is agreed upon before coding begins, you’ll receive groans from users of your interface if you decide to change it after code has been written.

The audience for which you are designing an interface also impacts how much time you should invest in the design. For example, if you are designing an interface with just a couple of member functions that will be used only in a few places by a few users, then it could be acceptable to modify the interface later. However, if you are designing a complex interface or an interface that will be used by many users, then you should spend more time on the design and do your best to prevent having to modify the interface once users start using it. This is what is known as Hyrum’s law (see \url{www.hyrumslaw.com}).

\mySamllsection{Consider the Purpose}

There are many reasons for writing an interface. Before putting any code on paper or even deciding on what functionality you’re going to expose, you need to understand the purpose of the interface.

\mySamllsection{Application Programming Interface}

An application programming interface (API) is an externally visible mechanism to extend a product or use its functionality within another context. If an internal interface is a contract, an API is closer to a set-in-stone law. Once people who don’t even work for your company are using your API, they don’t want it to change unless you’re adding new features that will help them. So, care should be given to planning the API and discussing it with customers before making it available to them.

The main trade-off in designing an API is usually ease of use versus flexibility. Because the target audience for the interface is not familiar with the internal working of your product, the learning curve to use the API should be gradual. After all, your company is exposing this API to customers because the company wants it to be used. If it’s too difficult to use, the API is a failure. Flexibility often works against this. Your product may have a lot of different uses, and you want the customer to be able to leverage all the functionality you have to offer. However, an API that lets the customer do anything that your product can do may be too complicated.

As a common programming adage goes, “A good API makes the common case easy and the advanced/ unlikely case possible.” That is, APIs should have a simple learning curve. The things that most programmers will want to do should be accessible. However, the API should allow for more advanced usage, and it’s acceptable to trade off complexity of the rare case for simplicity of the common case. The “Design Interfaces That Are Easy to Use” section later in this chapter discusses this strategy in detail with a number of concrete tips to follow for your designs.

\mySamllsection{Utility Class or Library}

Often, your task is to develop some particular functionality for general use elsewhere in the application, for example a logging class. In this case, the interface is somewhat easier to decide on because you tend to expose most or all of the functionality, ideally without giving too much away about its implementation. Generality is an important issue to consider. Because the class or library is general purpose, you’ll need to take the possible set of use cases into account in your design.

\mySamllsection{Subsystem Interface}

You may be designing the interface between two major subsystems of the application, such as the mechanism for accessing a database. In these cases, separating the interface from the implementation is paramount for a number of reasons.

One of the most important reasons is mockability. In testing scenarios, you will want to replace a certain implementation of an interface with another implementation of the same interface. For example, when writing test code for a database interface, you might not want to access a real database. An interface implementation accessing a real database could be replaced with one simulating all database access.

Another reason is flexibility. Even besides testing scenarios, you might want to provide several different implementations of a certain interface that can be used interchangeably. For example, you might want to replace a database interface implementation that uses a MySQL server database, with an implementation that uses a SQL Server database. You might even want to switch between different implementations at run time.

Yet another reason: by finishing the interface first, other programmers can already start programming against your interface before your implementation is complete.

When working on a subsystem, first think about what its main purpose is. Once you have identified the main task your subsystem is charged with, think about specific uses and how it should be presented to other parts of the code. Try to put yourself in their shoes and not get bogged down in implementation details.

\mySamllsection{Component Interface}

Most of the interfaces you define will probably be smaller than a subsystem interface or an API. These will be classes that you use within other code that you’ve written. In these cases, the main pitfall occurs when your interface evolves gradually and becomes unruly. Even though these interfaces are for your own use, think of them as though they weren’t. As with a subsystem interface, consider the main purpose of each class and be cautious of exposing functionality that doesn’t contribute to that purpose.

\mySamllsection{Design Interfaces That Are Easy to Use}

Your interfaces should be easy to use. That doesn’t mean that they must be trivial, but they should be as simple and intuitive as the functionality allows. This follows the KISS principle: keep it simple, stupid. You shouldn’t require consumers of your library to wade through pages of source code or documentation in order to use a simple data structure or to go through contortions in their code to obtain the functionality they need. This section provides four specific strategies for designing interfaces that are easy to use.

\mySamllsection{Follow Familiar Ways of Doing Things}

The best strategy for developing easy-to-use interfaces is to follow standard and familiar ways of doing things. When people encounter an interface similar to something they have used in the past, they will understand it better, adopt it more readily, and be less likely to use it improperly.

For example, suppose that you are designing the steering mechanism of a car. There are a number of possibilities: a joystick, two buttons for moving left or right, a sliding horizontal lever, or a good old steering wheel. Which interface do you think would be easiest to use? Which interface do you think would sell the most cars? Consumers are familiar with steering wheels, so the answer to both questions is, of course, the steering wheel. Even if you developed another mechanism that provided superior performance and safety, you would have a tough time selling your product, let alone teaching people how to use it. When you have a choice between following standard interface models and branching out in a new direction, it’s usually better to stick to the interface to which people are accustomed.

Innovation is important, of course, but you should focus on innovation in the underlying implementation, not in the interface. For example, consumers are excited about the innovative fully electric engine in some car models. These cars are selling well in part because the interface to use them is identical to cars with standard gasoline engines.

Applied to C++, this strategy implies that you should develop interfaces that follow standards to which C++ programmers are accustomed. For example, C++ programmers expect a constructor and destructor of a class to initialize and clean up an object, respectively (both discussed in details in Chapter 8, “Gaining Proficiency with Classes and Objects”). If you need to “reinitialize” an existing object, a standard way is to just assign a newly constructed object to it. When you design your classes, you should follow these standards. If you require programmers to call initialize() and cleanup() member functions for initialization and cleanup instead of placing that functionality in the constructor and destructor, you will confuse everyone who tries to use your class. Because your class behaves differently from other C++ classes, programmers will take longer to learn how to use it and will be more likely to use it incorrectly by forgetting to call initialize() or cleanup().

\begin{myNotic}{NOTE}
Always think about your interfaces from the perspective of someone using them. Do they make sense? Are they what you would expect?
\end{myNotic}

C++ provides a language feature called operator overloading that can help you develop easy-to-use interfaces for your objects. Operator overloading allows you to write classes such that the standard operators work on them just as they work on built-in types like int and double. For example, you can write a Fraction class that allows you to add, subtract, and print fractions like this:

\begin{cpp}
Fraction f1 { 3, 4 };
Fraction f2 { 1, 2 };
Fraction sum { f1 + f2 };
Fraction diff { f1 - f2 };
println("{} {}", f1, f2);
\end{cpp}

Contrast that with the same behavior using member function calls:

\begin{cpp}
Fraction f1 { 3, 4 };
Fraction f2 { 1, 2 };
Fraction sum { f1.add(f2) };
Fraction diff { f1.subtract(f2) };
f1.print();
print(" ");
f2.print();
println("");
\end{cpp}

As you can see, operator overloading allows you to provide an easier-to-use interface for your classes. However, be careful not to abuse operator overloading. It’s possible to overload the + operator so that it implements subtraction and the – operator so that it implements multiplication. Those implementations would be counterintuitive. This does not mean that each operator should always implement exactly the same behavior. For example, the string class implements the + operator to concatenate strings, which is an intuitive interface for string concatenation. See Chapters 9 and 15, “Overloading C++ Operators,” for details on operator overloading.

\mySamllsection{Don’t Omit Required Functionality}

As you are designing your interface, keep in mind what the future holds. Is this a design you will be locked into for years? If so, you might need to leave room for expansion by coming up with a plug-in architecture. Do you have evidence that people will try to use your interface for purposes other than what it was designed for? Talk to them and get a better understanding of their use case. The alternative is rewriting it later or, worse, attaching new functionality haphazardly and ending up with a messy interface. Be careful, though! Speculative generality is yet another pitfall. Don’t design the beall, end-all logging class if the future uses are unclear, because it might unnecessarily complicate the design, the implementation, and its public interface.

This strategy is twofold. First, include interfaces for all behaviors that clients could need. That might sound obvious at first. Returning to the car analogy, you would never build a car without a speedometer for the driver to view their speed! Similarly, you would never design a Fraction class without a mechanism for client code to access the nominator and denominator values.

However, other possible behaviors might be more obscure. This strategy requires you to anticipate all the uses to which clients might put your code. If you are thinking about the interface in one particular way, you might miss functionality that could be needed when clients use it differently. For example, suppose that you want to design a game board class. You might consider only the typical games, such as chess, and decide to support a maximum of one game piece per spot on the board. However, what if you later decide to write a backgammon game, which allows multiple pieces in one spot on the board? By precluding that possibility, you have ruled out the use of your game board as a backgammon board.

Obviously, anticipating every possible use for your library is difficult, if not impossible. Don’t feel compelled to agonize over potential future uses in order to design the perfect interface. Just give it some thought and do the best you can.

The second part of this strategy is to include as much functionality in the implementation as possible. Don’t require client code to specify information that you already know in the implementation, or could know if you designed it differently. For example, if your library requires a temporary file, don’t make the clients of your library specify that path. They don’t care what file you use; find some other way to determine an appropriate temporary file path.

Furthermore, don’t require library users to perform unnecessary work to amalgamate results. If your random number library uses a random number algorithm that calculates the low-order and high-order bits of a random number separately, combine all bits into one number before giving it to the user.

\mySamllsection{Present Uncluttered Interfaces}

To avoid omitting functionality in their interfaces, some programmers go to the opposite extreme: they include every possible piece of functionality imaginable. Programmers who use the interfaces are never left without the means to accomplish a task. Unfortunately, the interface might be so cluttered that they never figure out how to do it! Such interfaces are called fat interfaces.

Don’t provide unnecessary functionality in your interfaces; keep them clean and simple. It might appear at first that this guideline directly contradicts the previous strategy of not omitting necessary functionality. Although one strategy to avoid omitting functionality would be to include every imaginable interface, that is not a sound strategy. You should include necessary functionality and omit useless or counterproductive interfaces.

Consider cars again. You drive a car by interacting with only a few components: the steering wheel, the brake and accelerator pedals, the gearshift, the mirrors, the speedometer, and a few other dials on your dashboard. Now, imagine a car dashboard that looked like an airplane cockpit, with hundreds of dials, levers, monitors, and buttons. It would be unusable! Driving a car is so much easier than flying an airplane that the interface can be much simpler: You don’t need to view your altitude, communicate with control towers, or control the myriad components in an airplane such as the wings, engines, and landing gear.

A fat interface can be avoided by breaking up the interface into several smaller ones. Alternatively, the façade design pattern can be used to provide an easier interface or interfaces on top of a fat interface. For example, a fat car interface would include everything from simple actions such as accelerating, braking, and turning, to more advanced functionality, such as numerous options for tuning the performance of the engine, and many more. A better design is to provide multiple easier to use interfaces: one for basic operations such as accelerating, braking, and turning; another one to provide access to the engine tuning options; and many more.

Additionally, from the library development perspective, smaller libraries are easier to maintain. If you try to make everyone happy, then you have more room to make mistakes, and if your implementation is complicated enough so that everything is intertwined, even one mistake can render the library useless.

Unfortunately, the idea of designing uncluttered interfaces looks good on paper, but is remarkably hard to put into practice. The rule is ultimately subjective: you decide what’s necessary and what’s not. Of course, your clients will for sure tell you when you get it wrong!

\mySamllsection{Provide Documentation}

Regardless of how easy you make your interfaces to use, you should supply documentation for their use. You can’t expect programmers to use your library properly unless you tell them how to do it.

Think of your library or code as a product for other programmers to consume. Your product should have documentation explaining its proper use.
There are two ways to provide documentation for your interfaces: comments in the interfaces themselves and external documentation. You should strive to provide both. Most public APIs provide only external documentation: comments are a scarce commodity in many of the standard Unix and Windows header files. In Unix, the documentation usually comes in the form of man pages. In Windows, the documentation usually accompanies the integrated development environment or is available on the Internet.

Despite that most APIs and libraries omit comments in the interfaces themselves, I actually consider this form of documentation the most important. You should never give out a “naked” module or header file that contains only code. Even if your comments repeat exactly what’s in the external documentation, it is less intimidating to look at a module or header file with friendly comments than one with only code. Even the best programmers still like to see written language every so often! Chapter 3 gives concrete tips for what to comment and how to write comments, and also explains that there are tools available that can write external documentation for you based on the comments you write in your interfaces.

\mySamllsection{Design General-Purpose Interfaces}

The interfaces should be general purpose enough that they can be adapted to a variety of tasks. If you encode specifics of one application in a supposedly general interface, it will be unusable for any other purpose. Here are some guidelines to keep in mind.

\mySamllsection{Provide Multiple Ways to Perform the Same Functionality}

To satisfy all your “customers,” it is sometimes helpful to provide multiple ways to perform the same functionality. Use this technique judiciously, however, because over-application can easily lead to cluttered interfaces.

Consider cars again. Most new cars these days provide remote keyless entry systems, with which you can unlock your car by pressing a button on a key fob. However, these cars often provide a standard key that you can use to physically unlock the car, for example, when the battery in the key fob is drained. Although these two methods are redundant, most customers appreciate having both options.

Sometimes there are similar situations in interface design. Remember from earlier in this chapter, std::vector provides two member functions to get access to a single element at a specific index. You can use either the at() member function, which performs bounds checking, or array notation, which does not. If you know your indices are valid, you can use array notation and forgo the overhead that at() incurs due to bounds checking.

Note that this strategy should be considered an exception to the “uncluttered” rule in interface design. There are a few situations where the exception is appropriate, but you should most often follow the uncluttered rule.

\mySamllsection{Provide Customizability}

To increase the flexibility of your interfaces, provide customizability. Customizability can be as simple as allowing a client to turn error logging on or off. The basic premise of customizability is that it allows you to provide the same basic functionality to every client but to give clients the ability to tweak it slightly.

One way to accomplish this is through the use of interfaces to invert dependency relationships, also called dependency inversion principle (DIP). Dependency injection is one implementation of this principle. Chapter 4, “Designing Professional C++ Programs,” briefly mentions an example of an ErrorLogger service. You should define an ErrorLogger interface and use dependency injection to inject concrete implementations of this interface into each component that wants to use the ErrorLogger service.

You can allow greater customizability through callbacks and template parameters. For example, you could allow clients to set their own error-handling callbacks. Chapter 19, “Function Pointers, Function Objects, and Lambda Expressions,” discusses callbacks in detail.

The Standard Library takes this customizability strategy to the extreme and allows clients to specify their own memory allocators for containers. If you want to use this feature, you must write a memory allocator class that follows the Standard Library guidelines and adheres to the required interfaces. Most containers in the Standard Library take an allocator as one of their template parameters. Chapter 25, “Customizing and Extending the Standard Library,” provides more details.

\mySamllsection{Reconciling Generality and Ease of Use}

The two goals of ease of use and generality sometimes appear to conflict. Often, introducing generality increases the complexity of the interfaces. For example, suppose that you need a graph structure in a map program to store cities. In the interest of generality, you might use templates to write a generic map structure for any type, not just cities. That way, if you need to write a network simulator in your next program, you can employ the same graph structure to store routers in the network. Unfortunately, by using templates, you make the interface a little clumsier and harder to use, especially if the potential client is not familiar with templates.

However, generality and ease of use are not mutually exclusive. Although in some cases increased generality may decrease ease of use, it is possible to design interfaces that are both general purpose and straightforward to use.

To reduce complexity in your interfaces while still providing enough functionality, you can provide multiple separate interfaces. This is called the interface segregation principle (ISP). For example, you could write a generic networking library with two separate facets: one presents the networking interfaces useful for games, and the other presents the networking interfaces useful for the Hypertext Transfer Protocol (HTTP) for web browsing. Providing multiple interfaces also helps with making the commonly used functionality easy to use, while still providing the option for the more advanced functionality. Returning to the map program, you might want to provide a separate interface for clients of the map to specify names of cities in different languages, while making English the default as it is so predominant. That way, most clients will not need to worry about setting the language, but those who want to will be able to do so.

\mySubsubsection{6.2.4.}{Designing a Successful Abstraction}

Experience and iteration are essential to good abstractions. Truly well-designed interfaces come from years of writing and using other abstractions. You can also leverage someone else’s years of writing and using abstractions by reusing existing, well-designed abstractions in the form of standard design patterns. As you encounter other abstractions, try to remember what worked and what didn’t work. What did you find lacking in the Windows file system API you used last week? What would you have done differently if you had written the network wrapper, instead of your co-worker? The best interface is rarely the first one you put on paper, so keep iterating. Bring your design to your peers and ask for feedback. If your company uses code reviews, start by doing a review of the interface specifications before the implementation starts. Don’t be afraid to change the abstraction once coding has begun, even if it means forcing other programmers to adapt. Ideally, they’ll realize that a good abstraction is beneficial to everyone in the long term.

Sometimes you need to evangelize a bit when communicating your design to other programmers. Perhaps the rest of the team didn’t see a problem with the previous design or feels that your approach requires too much work on their part. In those situations, be prepared both to defend your work and to incorporate their ideas when appropriate.

A good abstraction means that the exported interface has only public member functions that are stable and will not change. A specific technique to accomplish this is called the private implementation idiom, or pimpl idiom, and is discussed in Chapter 9.

Beware of single-class abstractions. If there is significant depth to the code you’re writing, consider what other companion classes might accompany the main interface. For example, if you’re exposing an interface to do some data processing, consider also writing a result class that provides an easy way to view and interpret the results.

Always turn properties into member functions. In other words, don’t allow external code to manipulate the data behind your class directly. You don’t want some careless or nefarious programmer to set the height of a bunny object to a negative number. Instead, have a “set height” member function that does the necessary bounds checking.

Iteration is worth mentioning again because it is the most important point. Seek and respond to feedback on your design, change it when necessary, and learn from mistakes.

\mySubsubsection{6.2.5.}{The SOLID Principles}

This chapter and the previous one discuss a number of basic principles of object-oriented design. To summarize these principles, they are often abbreviated with an easy-to-remember acronym: SOLID.

The following table summarizes the five SOLID principles:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{S} &
\begin{tabular}[c]{@{}l@{}}Single Responsibility Principle (SRP)\\ A single component should have a single, well-defined responsibility and should not\\ combine unrelated functionality.\end{tabular} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{O} &
\begin{tabular}[c]{@{}l@{}}Open/Closed Principle (OCP)\\ A class should be open to extension, but closed for modification. Inheritance is one way\\ to accomplish this. Other mechanisms are templates, function overloading, and more. In\\ general, we speak about customization points in this context.\end{tabular} \\ \hline
\textbf{L} &
\begin{tabular}[c]{@{}l@{}}Liskov Substitution Principle (LSP)\\ You should be able to replace an instance of an object with an instance of a subtype of that\\ object. Chapter 5 explains this principle in the section “The Fine Line Between Has-A and\\ Is-A” with an example to decide whether the relationship between AssociativeArray and\\ MultiAssociativeArray is a has-a or an is-a relationship.\end{tabular} \\ \hline
\textbf{I} &
\begin{tabular}[c]{@{}l@{}}Interface Segregation Principle (ISP)\\ Keep interfaces clean and simple. It is better to have many smaller, well-defined single\\ responsibility interfaces than to have broad, general-purpose interfaces.\end{tabular} \\ \hline
\textbf{D} &
\begin{tabular}[c]{@{}l@{}}Dependency Inversion Principle (DIP)\\ Use interfaces to invert dependency relationships. One way to support the dependency\\ inversion principle is dependency injection, discussed earlier in this chapter and further in\\ Chapter 33, “Applying Design Patterns.”\end{tabular} \\ \hline
\end{longtable}










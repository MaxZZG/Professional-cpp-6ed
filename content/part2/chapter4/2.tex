开始编程之前，跳过分析与设计步骤，或者只是草率地执行真的很诱人。看到代码编译并通过运行，给人一种正在取得进步的印象。当大致知道想要如何组织程序时，正式化设计或写下功能需求似乎是在浪费时间。此外，编写设计文档远不如编码有趣。若整天想写论文，就不可能是计算机程序员！作为一名开发者，我理解这种立即开始编码的诱惑，并曾在某些时候也屈服于这种诱惑。然而，这很可能会导致一些问题。无论作为开发者的经验如何，对常用设计模式的精通程度，以及对C++、问题域和需求的深入理解，设计（思考）都是你工作职责的一部分。没有这个前端设计，就很难不走弯路。

俄国在一个团队中工作，每个团队成员都负责项目的不同部分，则为所有团队成员提供一个设计文档至关重要。设计文档也有助于新成员了解项目的设计。若没有设计文档，任何新加入项目的人都不会知道设计应该是什么样子，并且可能会修改代码，破坏一些未记录的设计，这可能会在项目后期导致问题。

有些公司有专门的功能分析师来编写功能需求，也有专门负责软件设计的软件架构师。这些公司中，开发者通常可以专注于项目编程。在其他公司，开发者必须自己收集需求和设计。有些公司介于这两种极端之间；也许他们只有一位软件架构师做出架构决策，而开发者则自己设计更小的部分。

为了帮助你理解编程设计的重要性，想象拥有一块土地，你想在那里建一座房子。当建筑商出现时，你要求看蓝图(建筑图纸)。

“什么蓝图？”他回答。“我知道我要做什么，不需要提前计划每一个小细节。两层楼的房子？没问题。几个月前我做过一栋单层房子——我会从那个模型开始，然后继续。”假设暂且相信他，让他继续。几个月后，注意到管道似乎从房子外面跑过，而不是从墙里面。当你向建筑商询问这个异常时，他说：“哦。我忘记在墙上为管道留出空间了。我对这种新的干墙技术太兴奋了，所以就把这件事忘了。但是在外面效果一样好，功能最重要。”你会对他的方法产生怀疑，但出于更好的判断，你还得让他继续。

当你第一次参观完成的建筑时，你注意到厨房没有水池。建筑商为自己辩解道：“我们意识到厨房没有空间放水池时，厨房已经完成了三分之二。我们不想从头开始，所以就在隔壁房间增加了一个单独的水池房间。这行得通，对吧？”如果你把建筑商的辩解翻译成软件领域，它们听起来是否熟悉？你是否曾经发现自己像把管道放在房子外面那样解决了一个“丑陋”的问题？例如，也许你忘记在你的队列数据结构中包含锁，这个数据结构被多个线程共享。当你意识到问题时，你决定只在队列被使用的所有地方手动执行锁。当然，这很丑陋，但能工作，你说。直到有新人加入项目，他们假设锁是数据结构内置的，没有确保对共享数据的互斥访问，导致了一个需要三周才能追踪到的竞态条件错误。一个专业的C++开发者绝不会决定在每次队列访问时手动执行锁，而是直接在队列类内部集成锁，或者以无锁的方式使队列类线程安全。

编写代码之前正式设计，有助于确定一切是如何相互配合的。就像房子的蓝图展示了房间如何相互关联，并协同工作以满足房子的要求一样。程序的设计展示了程序的子系统，如何相互关联并协同工作以满足软件需求。没有设计计划，很可能会错过子系统之间的联系、重用或共享信息的可能性，以及完成任务的最简单方式。没有设计给出的“主体的蓝图”，可能会让你陷入实现细节中，以至于失去了对整体架构和目标的把握。此外，设计为项目所有成员提供了书面文档参考。若使用前面提到的敏捷Scrum方法论这样的迭代过程，需要确保在流程的每个周期中保持设计文档的更新，只要这样做还有价值。敏捷方法论的一个支柱是“工作软件优于全面文档”。至少要确保设计文档关于项目更大部分如何协同工作的部分保持更新，而在我看来，团队是否维护项目小设计文档的价值取决于是否对未来有价值。若没有，那么要么删除这些文档，要么将其标记为过时。

若前面的类比还没有说服你在编写代码之前进行设计，这里有一个例子，直接进入编码无法导致最优设计。假设你想写一个棋类游戏程序。而不是在开始编码之前设计整个程序，你决定从最容易的部分开始，逐步向更难的部分推进。遵循第1章中介绍的面向对象的观点，并在第5章中详细介绍，你决定用类来建模棋子。

你认为兵是棋子中最简单的，所以决定从这里开始。在考虑了兵的特征和行为后，写了一个类，其属性和成员函数如图4.1所示的UML类图所示。

\myGraphic{0.3}{content/part2/chapter4/images/1.png}{图4.1}

在这个设计中，m\_color属性表示兵是黑色还是白色。promote()成员函数在到达棋盘对面的地方执行。

当然，实际上并没有制作这个类图，就直接进入了实现阶段。对这个类感到满意后，转向下一个最简单的棋子：象。了解了它的属性和功能后，写了一个类，其属性和成员函数如图4.2所示的类图中所示。

\myGraphic{0.3}{content/part2/chapter4/images/2.png}{图4.2}

因为没有生成一个类图，所以直接跳到了编码阶段。在这个阶段，你开始怀疑自己可能做错了什么。象和兵看起来很相似。事实上，它们的属性完全相同，并且它们共享许多成员函数。尽管兵和主教的move成员函数的实现可能不同，但两者都需要移动的能力。若在开始编码之前设计好程序，就会意识到各种棋子实际上非常相似，应该找到一种方法，只编写一次通用功能。第5章解释了如何使用面向对象的设计技术来实现这一点。

此外，棋子的几个方面取决于程序的其他子系统。例如，在棋子类本身中，无法准确地表示棋盘上的位置，除非知道如何建模棋盘。另一方面，可能可以以某种方式，以便棋盘以一种不需要棋子知道它们自己位置的方式来管理棋子。作为另一个例子，如何为棋子编写一个draw成员函数，除非首先确定程序的用户界面？它将是图形界面，还是文本界面？棋盘会是什么样子？问题在于，程序的子系统并不孤立存在——它们与其他子系统相关联，确定和定义这些关系需要在设计时完成。





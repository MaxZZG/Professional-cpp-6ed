
Up until C++20, formatting of strings was usually done with C-style functions like printf() or with C++ I/O streams such as std::cout:

\begin{itemize}
\item
C-style functions:

\begin{itemize}
\item
Not recommended because they are not type safe and are not extensible to support your own custom types

\item
Easy to read because of separation of format string and arguments, and hence easy to translate to different languages

\item
For example:
\begin{cpp}
    printf("x has value %d and y has value %d.\n", x, y);
\end{cpp}
\end{itemize}

\item
C++ I/O streams:

\begin{itemize}
\item
Recommended (before C++20) because they are type safe and extensible

\item
Harder to read because the strings and arguments are intertwined, and hence harder to translate

\item
For example:
\begin{cpp}
    cout << "x has value " << x << " and y has value " << y << '.' << endl;
\end{cpp}
\end{itemize}

\end{itemize}

C++20 introduced std::format(), defined in <format>, to format strings. It basically combines all advantages of the C-style functions and the C++ I/O streams. It‚Äôs a type-safe and extensible formatting mechanism. For example:

\begin{cpp}
cout << format("x has value {} and y has value {}.", x, y) << endl;
\end{cpp}

C++23 makes it even easier with the introduction of std::print() and println(). For example:

\begin{cpp}
println("x has value {} and y has value {}.", x, y);
\end{cpp}

Additionally, std::print() and println() have better support for writing UTF-8 Unicode text to Unicode-compliant consoles. Unicode is discussed in Chapter 21, but here‚Äôs a quick example:

\begin{cpp}
println("„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå");
\end{cpp}

This correctly prints the string ‚Äú„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå‚Äù, which is Japanese for ‚ÄúHello World,‚Äù to the console(To compile source code containing Unicode characters, you might need to pass a compiler switch. For Visual C++, you must pass the /utf-8 compiler switch. For GCC, use the command line option -finput-charset=UTF-8. Clang assumes all files are UTF-8 by default. Check your compiler documentation.). If you try to print this string using C++ I/O streams as follows, depending on your console settings, the output can be something garbled such as ‚ÄúœÄ√º√¥œÄ√©√¥œÄ√º¬ΩœÄ√º√≠œÄ√º¬ªŒ£‚ïï√ªœÑ√≤√Æ‚Äù:

\begin{cpp}
cout << "„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå" << endl;
\end{cpp}

Thanks to the Unicode support, you can even print emojis. The following prints a smiley if your output console properly supports Unicode. Using cout for this would likely result in garbled output.

\newfontfamily\emojifont{Segoe UI Emoji}
println("{\emojifont üòä}");


std::print() and println() are now the recommended ways to write text to the console; thus, they‚Äôre used throughout all the examples in this book. They are type safe, are extensible to support user types, are easy to read, support Unicode output, support localization to different languages, and so on. On top of all those benefits, the performance of print() and println() is also much better compared to doing the same using C++ I/O streams directly, even though, underneath, print() and println() are still using such streams.

\mySubsubsection{2.2.1.}{Format Strings}

std::format(), print(), and println() use a format string, a string specifying how the given arguments must be formatted in the output string. Its basic form is introduced in the previous chapter and already used throughout examples. Now it‚Äôs time to look at how powerful these format strings really are.

The format string is usually the first argument to format(), print(), and println(). A format string can contain a set of curly brackets, \{\}, which represent a replacement field. You can have as many replacement fields as you need. Subsequent arguments to format(), print(), and println() are values that are used to fill in those replacement fields. If you need the \{ and \} characters in the output, then you need to escape them as \{\{ or \}\}.

Up to now, replacement fields have always been empty sets of curly brackets, \{\}, but that is just the start. Inside those curly brackets can be a string in the format [index][:specifier]:

\begin{itemize}
\item
The optional index is an argument index, discussed in the next section.

\item
The optional specifier is a format specifier to stipulate how a value must be formatted in the output and explained in detail in the ‚ÄúFormat Specifiers‚Äù section.
\end{itemize}

Passing a format string to format(), print(), and println() is mandatory. For example, you cannot directly print a value as follows:

\begin{cpp}
int x { 42 };
println(x);
\end{cpp}

Instead, you can write the following:

\begin{cpp}
println("{}", x);
\end{cpp}

You also cannot print a single newline by just writing the following:

\begin{cpp}
println();
\end{cpp}

Instead, use this:

\begin{cpp}
println("");
\end{cpp}

\mySubsubsection{2.2.2.}{Argument Indices}

You can either omit the index from all replacement fields or specify, for all replacement fields, the zero-based index of one of the values passed to format(), print(), or println() as second and subsequent arguments that should be used for a replacement field. You are allowed to use a certain index multiple times if you want to output that value multiple times. If index is omitted, the values passed as second and subsequent arguments are used in their given order for all replacement fields.

The following call to println() omits explicit indices in the replacement fields:

\begin{cpp}
int n { 42 };
println("Read {} bytes from {}", n, "file1.txt");
\end{cpp}

You can specify manual indices as follows:

\begin{cpp}
println("Read {0} bytes from {1}", n, "file1.txt");
\end{cpp}

Mixing manual indices and automatic indices is not allowed. The following uses an invalid format string:

\begin{cpp}
println("Read {0} bytes from {}", n, "file1.txt");
\end{cpp}

The order of the formatted values in the output string can be changed without having to change the actual order of the arguments. This is a useful feature if you want to translate strings in your software. Certain languages have different ordering within their sentences. For example, the previous format string can be translated to Chinese as follows. In Chinese, the order of the replacement fields in the sentence is reversed, but thanks to the use of argument indices in the format string, the order of the arguments to println() remains unchanged.

\begin{cpp}
println("‰ªé{1}‰∏≠ËØªÂèñ{0}‰∏™Â≠óËäÇ„ÄÇ ", n, "file1.txt");
\end{cpp}

\mySubsubsection{2.2.3.}{Printing to Different Destinations}

Up to now, every call to print() and println() had a format string as the first argument, followed by a number of additional arguments. For example:

\begin{cpp}
println("x has value {} and y has value {}.", x, y);
\end{cpp}

This prints the string to the standard output stream, the same stream as std::cout.

As Chapter 1 explains, there‚Äôs also std::cerr, which streams to the standard error console. You can use print() and println() to print to the error console as follows:

\begin{cpp}
println(cerr, "x has value {} and y has value {}.", x, y);
\end{cpp}

\CXXTwentythreeLogo{-40}{-40}

\mySubsubsection{2.2.4.}{Compile-Time Verification of Format Strings}

As of C++23, the format string for format()(This is a breaking change for std::format(). Prior to C++23, the format string for format() was not enforced to be a compile-time constant.), print(), and println() must be a compile-time constant so that the compiler can check at compile time whether there are any syntax errors in the format string. That means the following does not compile:

\begin{cpp}
string s { "Hello World!" };
println(s); // Error! Does not compile
\end{cpp}

The error produced is compiler dependent and unfortunately, at the time of this writing, rather cryptic and not always immediately helpful in pinpointing the exact cause of the error. For example, here is the error from the Microsoft Visual C++ 2022 compiler:

\begin{shell}
error C7595: 'std::basic_format_string<char>::basic_format_string': call to
immediate function is not a constant expression
\end{shell}

The correct use is as follows:

\begin{cpp}
string s { "Hello World!" };
println("{}", s);
\end{cpp}

constexpr format strings are naturally also allowed as those are compile-time constants. Chapter 9, ‚ÄúMastering Classes and Objects,‚Äù discusses the constexpr keyword in detail.

\begin{cpp}
constexpr auto formatString { "Value: {}" };
println(formatString, 11); // Value: 11
\end{cpp}

\mySamllsection{Non-Compile-Time Constant Format Strings}

The fact that format strings must be compile-time constants can be a bit cumbersome when you need to localize/translate format strings for different languages. In such a scenario, you can use std::vprint\_unicode() or std::vprint\_nonunicode() instead of std::print(). It‚Äôs a little bit harder to use, though. You cannot just pass the arguments as you do with print(), but you need to use std::make\_format\_args() to do so. Here‚Äôs an example:

\begin{cpp}
enum class Language { English, Dutch };

string_view GetLocalizedFormat(Language language)
{
    switch (language) {
        case Language::English: return "Numbers: {0} and {1}.";
        case Language::Dutch: return "Getallen: {0} en {1}.";
    }
}

int main()
{
    Language language { Language::English };
    vprint_unicode(GetLocalizedFormat(language), make_format_args(1, 2));
    println("");
    language = Language::Dutch;
    vprint_unicode(GetLocalizedFormat(language), make_format_args(1, 2));
}
\end{cpp}

The output is:

\begin{shell}
Numbers: 1 and 2.
Getallen: 1 en 2.
\end{shell}

The following call using print() does not compile as it requires a compile-time constant format string:

\begin{cpp}
print(GetLocalizedFormat(language), 1, 2);
\end{cpp}

\mySamllsection{Handling Errors in Non-Compile-Time Constant Format Strings}

When format strings are verified at run time, instead of at compile time, std::format\_error exceptions are thrown for any format string error. As explained earlier, functions such as std::format(), print(), and println() never throw such exceptions as the format strings are all verified at compile time. However, functions such as std::vformat() and vprint\_unicode() (see the previous section) don‚Äôt require the format string to be constant and hence don‚Äôt verify them at compile time but at run time. These functions might throw format\_error exceptions. Here is an example:

\begin{cpp}
try {
    vprint_unicode("An integer: {5}", make_format_args(42));
} catch (const format_error& caught_exception) {
    println("{}", caught_exception.what()); // "Argument not found."
}
\end{cpp}

Now, let‚Äôs investigate how powerful format specifiers really are.

\mySubsubsection{2.2.5.}{Format Specifiers}

As mentioned earlier, a format string can contain replacement fields delimited by curly brackets. Inside those curly brackets can be a string in the format [index][:specifier]. This section discusses the format specifier part of the replacement field. index is discussed earlier.

A format specifier is used to manipulate how a value is formatted in the output. A format specifier is prefixed with a colon, :. The general form of a format specifier is as follows:

\begin{shell}
[[fill]align][sign][#][0][width][.precision][L][type]
\end{shell}

All parts between square brackets are optional. The individual specifier parts are discussed in the next subsections.

\mySamllsection{width}

The width specifies the minimum width of the field into which the given value should be formatted.

This can also be another set of curly brackets, in which case it‚Äôs called a dynamic width. If an index is specified in the curly brackets, for example {3}, the value for the dynamic width is taken from the argument with the given index. Otherwise, if no index is specified, for example \{\}, the width is taken from the next argument in the list of arguments.
Here are some examples:

\begin{cpp}
int i { 42 };
println("|{:5}|", i);        // |    42|
println("|{:{}}|", i, 7);    // |       42|
println("|{1:{0}}|", 7, i);  // |       42|
\end{cpp}


\mySamllsection{[fill]align}

The [fill]align part optionally says what character to use as a fill character, followed by how a value should be aligned in its field:

\begin{itemize}
\item
< means left alignment (default for non-integers and non-floating-point numbers).

\item
> means right alignment (default for integers and floating-point numbers).

\item
\^{}  means center alignment.
\end{itemize}

The fill character is inserted into the output to make sure the field in the output reaches the desired minimum width specified by the [width] part of the specifier. If no [width] is specified, then [fill] align has no effect.

When using center alignment, the same number of fill characters is on the left and on the right of the formatted value. If the total number of fill characters is odd, then the extra fill character is added on the right.

Here are some examples:

\begin{cpp}
int i { 42 };
println("|{:7}|", i);     // |     42|
println("|{:<7}|", i);    // |42     |
println("|{:_>7}|", i);   // |_____42|
println("|{:_^7}|", i);   // |__42___|
\end{cpp}

The following is an interesting trick to output a character a specific number of times. Instead of typing a string literal yourself containing the correct number of characters, you specify the number of characters you need explicitly in the format specifier:

\begin{cpp}
println("|{:=>16}|", ""); // |================|
\end{cpp}

\mySamllsection{sign}

The sign part can be one of the following:

\begin{itemize}
\item
- means to only display the sign for negative numbers (default).

\item
+ means to display the sign for negative and positive numbers.

\item
space means that a minus sign should be used for negative numbers, and a space for positive numbers.
\end{itemize}

Here are some examples:

\begin{cpp}
int i { 42 };
println("|{:<5}|", i);   // |42  |
println("|{:<+5}|", i);  // |+42 |
println("|{:< 5}|", i);  // | 42 |
println("|{:< 5}|", -i); // |-42 |
\end{cpp}

\mySamllsection{\#}

The \# part enables the alternate formatting rules. If enabled for integral types, and hexadecimal, binary, or octal number formatting is specified as well, then the alternate format inserts a 0x, 0X, 0b, 0B, or 0 in front of the formatted number. If enabled for floating-point types, the alternate format will always output a decimal separator, even if no digits follow it.

The following two sections give examples with alternate formatting.

\mySamllsection{type}

The type specifies the type a given value must be formatted in. There are several options:

\begin{itemize}
\item
Integer types: b (binary), B (binary, but with 0B instead of 0b if \# is specified), d (decimal), o (octal), x (hexadecimal with lowercase a, b, c, d, e, f), X (hexadecimal with uppercase A, B, C, D, E, F, and if \# is specified, with 0X instead of 0x). If type is unspecified, d is used for integer types.

\item
Floating-point types: The following floating-point formats are supported. The result of scientific, fixed, general, and hexadecimal formatting is the same as discussed earlier in this chapter for std::chars\_format::scientific, fixed, general, and hex.

\begin{itemize}
\item
e, E: Scientific notation with either small e or capital E as the representation of the exponent, formatted with either a given precision or 6 if no precision is specified.

\item
f, F: Fixed notation formatted with either a given precision or 6 if no precision is specified.

\item
g, G: General notation automatically chooses a representation without an exponent (fixed format) or with an exponent (small e or capital E), formatted with either a given precision or 6 if no precision is specified.

\item
a, A: Hexadecimal notation with either lowercase letters (a) or uppercase letters (A)

\item
If type is unspecified, g is used for floating-point types.
\end{itemize}

\item
Booleans: s (outputs true or false in textual form), b, B, c, d, o, x, X (outputs 1 or 0 in integer form). If type is unspecified, s is used for Boolean types.

\item
Characters: c (character is copied to output), ? (escaped character is copied to output; see section ‚ÄúFormatting Escaped Characters and Strings‚Äù), b, B, d, o, x, X (integer representation). If type is unspecified, c is used for character types.

\item
String: s (string is copied to output), ? (escaped string is copied to output; see section ‚ÄúFormatting Escaped Characters and Strings‚Äù). If type is unspecified, s is used for string types.

\item
Pointers: p (hexadecimal notation of the pointer prefixed with 0x). If type is unspecified, p is used for pointer types. Only pointers of type void* can be formatted. Other pointer types must first be converted to type void*, for example using static\_cast<void*>(myPointer).
\end{itemize}

Here are some examples with an integral type:

\begin{cpp}
int i { 42 };
println("|{:10d}|", i);   // |        42|
println("|{:10b}|", i);   // |    101010|
println("|{:#10b}|", i);  // |  0b101010|
println("|{:10X}|", i);   // |        2A|
println("|{:#10X}|", i);  // |      0X2A|
\end{cpp}

Here is an example with a string type:

\begin{cpp}
string s { "ProCpp" };
println("|{:_^10}|", s); // |__ProCpp__|
\end{cpp}

Examples with floating-point types are given in the next section on precision.

\mySamllsection{precision}

The precision can be used only for floating-point and string types. It is specified as a dot followed by the number of decimal digits to output for floating-point types, or the number of characters to output for strings. The number of digits for floating-point types includes all digits, including the ones before the decimal separator, unless fixed floating-point notation (f or F) is used, in which case precision is the number of digits after the decimal point.

Just as with width, precision can also be another set of curly brackets, in which case it‚Äôs called a dynamic precision. The precision is then taken either from the next argument in the list of arguments or from the argument with given index.

Here are some examples using a floating-point type:

\begin{cpp}
double d { 3.1415 / 2.3 };
println("|{:12g}|", d);   // |     1.36587|
println("|{:12.2}|", d);  // |         1.4|
println("|{:12e}|", d);   // |1.365870e+00|

int width { 12 };
int precision { 3 };
println("|{2:{0}.{1}f}|", width, precision, d); // |     1.366|
println("|{2:{0}.{1}}|", width, precision, d);  // |      1.37|
\end{cpp}

\mySamllsection{0}

The 0 part of the specifier means that, for numeric values, zeros are inserted into the formatted value to reach the desired minimum width specified by the [width] part of the specifier (see earlier). These zeros are inserted at the front of the numeric value, but after any sign, and after any 0x, 0X, 0b, or 0B prefix. The 0 specifier is ignored if an alignment is specified.

Here are some examples:

\begin{cpp}
int i { 42 };
println("|{:06d}|", i);   // |000042|
println("|{:+06d}|", i);  // |+00042|
println("|{:06X}|", i);   // |00002A|
println("|{:#06X}|", i);  // |0X002A|
\end{cpp}

\mySamllsection{L}

The optional L specifier enables locale-specific formatting. This option is valid only for arithmetic types, such as integers, floating-point types, and Booleans. When used with integers, the L option specifies that the locale-specific digit group separator character must be used. For floating-point types, it means to use the locale-specific digit group and decimal separator characters. For Boolean types output in textual form, it means to use the locale-specific representation of true and false.

When using the L specifier, you have to pass an std::locale instance as the first parameter to std::format(). This works only with format(), not with print() and println(). Here is an example that formats a floating-point number using the nl locale:

\begin{cpp}
float f { 1.2f };
cout << format(std::locale{ "nl" }, "|{:Lg}|\n", f); // |1,2|
\end{cpp}

Locales are discussed in Chapter 21.

\CXXTwentythreeLogo{-40}{-50}

\mySubsubsection{2.2.6.}{Formatting Escaped Characters and Strings}

C++23 allows you to format escaped strings and characters by using the ? type specifier. This use case does not occur often, but it can be helpful for logging and debugging purposes. The output resembles how you write string and character literals in your code: they start and end with double or single quotes, and they use escaped character sequences. The following table shows what the output is of certain characters when using escaped formatting:.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
CHARACTER       & ESCAPED OUTPUT                   \\ \hline
\endfirsthead
%
\endhead
%
Horizontal tab  & \textbackslash{}t                \\ \hline
New line        & \textbackslash{}n                \\ \hline
Carriage return & \textbackslash{}r                \\ \hline
Backslash       & \textbackslash{}\textbackslash{} \\ \hline
Double quote    & \textbackslash{}"                \\ \hline
Single quote    & \textbackslash{}'                \\ \hline
\end{longtable}

The escaping of double quotes happens only when the output is a double-quoted string, while the escaping of single quotes happens only when the output is a single-quoted character. The escaped output of unprintable characters is \textbackslash{}u\{hex-code-point\}.

Here are some examples:

\begin{cpp}
println("|{:?}|", "Hello\tWorld!\n");   // |Hello\tWorld!\n|
println("|{:?}|", "\"");                // |"\""|
println("|{:?}|", '\'');                // |'\''|
println("|{:?}|", '"');                 // |'"'|
\end{cpp}

\CXXTwentythreeLogo{-40}{-50}

\mySubsubsection{2.2.7.}{Formatting Ranges}

Chapter 1 introduces the std::vector, array, and pair containers to store multiple elements of data. Chapter 18, ‚ÄúStandard Library Containers,‚Äù introduces quite a few additional containers provided by the Standard Library. Starting with C++23, it‚Äôs possible to directly format such ranges of elements. For ranges such as vectors and arrays, the output, by default, is surrounded by square brackets and individual elements are separated by commas. If the elements of the range are strings, their output is escaped by default.

The formatting of ranges can be controlled using nested format specifiers. The general form is as follows:

\begin{shell}
[[fill]align][width][n][range-type][:range-underlying-spec]
\end{shell}

Everything between square brackets is optional. As with other format specifiers, fill specifies a fill character, align specifies the alignment of the output, and width specifies the width of the output field. If n is specified, the output will not contain the opening and closing brackets of the range. The range-type can be one of the following:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{RANGE-TYPE} & \textbf{DESCRIPTION}                                                                                                                     \\ \hline
\endfirsthead
%
\endhead
%
m &
\begin{tabular}[c]{@{}l@{}}Available only for pairs and tuples with two elements. By default, these\\ are surrounded by parentheses and separated by commas. If m is specified,\\ they are not surrounded by any type of brackets, and the two elements are\\ separated by ": ".\end{tabular} \\ \hline
s                   & \begin{tabular}[c]{@{}l@{}}Formats the range as a string (cannot be combined with n or a\\ range-underlying-spec).\end{tabular}          \\ \hline
?s                  & \begin{tabular}[c]{@{}l@{}}Formats the range as an escaped string (cannot be combined with n or a\\ range-underlying-spec).\end{tabular} \\ \hline
\end{longtable}

The range-underlying-spec is an optional format specifier for the individual elements of the range. Range specifiers can be nested multiple levels deep. If the elements are again ranges (e.g., a vector of vectors), then the range-underlying-spec is another range format specifier, and so on.

Let‚Äôs look at some examples. First, let‚Äôs format a vector of numbers:

\begin{cpp}
vector values { 11, 22, 33 };
println("{}", values); // [11, 22, 33]
println("{:n}", values); // 11, 22, 33
\end{cpp}

If you want to replace the starting and ending square brackets, you can combine the n specifier with surrounding the format specifier with your own starting and ending characters. For example, the following surrounds the output with curly brackets instead. Curly brackets that you want to appear in the output need to be escaped as \{\{ and \}\}.

\begin{cpp}
println("{{{:n}}}", values); // {11, 22, 33}
\end{cpp}

The following provides a format specifier for the entire range. For both, the range is output in the center of a field that is 16 characters wide with * as a fill character. For the second, the n specifies that the opening and closing brackets should be omitted:

\begin{cpp}
println("{:*^16}", values); // **[11, 22, 33]**
println("{:*^16n}", values); // ***11, 22, 33***
\end{cpp}

The following does not provide an explicit specifier for the entire range, but it does specify how individual elements are to be formatted. In this case, the individual elements are output in the center of a field that‚Äôs six characters wide with * as a fill character:

\begin{cpp}
println("{::*^6}", values); // [**11**, **22**, **33**]
\end{cpp}

This can again be combined with the n specifier:

\begin{cpp}
println("{:n:*^6}", values); // **11**, **22**, **33**
\end{cpp}

Here are some examples formatting a vector of strings:

\begin{cpp}
vector strings { "Hello"s, "World!\t2023"s };
println("{}", strings);     // ["Hello", "World!\t2023"]
println("{:}", strings);    // ["Hello", "World!\t2023"]
println("{::}", strings);   // [Hello, World!   2023]
println("{:n:}", strings);  // Hello, World!   2023
\end{cpp}

If you have a vector of characters, you can format them as individual characters, or you can consider the entire vector as a string using the s or ?s range type:

\begin{cpp}
vector chars { 'W', 'o', 'r', 'l', 'd', '\t', '!' };
println("{}", chars);       // ['W', 'o', 'r', 'l', 'd', '\t', '!']
println("{::#x}", chars);   // [0x57, 0x6f, 0x72, 0x6c, 0x64, 0x9, 0x21]
println("{:s}", chars);     // World    !
println("{:?s}", chars);    // "World\t!"
\end{cpp}

Here are some examples of outputting a pair. By default, a pair is surrounded by parentheses instead of square brackets, and the two elements are separated by a comma. Using the n specifier removes the opening and closing parentheses. The m specifier also removes the parentheses and separates the elements with ": ".

\begin{cpp}
pair p { 11, 22 };
println("{}", p);     // (11, 22)
println("{:n}", p);   // 11, 22
println("{:m}", p);   // 11: 22
\end{cpp}

Finally, here are some examples of outputting a vector of vectors:

\begin{cpp}
vector<vector<int>> vv { {11, 22}, {33, 44, 55} };
println("{}", vv);          // [[11, 22], [33, 44, 55]]
println("{:n}", vv);        // [11, 22], [33, 44, 55]
println("{:n:n}", vv);      // 11, 22, 33, 44, 55
println("{:n:n:*^4}", vv);  // *11*, *22*, *33*, *44*, *55*
\end{cpp}

\mySubsubsection{2.2.8.}{Support for Custom Types}

The formatting library can be extended to add support for custom types. This involves writing a specialization of the std::formatter class template containing two member function templates: parse() and format(). I know, at this point in the book, you will not understand all the syntax in this example yet, as it uses all of the following techniques:

\begin{itemize}
\item
constexpr functions, discussed in Chapter 9

\item
Template specialization, member function templates, and abbreviated function template syntax, explained in Chapter 12 ‚ÄúWriting Generic Code with Templates‚Äù

\item
Exceptions, discussed in Chapter 14, ‚ÄúHandling Errors‚Äù

\item
Iterators, discussed in Chapter 17, ‚ÄúUnderstanding Iterators and the Ranges Library‚Äù
\end{itemize}

Still, for completeness and to give you a taste of what is possible, let‚Äôs see how you will be able to implement a custom formatter once you advance further in the book, at which point you can come back to this example.

Suppose you have the following class to store a key-value pair:

\begin{cpp}
class KeyValue
{
    public:
        KeyValue(string_view key, int value) : m_key { key }, m_value { value } {}

        const string& getKey() const { return m_key; }
        int getValue() const { return m_value; }
    private:
        string m_key;
        int m_value { 0 };
};
\end{cpp}

A custom formatter for KeyValue objects can be implemented by writing the following class template specialization. This KeyValue formatter supports:

\begin{itemize}
\item
Custom format specifiers: \{:k\} outputs only the key, \{:v\} outputs only the value, and \{:b\} and \{\} output both key and value.

\item
Nested format specifiers: These specify optional formats for the key and or the value. The syntax is as follows: \{:b:KeyFormat:ValueFormat\}.

\begin{cpp}
template <>
class std::formatter<KeyValue>
{
    public:
        constexpr auto parse(auto& context)
        {
            string keyFormat, valueFormat;
            size_t numberOfParsedColons { 0 };
            auto iter { begin(context) };
            for (; iter != end(context); ++iter) {
                if (*iter == '}') { break; }

                if (numberOfParsedColons == 0) { // Parsing output type
                    switch (*iter) {
                        case 'k': case 'K': // {:k format specifier
                            m_outputType = OutputType::KeyOnly; break;
                        case 'v': case 'V': // {:v format specifier
                            m_outputType = OutputType::ValueOnly; break;
                        case 'b': case 'B': // {:b format specifier
                            m_outputType = OutputType::KeyAndValue; break;
                        case ':':
                            ++numberOfParsedColons; break;
                        default:
                            throw format_error { "Invalid KeyValue format." };
                    }
                } else if (numberOfParsedColons == 1) { // Parsing key format
                    if (*iter == ':') { ++numberOfParsedColons; }
                    else { keyFormat += *iter; }
                } else if (numberOfParsedColons == 2) { // Parsing value format
                    valueFormat += *iter;
                }
            }
            // Validate key format specifier.
            if (!keyFormat.empty()) {
                format_parse_context keyFormatterContext { keyFormat };
                m_keyFormatter.parse(keyFormatterContext);
            }
            // Validate value format specifier.
            if (!valueFormat.empty()) {
                format_parse_context valueFormatterContext { valueFormat };
                m_valueFormatter.parse(valueFormatterContext);
            }
            if (iter != end(context) && *iter != '}') {
                throw format_error { "Invalid KeyValue format." };
            }
            return iter;
        }

        auto format(const KeyValue& kv, auto& ctx) const
        {
            switch (m_outputType) {
                using enum OutputType;
                case KeyOnly:
                    ctx.advance_to(m_keyFormatter.format(kv.getKey(), ctx));
                    break;
                case ValueOnly:
                    ctx.advance_to(m_valueFormatter.format(kv.getValue(), ctx));
                    break;
                default:
                    ctx.advance_to(m_keyFormatter.format(kv.getKey(), ctx));
                    ctx.advance_to(format_to(ctx.out(), " - "));
                    ctx.advance_to(m_valueFormatter.format(kv.getValue(), ctx));
                    break;
                }
                return ctx.out();
            }
        private:
            enum class OutputType { KeyOnly, ValueOnly, KeyAndValue };
            OutputType m_outputType { OutputType::KeyAndValue };
            formatter<string> m_keyFormatter;
            formatter<int> m_valueFormatter;
};
\end{cpp}
\end{itemize}

The parse() member function is responsible for parsing the format specifier given as a character range [begin(context), end(context)). It stores the result of the parsing in data members of the formatter class and returns an iterator pointing to the character after the end of the parsed format specifier string. Two of the data members are m\_keyFormatter of type formatter<string> and m\_valueFormatter of type formatter<int> to handle parsing the KeyFormat and ValueFormat parts, respectively, of the format specifier.

The format() member function formats the value given as first argument according to the format specification parsed by parse(), writes the result to ctx.out(), and returns an iterator to the end of the output. The function uses std::format\_to(), which is similar to std::format(), except that it accepts an output iterator indicating where the output should be written to.

The KeyValue formatter can be tested as follows:

\begin{cpp}
const size_t len { 34 }; // Label field length
KeyValue kv { "Key 1", 255 };
println("{:>{}} {}", "Default:", len, kv);
println("{:>{}} {:k}", "Key only:", len, kv);
println("{:>{}} {:v}", "Value only:", len, kv);
println("{:>{}} {:b}", "Key and value with default format:", len, kv);
println("{:>{}} {:k:*^11}", "Key only with special format:", len, kv);
println("{:>{}} {:v::#06X}", "Value only with special format:", len, kv);
println("{:>{}} {::*^11:#06X}", "Key and value with special format:", len, kv);
try {
    auto formatted { vformat("{:cd}", make_format_args(kv)) };
    println("{}", formatted);
} catch (const format_error& caught_exception) {
    println("{}", caught_exception.what());
}
\end{cpp}

The output is as follows:

\begin{shell}
                          Default: Key 1 - 255
                         Key only: Key 1
                       Value only: 255
Key and value with default format: Key 1 - 255
     Key only with special format: ***Key 1***
   Value only with special format: 0X00FF
Key and value with special format: ***Key 1*** - 0X00FF
Invalid KeyValue format.
\end{shell}

As an exercise, you could add support for a different separator symbol between the key and the value. With custom formatters, the possibilities are endless, and everything is type safe!




















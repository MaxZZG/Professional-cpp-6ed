
C++语言常视为“更好的C语言”或“C语言的超集”，其设计为面向对象的C，所以称之为“带类的C”。后来，C语言的许多令人烦恼和粗糙的问题得到了解决。因为C++是基于C的，若是一个经验丰富的C语言开发者，那肯定会在本节中看到的一些熟悉的语法。当然，这两种语言也有不同之处。C23标准规范文档的篇幅不到800页，而C++23标准规范文档的篇幅超过2000页。所以，若是一名C语言开发者，或是熟悉其他语言(如Java、C\#、Python等)的开发者，请留意自己不熟悉的语法!

\mySubsubsection{1.1.1.}{必不可少的“Hello, World”}

下面的代码是最简单的C++程序。若使用的是旧版本的C++，import  std;std::println()会无法识，将需要使用替代方案（稍后会讨论）。

\begin{cpp}
// 01_helloworld.cpp
import std;

int main()
{
    std::println("Hello, World!");
    return 0;
}
\end{cpp}

这段代码会在屏幕上输出“Hello, World!”。这是一个简单的程序，并展示了关于C++程序格式的相关概念:

\begin{itemize}
\item
注释

\item
导入模块

\item
main()函数

\item
屏幕输出

\item
从函数返回
\end{itemize}

这些概念将在接下来的章节中进行简要解释。

\mySamllsection{注释}

程序的第一行是注释，这是一条仅为开发者存在的信息，编译器会忽略它。C++中，有两种描述注释的方法。可以使用两个正斜杠来表示该行后面的内容是注释:

\begin{cpp}
// 01_helloworld.cpp
\end{cpp}

同样的行为(也就是说，没有)可以通过使用多行注释来实现。多行注释以/*开始，以*/结束。下面的代码展示了一个多行注释的作用:

\begin{cpp}
/* This is a multiline comment.
   The compiler will ignore it.
*/
\end{cpp}

注释将在第3章“编码风格”中详细介绍。

\mySamllsection{导入模块}

模块是C++20的四大新特性之一，取代了旧的以头文件为机制的方式。若想使用某个模块的功能，只需简单地导入该模块，可以通过导入声明来实现。从C++23开始，可以通过导入一个单一的标准命名模块来访问整个C++标准库，这个标准模块叫做std。Hello, World的第一行导入了这个标准模块：

\begin{cpp}
import std;
\end{cpp}

若没有导入该模块，将无法执行进行屏幕输出。

若没有C++23的标准命名模块支持，必须显式导入代码所需的头文件。由于标准库中有超过100个头文件，并不总是清楚需要导入哪个特定的头文件才能使用某个特定功能。作为一个参考，附录C“标准库头文件”中，列出了C++标准库的所有头文件，包括它们内容的简短描述。例如，“Hello, World”中，可以不导入标准命名模块std，只导入代码需要的头文件即可。这个例子中，代码只需要导入<print>来获取文本的输出功能。请注意，导入命名模块std时，不使用尖括号，但在导入单个头文件时，需要使用尖括号：

\begin{cpp}
import <print>;
\end{cpp}

因为本书是一本关于C++23的书，所以在所有地方都使用了模块。C++标准库提供的所有功能都包含在定义良好的头文件中。本书中的大多数示例只是导入std命名模块，而不是单个头文件，但会指出功能是哪个头文件提供的。

模块不仅限于标准库，我们也可以编写自己的模块来提供自定义类型和功能。

\begin{myNotic}{NOTE}
若正在使用的编译器尚未完全支持模块，可以将头文件导入声明替换为\#include预处理指令。
\end{myNotic}

\mySamllsection{编译器如何处理源码}

简而言之，构建C++程序需要三个步骤。从技术上讲，编译过程中还有更多的阶段，现阶段这个简化的视图就足够了。

\begin{enumerate}
\item
首先，代码通过预处理运行，预处理器识别有关代码的元信息并处理预处器指令，例如\#include指令。处理所有预处理指令的源文件称为\textbf{翻译单元}。

\item
接下来，所有翻译单元独立编译或翻译成机器可读的文件，其中对函数等的引用尚未定义。

\item
解析这些引用在最后阶段由链接器完成，其会将所有的目标文件链接到最终的可执行文件中。
\end{enumerate}

\CXXTwentythreeLogo{-40}{-50}
\begin{myNotic}{NOTE}
从C++23开始，标准规定C++编译器必须接受使用UTF-8编码的源代码文件。第21章“字符串本地化和正则表达式”讨论了不同的编码，包括UTF-8。我建议您配置工具链以使用UTF-8。这将提高您的文件在不同平台之间的可移植性，并允许源文件中使用非英文字符。

为了在Microsoft Visual C++中启用UTF-8支持，请在项目属性 -> 配置属性 -> C/C++ -> 命令行 下的附加选项设置中添加 /utf-8 选项。对于GCC，请使用命令行选项 -finput-charset=UTF-8。Clang默认认为所有文件都是UTF-8编码。
\end{myNotic}

\mySamllsection{预处理指令}

若编译器尚不支持模块，需要用\#include头文件来代替导入模块或头文件。也就是说，显式的导入声明，如import <print>;，需要用\#include预处理指令替换：

\begin{cpp}
#include <print>
\end{cpp}

预处理的指令以\#字符开头，例如\#include。\#include指令告诉预处理器从<print>头文件中获取所有内容并将其复制到当前文件中。<print>头文件提供了将文本打印到屏幕的功能。

第11章“模块、头文件和其他主题”对预处理指令进行了更详细的讨论。

\mySamllsection{main()函数}

当然，main()是程序的起始点。main()的返回类型是int，表示程序的结果状态。main()函数可以没有任何参数，或者两个参数：

\begin{cpp}
int main(int argc, char** argv)
\end{cpp}

argc给出传递给程序的参数数量，而argv包含这些参数。其中，argv[0]可能是程序名称，也可能是空字符串，所以不要依赖它；相反，应该使用特定于平台的函数来获取程序名称。另外，包含在argv中的实际参数，需要从索引1开始计算。

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{屏幕输出}

C++23前，可使用I/O流将文本输出到屏幕。流会在下一节和第13章“揭开I/O的神秘面纱”中进行了简要介绍。C++23引入了一个新的、更易于使用的机制来输出文本到屏幕，这在本书的每个代码片段中都使用到了：std::print()和println()，都在<print>中定义。

第2章“使用字符串和字符串视图”详细讨论了std::print()和println()，用于将字符串格式化和输出到屏幕上。其基本使用的方式非常直接，其最基本的形式中，println()可以用来打印一行文本，该文本输出后会自动换行：

\begin{cpp}
std::println("Hello, World!");
\end{cpp}

println()的第一个参数是字符串格式的，其中可以包含替换字段，这些字段将由作为第二个和后续参数传递的值替换。可以在每个字段旁边包含大括号\{\}来指示替换字段的位置。例如：

\begin{cpp}
std::println("There are {} ways I love you.", 219);
\end{cpp}

这个例子中，数字219将插入到字符串中，所以输出为：

\begin{shell}
There are 219 ways I love you
\end{shell}

可以根据需要设置任意多的替换字段，例如:

\begin{cpp}
std::println("{} + {} = {}", 2, 4, 6);
\end{cpp}

这个例子中，每个字段都是按顺序应用的，所以结果输出为:

\begin{shell}
2 + 4 = 6
\end{shell}

关于替换字段的格式还有很多要说的，但这是第2章的内容。

若使用print()而不是println()，输出的文本将不会以换行。

\mySamllsection{输入输出流}

若编译器还不支持C++23，在使用std::print()和println()函数，则必须使用I/O流重新实现。

输入输出流会在第13章中深入的介绍，但其基本概念很简单。可以将输出流想象成数据槽通道，投入其中的东西都会输出。std::cout是与用户控制台或标准输出对应的通道。还有其他的通道，包括std::cerr，输出到错误控制台。<{}<运算符将数据投入通道中。输出流允许多种类型的数据在单行代码中顺序发送到通道中。以下代码输出文本，然后是一个数字，最后是文本：

\begin{cpp}
std::cout << "There are " << 219 << " ways I love you." << std::endl;
\end{cpp}

从C++20开始，推荐使用std::format()，其定义在<format>中，对字符串进行格式化。format()函数使用与print()和println()相同的替换字段概念，这会在第2章中详细讨论。用其来重写前面的语句也很简单：

\begin{cpp}
std::cout << std::format("There are {} ways I love you.", 219) << std::endl;
\end{cpp}

若编译器尚不支持print()和println()，可以使用cout、format()和endl。假设有以下代码：


\begin{cpp}
std::println("{} + {} = {}", 2, 4, 6);
\end{cpp}

将println()替换为format()，将结果流式传输到cout，并添加endl输出:

\begin{cpp}
std::cout << std::format("{} + {} = {}", 2, 4, 6) << std::endl;
\end{cpp}

std::endl表示行结束。当输出流遇到std::endl时，会将输出到目前为止已发送到通道中的所有内容，并移动到下一行。表示行结束的另一种方法是使用\verb|\|n字符。\verb|\|n字符是一个转义字符，是一个换行字符。转义字符可以在任何带引号的文本字符串中使用。下表显示了最常见的几种:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{转义字符}         & \textbf{含义}                                             \\ \hline
\endfirsthead
%
\endhead
%
\textbackslash{}n                & 换行:将光标移到下一行的开头 \\ \hline
\textbackslash{}r &
\begin{tabular}[c]{@{}l@{}}回车:将光标移到当前行的开头，但不能换行\end{tabular} \\ \hline
\textbackslash{}t                & 制表符                                                          \\ \hline
\textbackslash{}\textbackslash{} & 反斜杠字符                                          \\ \hline
\textbackslash{}"                & 引号                                               \\ \hline
\end{longtable}

\begin{myWarning}{WARNING}
请记住，endl会将新行插入到流中，并将当前在其缓冲区中的所有内容输出到通道中。所以不建议过度使用endl，例如在循环中，因为这会影响性能。另一方面，在流中插入\textbackslash{}n也会插入新行，但不会自动刷新缓冲区。
\end{myWarning}

默认情况下，print()和println()将文本输出到标准输出控制台std::cout。也可以输出到错误控制台std::cerr:

\begin{cpp}
std::println(std::cerr, "Error: {}", 6);
\end{cpp}

流也可以用来接受来自用户的输入。最简单的方法是对输入流使用操作符>{}>。cin输入流可接受来自用户的键盘输入:

\begin{cpp}
import std;
int main()
{
    int value;
    std::cin >> value;
    std::println("You entered {}", value);
}
\end{cpp}

操作符>{}>在读取值后遇到空格字符时停止输入，所以不能使用操作符读取包含空格的文本。此外，用户输入可能很棘手，因为不知道用户将输入什么样的数据。第13章详细讨论了输入流，包括如何读取带有空格的文本。

若是C++新手，并且具有C背景，可能会想知道是否可以使用printf()和scanf()函数。虽然这些函数仍然可以在C++中使用，但强烈建议使用现代的print()、println()和format()函数和流库，其主要原因是因为printf()和scanf()系列函数不提供类型安全的保障。

\mySamllsection{从函数返回}

“Hello, World”程序的最后一行:

\begin{cpp}
return 0;
\end{cpp}

由于这是main()函数，从它返回将控制权返回给操作系统。当这样做时，其传递值0，这通常向操作系统发出信号，表明在执行程序时没有错误。对于错误情况，可以返回非零值。

main()中的return语句是可选的。若不写一个，编译器将隐式地添加一个return 0;。

\mySubsubsection{1.1.2.}{命名空间}

命名空间解决了不同代码段之间的命名冲突问题。例如，正在编写一些代码，其中包含一个名为foo()的函数。某天，决定开始使用第三方库，该库也有一个foo()函数，这时编译器无法知道代码中引用的是哪个版本的foo()。若不能更改库的函数名，就要更改自己的函数名，这是一件非常痛苦的事情。

这种情况下，命名空间可以发挥作用，因为可以定义定义名称的上下文。将代码放置在命名空间，请将其包含在命名空间块中:

\begin{cpp}
namespace mycode {
    void foo()
    {
        std::println("foo() called in the mycode namespace");
    }
}
\end{cpp}

将您自己的foo()放在命名空间mycode中，可以将其与第三方库提供的foo()函数隔离。要调用支持命名空间的foo()版本，请使用::将命名空间添加到函数名之前，也称为作用域解析操作符:

\begin{cpp}
mycode::foo(); // Calls the "foo" function in the "mycode" namespace
\end{cpp}

属于mycode命名空间块的代码都可以调用同一命名空间内的其他代码，而无需显式添加命名空间。这种隐式命名空间的做法，有助于提高代码的可读性。也可以使用using指令来消除命名空间的前缀。该指令告诉编译器，后续代码正在使用指定命名空间中的名称，所以下面的代码隐藏了命名空间:

\begin{cpp}
using namespace mycode;

int main()
{
    foo(); // Implies mycode::foo();
}
\end{cpp}

\begin{myNotic}{NOTE}
main()函数绝不能放在命名空间中，其必须在全局命名空间中。
\end{myNotic}

单个源文件可以包含多个using指令，但不要过度使用这种方式。极端情况下，若声明使用人类已知的所有所以空间，实际上就等于消除了命名空间!若使用包含相同名称的两个名称空间，将名称冲突会继续。知道代码在哪个名称空间中运行也很重要，这样就不会意外地调用错误的函数。

之前已经了解了命名空间的语法，在“Hello, World”程序中我们使用了它，其中println是在std名称空间中定义的名称。可以用using指令写“Hello, World”，如下所示:

\begin{cpp}
import std;

using namespace std;

int main()
{
    println("Hello, World!");
}
\end{cpp}

\begin{myNotic}{NOTE}
本书中的大多数代码片段都假定std命名空间有一个using指令，C++标准库中的所有内容都可以使用，而不需要用std::来限定。
\end{myNotic}

using声明可用于引用命名空间中的特定项。只想在std命名空间中使用非限定的print，可以使用下面的using声明:

\begin{cpp}
using std::print;
\end{cpp}

后续代码可以在不添加名称空间的情况下引用print，但std命名空间中的其他项，如println，仍然需要显式限定:

\begin{cpp}
using std::print;
print("Hello, ");
std::println("World!");
\end{cpp}

\begin{myWarning}{WARNING}
永远不要在全局作用域的头文件中放置using指令或using声明;否则，将强制每个包含头文件的源文件执行此操作。可以将其放在较小的作用域中(例如命名空间或类作用域中)，即使在头文件中也是如此。把using指令或声明放在模块接口文件中也完全没问题，只要不导出。因为我认为模块使接口更容易理解，所以本书完全限定模块接口文件中的所有类型。模块接口文件和从模块导出将在后续章节中进行解释。
\end{myWarning}

\mySamllsection{嵌套命名空间}

嵌套命名空间是指一个命名空间在另一个命名空间内。每个命名空间由双冒号分隔。这里有一个例子:

\begin{cpp}
namespace MyLibraries::Networking::FTP {
    /* ... */
}
\end{cpp}

这种紧凑的语法在C++17之前不可用。若是编译器不支持C++17，可以使用如下方法:

\begin{cpp}
namespace MyLibraries {
    namespace Networking {
        namespace FTP {
            /* ... */
        }
    }
}
\end{cpp}

\mySamllsection{命名空间的别名}

命名命名空间别名可用于为另一个命名空间提供一个新的、可能更短的名称:

\begin{cpp}
namespace MyFTP = MyLibraries::Networking::FTP;
\end{cpp}

\mySubsubsection{1.1.3.}{字面量}

字面量用于在代码中编写数字或字符串，C++支持一些标准字面量。整数可以用以下字面值表示(示例表示相同的数字123):

\begin{itemize}
\item
十进制字面量, 123

\item
八进制字面量, 0173 (以0开头)

\item
十六进制字面量, 0x7B (以0x开头)

\item
二进制字面量, 0b1111011 (以0b开头)
\end{itemize}

\begin{myWarning}{WARNING}
除非是八进制字面量，永远不要在数字字面值前面放一个0!
\end{myWarning}

C++中使用字面量的其他例子：

\begin{itemize}
\item
浮点值 (例如 3.14f)

\item
双精度浮点值 (例如 3.14)

\item
十六进制浮点字面值 (例如 0x3.ABCp-10 和 0Xb.cp12l)

\item
单个字符 (例如 'a')

\item
以零结尾的字符数组 (例如 "character array")
\end{itemize}

字面量可以带有后缀，例如3.14f中的f，以强制使用某种类型。本例中，3.14f是float，而3.14是double。

单引号字符可以用作数字字面量中的数字分隔符。例如:

\begin{itemize}
\item
23'456'789

\item
2'34'56'789

\item
0.123'456f
\end{itemize}

仅用空格分隔的多个字符串字面值，可以自动连接成单个字符串。例如:

\begin{cpp}
std::println("Hello, "
             "World!");
\end{cpp}

等价于：

\begin{cpp}
std::println("Hello, World!");
\end{cpp}

也可以自定义字面值，这是第15章“重载C++操作符”中一项高级特性。

\mySubsubsection{1.1.4.}{变量}

C++中，变量几乎可以在代码的任何地方声明，并可以在声明之后的当前块内使用。变量可以在未给定值的情况下声明，这些未初始化的变量通常会有一个随机的值，这个值基于那一刻内存中的内容，因此这也是无数错误的根源。C++中，变量在声明时可以选择赋予一个初始值。下面的代码展示了两种风格的变量声明，使用了表示整数值的int类型：

\begin{cpp}
int uninitializedInt;
int initializedInt { 7 };
println("{} is a random value", uninitializedInt);
println("{} was assigned as an initial value", initializedInt);
\end{cpp}

\begin{myNotic}{NOTE}
当代码使用未初始化的变量时，大多数编译器都会发出警告或错误。有些编译器会生成在运行时报错的代码。
\end{myNotic}

initializedInt变量可以使用统一的初始化语法进行初始化，也可以使用下面的赋值语法来初始化变量:

\begin{cpp}
int initializedInt = 7;
\end{cpp}

统一初始化是在2011年随C++11标准引入的。建议使用统一初始化来代替旧的赋值语法，本书也使用了这种语法。后面，会在“统一初始化”的章节中更深入地探讨其优点，以及推荐使用的原因。

C++中的变量是强类型的，所以总是具有特定的类型。C++提供了一套完整的内置类型，可以直接使用。下表展示了最常见的一些类型：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{类型} &
\textbf{描述} &
\textbf{用法} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}(signed) int\\ signed\end{tabular} &
\begin{tabular}[c]{@{}l@{}}正、负整数;范围取决于编译器\\ (通常为4字节)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}int i \{-7\};\\ signed int i \{-6\};\\ signed i \{-5\};\end{tabular} \\ \hline
(signed) short (int) &
短整数(通常为2字节) &
\begin{tabular}[c]{@{}l@{}}short s \{13\};\\ short int s \{14\};\\ signed short s \{15\};\\ signed short int s \{16\};\end{tabular} \\ \hline
(signed) long (int) &
长整数(通常为4字节) &
long l \{-7L\}; \\ \hline
(signed) long long (int) &
\begin{tabular}[c]{@{}l@{}}超长整型;该范围取决于编译器，\\ 但至少与长整数相同\\ (通常为8字节)\end{tabular} &
long long ll \{14LL\}; \\ \hline
\begin{tabular}[c]{@{}l@{}}unsigned (int)\\ unsigned short (int)\\ unsigned long (int)\\ unsigned long long (int)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}将上述类型限制为\textgreater{}= 0的值\end{tabular} &
\begin{tabular}[c]{@{}l@{}}unsigned int i \{2U\};\\ unsigned j \{5U\};\\ unsigned short s \{23U\};\\ unsigned long l \{54UL\};\\ unsigned long long ll \{140ULL\};\end{tabular} \\ \hline
float &
\begin{tabular}[c]{@{}l@{}}单精度浮点数\end{tabular} &
float f \{7.2f\}; \\ \hline
double &
\begin{tabular}[c]{@{}l@{}}双精度浮点数;\\ 精度至少与float相同\end{tabular} &
double d \{7.2\}; \\ \hline
long double &
\begin{tabular}[c]{@{}l@{}}长双精度浮点数;\\ 精度至少与double相同\end{tabular} &
long double d \{16.98L\}; \\ \hline
\begin{tabular}[c]{@{}l@{}}char\\ unsigned char\\ signed char\end{tabular} &
单个字符 &
char ch \{'m'\}; \\ \hline
\begin{tabular}[c]{@{}l@{}}char8\_t\\ char16\_t\\ char32\_t\end{tabular} &
\begin{tabular}[c]{@{}l@{}}单个n位UTF-n编码的Unicode字符，\\ 其中n可以是8、16或32\end{tabular} &
\begin{tabular}[c]{@{}l@{}}char8\_t c8 \{u8'm'\};\\ char16\_t c16 \{u'm'\};\\ char32\_t c32 \{U'm'\};\end{tabular} \\ \hline
wchar\_t &
\begin{tabular}[c]{@{}l@{}}单个宽字符;大小取决于编译器\end{tabular} &
wchar\_t w \{L'm'\}; \\ \hline
bool &
\begin{tabular}[c]{@{}l@{}}布尔类型，有两个可能值:true或false\end{tabular} &
bool b \{true\}; \\ \hline
\end{longtable}

有符号整数和无符号整数以及char类型的范围如下:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{类型}                                             & \textbf{有符号}                 & \textbf{无符号}  \\ \hline
\endfirsthead
%
\endhead
%
char                                                      & -128 - 127                     & 0 - 255           \\ \hline
\begin{tabular}[c]{@{}l@{}}2字节的整数\end{tabular} & -32,768 - 32,767               & 0 - 65,535        \\ \hline
\begin{tabular}[c]{@{}l@{}}4字节的整数\end{tabular} & -2,147,483,648 - 2,147,483,647 & 0 - 4,294,967,295 \\ \hline
\begin{tabular}[c]{@{}l@{}}8字节的整数\end{tabular} &
\begin{tabular}[c]{@{}l@{}}-9,223,372,036,854,775,808 -\\ 9,223,372,036,854,775,807\end{tabular} &
0 - 18,446,744,073,709,551,615 \\ \hline
\end{longtable}

char类型与有符号char和无符号char类型相比是一种不同的类型，只用于表示字符。根据编译器的不同，可以有符号，也可以无符号。

浮点类型的范围和精度将在本章的“浮点数”一节中讨论。

与char相关的是，<cstddef>提供了std::byte类型，表示单个字节。C++17之前，使用char或unsigned char来表示字节，但这些类型看起来像是在处理字符。另一方面，std::byte可以清楚地说明意图，即单个字节的内存。字节可以按如下方式初始化:

\begin{cpp}
std::byte b { 42 };
\end{cpp}

\begin{myNotic}{NOTE}
C++不提供基本的字符串类型。但作为标准库的一部分，提供了字符串的标准实现，本章稍后会简单说明一下，详细讨论将在第2章进行。
\end{myNotic}

\mySamllsection{数值范围}

C++提供了一种标准的方法来获取有关数字限制的信息，例如：当前平台上整数的最大可能值。C可以访问常量，例如INT\_MAX。这些在C++中仍然可用，但建议使用<limits>中定义的std::numeric\_limits类模板。类模板将在本书后面讨论，这些细节对于理解如何使用numeric\_limits并不重要。现在，只需要知道，它是一个类模板，所以必须在一组尖括号之间指定类型。例如，要获取整数的数值限制，可以编写std::numeric\_limits<int>。参考标准库参考(参见附录B)，了解使用numeric\_limits可以查询哪些类型的信息。

举一些例子：

\begin{cpp}
println("int:");
println("Max int value: {}", numeric_limits<int>::max());
println("Min int value: {}", numeric_limits<int>::min());
println("Lowest int value: {}", numeric_limits<int>::lowest());

println("\ndouble:");
println("Max double value: {}", numeric_limits<double>::max());
println("Min double value: {}", numeric_limits<double>::min());
println("Lowest double value: {}", numeric_limits<double>::lowest());
\end{cpp}

这些代码在我的系统上的输出:

\begin{shell}
int:
Max int value: 2147483647
Min int value: -2147483648
Lowest int value: -2147483648
double:
Max double value: 1.7976931348623157e+308
Min double value: 2.2250738585072014e-308
Lowest double value: -1.7976931348623157e+308
\end{shell}

注意min()和lowest()之间的区别。对于整数，最小值等于最小值。然而，对于浮点类型，最小值是可以表示的最小正值，而最小值是可以表示的最大负值，等于-max()。

\mySamllsection{零初始化}

变量可以用\{0\}初始化为零，也可以用零初始化器\{\}。零初始化将基本整数类型(如char、int等)初始化为零，将基本浮点类型初始化为0.0，将指针类型初始化为nullptr，并使用默认构造函数构造对象(稍后讨论)。

下面是零初始化浮点型和int型的例子:

\begin{cpp}
float myFloat {};
int myInt {};
\end{cpp}

\mySamllsection{类型转换}

变量可以通过强制转换转换为其他类型。例如，可以将float类型强制转换为int类型。c++提供了三种显式更改变量类型的方法。第一个方法是从C语言继承来的，不推荐使用，但这种方法仍然广泛使用。第二种方法很少使用。第三种方法是最冗长的，但也最干净，推荐使用。

\begin{cpp}
float myFloat { 3.14f };
int i1 { (int)myFloat }; // method 1
int i2 { int(myFloat) }; // method 2
int i3 { static_cast<int>(myFloat) }; // method 3
\end{cpp}

得到的整数将是截断小数部分的浮点数的值。第10章“了解继承”更详细地描述了不同的类型转换方法。某些上下文中，可以自动强制转换或强制转换变量。例如，因为long表示至少具有相同精度的相同类型的数据，short可以自动转换为long:

\begin{cpp}
long someLong { someShort }; // no explicit cast needed
\end{cpp}

自动转换变量时，需要注意潜在的数据丢失。例如，将浮点型转换为int型会丢掉数字的小数部分，若浮点值表示的数字大于可表示的最大整数值，则得到的整数甚至是错误的。若将float赋值给int而不进行显式强制类型转换，大多数编译器将发出警告，甚至报错。若确定左侧类型与右侧类型完全兼容，则可以进行隐式强制转换。

\mySamllsection{浮点数}

处理浮点数比处理整型更复杂，使用数量级不同的浮点值进行计算可能会导致错误。此外，计算两个几乎相同的浮点数之间的差会导致精度的损失。并且，许多十进制值不能精确地表示为浮点数。深入讨论使用浮点数的数值问题，以及如何编写数值稳定的浮点算法超出了本书的范围。

有几种特殊的浮点数:

\begin{itemize}
\item
\textbf{正/负无穷大}:表示正无穷大和负无穷大，例如：非零数除以零的结果

\item
\textbf{NaN}: 非数字的缩写，例如0除以0的结果，数学上未定义的结果
\end{itemize}

要检查给定的浮点数是否不是数字，请使用std::isnan()。要检查无穷大，使用std::isinf()。这两个函数都在<cmath>中定义。

要获得这些特殊的浮点值，请使用numeric\_limits，例如std::numeric\_limits<double>::infinity()。

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{扩展浮点数类型}

正如前面关于变量的部分所提到的，C++提供了以下标准浮点类型:float、double和long double。

C++23引入了以下扩展的浮点类型，这些类型在某些领域已经变得很流行。对这些类型的支持可选，并不是所有编译器都提供这些类型。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{类型}    & \textbf{描述}                               & \textbf{字面量后缀} \\ \hline
\endfirsthead
%
\endhead
%
std::float16\_t  & IEEE 754标准的16位格式。         & F16 或 f16              \\ \hline
std::float32\_t  & IEEE 754标准的32位格式。          & F32 或 f32              \\ \hline
std::float64\_t  & IEEE 754标准的64位格式。          & F64 或 f64              \\ \hline
std::float128\_t & IEEE 754标准的128位格式。         & F128 或 f128            \\ \hline
std::bfloat16\_t & 脑浮点数，用于某些AI领域。 & BF16 或 bf16            \\ \hline
\end{longtable}

大脑浮点数:由谷歌人工智能团队Google Brain开发。用于人工智能处理器，并持最新的NVIDIA GPU。

大多数情况下，标准类型float、double和long double就足够了。因此，double应该是您的默认类型。使用float可能会导致精度损失，损失是否可接受，要具体情况具体分析。

\mySamllsection{浮点类型的范围和精度}

浮点类型具有有限的范围和有限的精度，下表给出了C++支持的所有标准和扩展浮点类型的详细规范。标准类型(float、double和long double)的规范并没有在C++标准中明确规定。标准只要求long double至少具有与double相同的精度，而double至少具有与float相同的精度。对于这三种类型，下表展示了主流编译器常用的值。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|l|l|l|l|}
\hline
\textbf{类型} &
\textbf{名称} &
\textbf{尾数位} &
\textbf{小数位数} &
\textbf{指数位} &
\textbf{最小值} &
\textbf{最大值} \\ \hline
\endfirsthead
%
\endhead
%
float           & \begin{tabular}[c]{@{}l@{}}单精度\end{tabular}   & 24 & 7.22  & 8  & $1.18$x$10^{-38}$   & $3.40$x$10^{38}$   \\ \hline
double          & \begin{tabular}[c]{@{}l@{}}双精度\end{tabular}   & 53 & 15.95 & 11 & $2.23$x$10^{-308}$  & $1.80$x$10^{308}$  \\ \hline
long double     & \begin{tabular}[c]{@{}l@{}}扩展精度\end{tabular} & 64 & 19.27 & 15 & $3.36$x$10^{-4932}$ & $1.19$x$10^{4932}$ \\ \hline
std::float16\_t & \begin{tabular}[c]{@{}l@{}}半精度\end{tabular}     & 11 & 3.31  & 5  & $6.10$x$10^{-5}$    & $65504$       \\ \hline
std::float32\_t & \begin{tabular}[c]{@{}l@{}}单精度\end{tabular}   & 24 & 7.22  & 8  & $1.18$x$10^{-38}$   & $3.40$x$10^{38}$   \\ \hline
std::float64\_t & \begin{tabular}[c]{@{}l@{}}双精度\end{tabular}   & 53 & 15.95 & 11 & $2.23$x$10^{-308}$  & $1.80$x$10^{308}$  \\ \hline
std::float128\_t &
\begin{tabular}[c]{@{}l@{}}四倍精度\end{tabular} &
113 &
34.02 &
15 &
$3.36$x$10^{-4932}$ &
$1.19$x$10^{4932}$ \\ \hline
std::bfloat16\_t &
\begin{tabular}[c]{@{}l@{}}脑浮点\end{tabular} &
8 &
2.41 &
8 &
$1.18$x$10^{-38}$ &
$3.40$x$10^{38}$ \\ \hline
\end{longtable}

\mySubsubsection{1.1.5.}{操作符}

除了改变一个变量，它还有什么用呢?下表显示了C++中常用的操作符，以及使用这些操作符的示例代码。C++中的操作符可以是二进制(对两个表达式进行操作)、一元(对单个表达式进行操作)，甚至三元(对三个表达式进行操作)。C++中只有一种三元运算符，本章后面的“条件运算符”一节中对其进行了解释。此外，第15章“重载C++操作符”会解释如何在自己的自定义类型中，添加对这些操作符的支持。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{操作符} &
\textbf{描述} &
\textbf{用法} \\ \hline
\endfirsthead
%
\endhead
%
= &
\begin{tabular}[c]{@{}l@{}}将右边的值赋给左边表达式的二元操作符\end{tabular} &
\begin{tabular}[c]{@{}l@{}}int i;\\ i = 3;\\ int j;\\ j = i;\end{tabular} \\ \hline
! &
\begin{tabular}[c]{@{}l@{}}用于补充表达式的真/假(非0/0)状态的一元操作符\end{tabular} &
\begin{tabular}[c]{@{}l@{}}bool b \{!true\};\\ bool b2 \{!b\};\end{tabular} \\ \hline
+ &
用于加法的二进制运算符 &
\begin{tabular}[c]{@{}l@{}}int i \{3 + 2\};\\ int j \{i + 5\};\\ int k \{i + j\};\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}-\\ *\\ /\end{tabular} &
用于减法、乘法和除法的二进制运算符 &
\begin{tabular}[c]{@{}l@{}}int i \{5 – 1\};\\ int j \{5 * 2\};\\ int k \{j / i\};\end{tabular} \\ \hline
\% &
\begin{tabular}[c]{@{}l@{}}除法运算余数的二进制运算符，也称为取模或取模算子。\\ 例如: 5\%2=1\end{tabular} &
int rem \{5 \% 2\}; \\ \hline
++ &
\begin{tabular}[c]{@{}l@{}}一元运算符，将表达式加1。\\ 若运算符出现在表达式之后或自增后，则表达式的结果是未自增的值\\ 若运算符出现在表达式之前，或者在递增前，表达式的结果就是新值\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i++;\\ ++i;\end{tabular} \\ \hline
-- &
一元运算符，将表达式减1。 &
\begin{tabular}[c]{@{}l@{}}i--;\\ --i;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}+=\\ -=\\ *=\\ /+\\ \%=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}简写语法:\\ i = i + (j);\\ i = i - (j);\\ i = i * (j);\\ i = i / (j);\\ i = i \% (j);\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i += j;\\ i -= j;\\ i *= j;\\ i /= j;\\ i \%= j;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}\&\\ \&=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}获取变量的位表达式，并与另一个表达式按位执行与运算。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = j \& k;\\ j \&= k;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}|\\ |=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}获取变量的位表达式，并对另一个表达式执行位或运算。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = j | k;\\ j |= k;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}\textless{}\textless\\ \textgreater{}\textgreater\\ \textless{}\textless{}=\\ \textgreater{}\textgreater{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}获取表达式的原始位，并将每个位向左\\ (\textless{}\textless{})或向右(\textgreater{}\textgreater{})移动”指定的位数。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = i \textless{}\textless 1;\\ i = i \textgreater{}\textgreater 4;\\ i \textless{}\textless{}= 1;\\ i \textgreater{}\textgreater{}= 4;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}\textasciicircum\\ \textasciicircum{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}对两个表达式执行位异或操作，也称为异或操作。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = i \textasciicircum j;\\ i \textasciicircum{}= j;\end{tabular} \\ \hline
\end{longtable}

op=形式的操作符，例如+=，称为复合赋值操作符。

当二元操作符应用于两个不同类型的操作数时，编译器会插入隐式转换。在应用该操作符之前，将其中一个操作数转换为另一个操作数。还可以使用static\_cast()使用显式转换将一种类型转换为另一种类型。

对于隐式转换，编译器有一定的规则来决定将哪个类型转换为另一个类型。例如，对于具有小整数类型和大整数类型的二进制操作，较小的类型将转换为较大的类型。然而，结果可能并不总是像你期望的那样，所以建议谨慎使用隐式转换，并使用显式转换，以确保编译器按开发者的期望工作。

下面的代码片段显示了最常见的变量类型和操作符。还展示了显式转换，并解释了为什么需要转换。若不确定变量和操作符是如何工作的，请尝试预测这个程序的输出将是什么，然后运行它来确认答案。

\begin{cpp}
int someInteger { 256 };
short someShort;
long someLong;
float someFloat;
double someDouble;

someInteger++;
someInteger *= 2;
// Conversion from larger integer type to smaller integer type
// can cause a warning or error, hence static_cast() is required.
someShort = static_cast<short>(someInteger);
someLong = someShort * 10000;
someFloat = someLong + 0.785f;
// To make sure the division is performed with double precision,
// someFloat is explicitly converted to double first.
someDouble = static_cast<double>(someFloat) / 100000;
println("{}", someDouble);
\end{cpp}

C++编译器有一个表达式计算的顺序。若有一个包含许多操作符的复杂表达式，则执行顺序可能不明显。出于这个原因，最好将一个复杂的表达式分解成几个较小的表达式，或者通过使用括号显式地对子表达式进行分组。例如，除非知道操作符的准确求值顺序，否则下面这行代码的计算顺序可能会令人困惑:

\begin{cpp}
int i { 34 + 8 * 2 + 21 / 7 % 2 };
\end{cpp}

添加括号可以明确哪些操作先发生:

\begin{cpp}
int i { 34 + (8 * 2) + ( (21 / 7) % 2 ) };
\end{cpp}

对于在家练习的同学来说，这两种方法是相等的，最后i等于51。若假设C++从左到右计算表达式，则的答案将是1。C++首先计算/，*和\%(按从左到右的顺序)，然后是加法和减法，然后是位运算符。括号可以显式地告诉编译器应该首先计算某个操作。

形式上，运算符的求值顺序由它们的优先级表示，优先级高的操作符在优先级低的操作符之前执行。下面的列表显示了上表中操作符的优先级，列表中较高的操作符具有较高的优先级，因此在列表中较低的操作符之前执行。

\begin{itemize}
\item
++ \enspace −{}− (后置)

\item
! \enspace ++ \enspace −{}− (前置)

\item
* \enspace / \enspace \%

\item
+ \enspace −

\item
<{}< \enspace >{}>

\item
\&

\item
\textasciicircum

\item
|

\item
= \enspace += \enspace -= \enspace *= \enspace /= \enspace \%= \enspace \&= \enspace |= \enspace \textasciicircum= \enspace <{}<= \enspace >{}>=

\end{itemize}

这只是一些常用的C++操作符。第15章给出了所有可用操作符的完整概述，包括其优先级。

\mySubsubsection{1.1.6.}{枚举}

整数实际上表示较大的值集合中的一个值——整个整数序列。枚举是允许自定义序列的类型，这样就可以用该序列中的值声明变量。例如，在国际象棋程序中，可以将每个棋子表示为int，并用常量表示棋子类型，如下面的代码所示。表示类型的整数标记为const，表明永远不会改变。

\begin{cpp}
const int PieceTypeKing { 0 };
const int PieceTypeQueen { 1 };
const int PieceTypeRook { 2 };
const int PieceTypePawn { 3 };
//etc.
int myPiece { PieceTypeKing };
\end{cpp}

这种表示可能会变得危险。由于piece只是一个int类型，若另一个开发者添加代码来增加piece的值，会发生什么?加1，国王就变成了王后，这真的没有意义。更糟糕的是，有人可能会给一个片段一个-1的值，而这个值没有对应的常数。

强类型枚举通过严格定义变量的值范围来解决这些问题。下面的代码声明了一个新类型PieceType，有四个可能的值，称为枚举数，代表四个棋子:

\begin{cpp}
enum class PieceType { King, Queen, Rook, Pawn };
\end{cpp}

这个新类型可以像下面这样使用:

\begin{cpp}
PieceType piece { PieceType::King };
\end{cpp}

枚举只是一个整数值，King、Queen、Rook和Pawn的基本值分别为0、1、2和3。可以自己指定枚举数的整数值:

\begin{cpp}
enum class PieceType
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};
\end{cpp}

若没有给枚举数赋值，编译器会自动给它赋一个上一个枚举数加1的值。若果不给第一个枚举数赋值，编译器将给它赋值0。所以这个例子中，King的整数值是1，Queen的值是编译器赋值的2，Rook的值是10，Pawn的值是编译器自动赋值的11。

尽管枚举数在内部由整数值表示，但不会自动转换为整数，所以以下操作是非法的:

\begin{cpp}
int underlyingValue { piece };
\end{cpp}

\CXXTwentythreeLogo{-40}{-35}

C++23开始，可以使用std::to\_underlying()。例如:

\begin{cpp}
int underlyingValue { to_underlying(piece) };
\end{cpp}

默认情况下，枚举数的基础类型是整数，但也可以这样修改:

\begin{cpp}
enum class PieceType : unsigned long
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};
\end{cpp}

对于枚举类，枚举数名称不会自动导出到封闭作用域，所以不会与父作用域中已经定义的其他名称冲突，从而不同的强类型枚举可以具有相同名称的枚举数。例如，下面两个枚举完全合法:

\begin{cpp}
enum class State { Unknown, Started, Finished };
enum class Error { None, BadInput, DiskFull, Unknown };
\end{cpp}

这样做的一大好处是，可以为枚举器提供简短的名称，用Unknown代替UnknownState和UnknownError。但必须完全限定枚举值，或者使用using enum或using声明。下面是using enum声明的一个例子:

\begin{cpp}
using enum PieceType;
PieceType piece { King };
\end{cpp}

若希望避免完全限定特定枚举数，可以使用using声明。例如，在下面的代码片段中，King可以在没有完全限定的情况下使用，但其他枚举数仍然需要完全限定:

\begin{cpp}
using PieceType::King;
PieceType piece { King };
piece = PieceType::Queen;
\end{cpp}

\begin{myWarning}{WARNING}
尽管C++允许您避免完全限定的枚举器，但建议谨慎使用该特性。至少要缩小using enum或using声明的作用域，因为若这个作用域太大，就有可能重新引入名称冲突。本章后面关于switch语句的部分，展示了using enum声明的适当作用域用法。
\end{myWarning}

\mySamllsection{旧式枚举}

新代码应该始终使用前一节中解释的强类型枚举。但在遗留代码库中，可能会看到旧式枚举，也称为无作用域枚举:enum，而非enum类。下面是之前定义为旧式枚举的PieceType:

\begin{cpp}
enum PieceType { PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn };
\end{cpp}

这种旧式枚举的枚举数导出到封闭作用域。所以在父作用域中，可以使用枚举数的名称而不完全限定它们，例如:

\begin{cpp}
PieceType myPiece { PieceTypeQueen };
\end{cpp}

当然，它们可能与父作用域中已经定义的其他名称冲突，从而导致编译错误。这里有一个例子:

\begin{cpp}
bool ok { false };
enum Status { error, ok };
\end{cpp}

这段代码片段无法编译，因为名称ok首先定义为一个布尔变量，之后又将相同的名称用作枚举数的名称。Visual C++ 2022会出现以下错误:

\begin{shell}
error C2365: 'ok': redefinition; previous definition was 'data variable'
\end{shell}

因此，应该确保这种旧式枚举具有具有唯一名称的枚举数，例如PieceTypeQueen，而不是简单的Queen。

这些旧式枚举不是强类型的，所以类型不安全。它们可解释为整数，所以会无意中比较来自完全不同枚举的枚举数，或者将错误枚举类型的枚举数传递给函数。

\begin{myWarning}{WARNING}
始终使用强类型枚举类枚举，而不是旧式的、无作用域的、类型不安全的枚举类型。
\end{myWarning}

\mySubsubsection{1.1.7.}{结构体}

结构体允许将一个或多个现有类型封装成一个新的类型，其经典示例是数据库。若正在构建一个人事系统来跟踪员工信息，可能希望存储每个员工的姓名首字母、姓氏首字母、员工编号和薪资。以下employee.cppm模块接口文件中展示了一个包含所有这些信息的结构体，这是目前编写的第一个模块。模块接口文件通常具有.cppm扩展名。模块接口文件的第一行是一个模块声明，表明这个文件正在定义一个名为employee的模块。此外，模块需要明确声明它导出了什么，即当这个模块在其他地方导入时，哪些内容可见。通过在例如结构体前加上export关键字，可以从模块中导出一个类型。

\begin{cpp}
export module employee;

export struct Employee {
    char firstInitial;
    char lastInitial;
    int employeeNumber;
    int salary;
};
\end{cpp}

使用类型Employee声明的变量内置了所有这些字段，结构体的各个字段可以通过使用.运算符来访问。下面的示例创建然后输出一个员工的记录，与导入标准命名模块std一样，导入自定义模块时也不使用尖括号。

\begin{cpp}
import std;
import employee; // Import our employee module

using namespace std;

int main()
{
    // Create and populate an employee.
    Employee anEmployee;
    anEmployee.firstInitial = 'J';
    anEmployee.lastInitial = 'D';
    anEmployee.employeeNumber = 42;
    anEmployee.salary = 80000;
    // Output the values of an employee.
    println("Employee: {}{}", anEmployee.firstInitial,
        anEmployee.lastInitial);
    println("Number: {}", anEmployee.employeeNumber);
    println("Salary: ${}", anEmployee.salary);
}
\end{cpp}

\mySubsubsection{1.1.8.}{条件语句}

条件语句允许你根据某个条件是否为真来执行代码。如下节所示，C++中有两种主要的条件语句：if/else语句和switch语句。

\mySamllsection{if/else}

最常见的条件语句是if语句，可以伴随一个else。若if语句内部给出的条件为真，则执行该行或代码块；否则，继续执行当前if语句的else情况（若存在），或者执行条件语句之后的代码。以下代码展示了一个级联if语句，花哨的说法是if语句有一个else语句，而这个else语句又有一个if语句，依此类推：

\begin{cpp}
if (i > 4) {
    // Do something.
} else if (i > 2) {
    // Do something else.
} else {
    // Do something else.
}
\end{cpp}

if语句括号内的表达式必须是布尔值或计算结果为布尔值。值为0的计算结果为false，而任何非零值的计算结果为true。例如，if(0)等同于if(false)。后面将描述的逻辑评估运算符提供了一种方法，用于计算表达式以产生true或false的布尔值。

\mySamllsection{if语句的初始化式}

C++允许你在if语句中使用以下语法包含一个初始化表达式：

\begin{cpp}
if (<initializer>; <conditional_expression>) {
    <if_body>
} else if (<else_if_expression>) {
    <else_if_body>
} else {
    <else_body>
}
\end{cpp}

<initializer>中引入的变量仅在<conditional\_expression>、<if\_body>、所有<else\_if\_expression>和<else\_if\_body>，以及<else\_body>中可用。这样的变量在if语句外部不可用。

给出这个功能的例子还为时过早，但这里有一个如何使用它的例子:

\begin{cpp}
if (Employee employee { getEmployee() }; employee.salary > 1000) { ... }
\end{cpp}

这个例子中，初始化器通过调用getEmployee()函数来获取一个员工，条件检查检索到的员工的薪资是否超过1000。只有在这种情况 下，才会执行if语句的主体。本书将在后续提供更具体的例子。

\mySamllsection{switch}

switch语句是基于表达式值执行操作的一种替代语法。在C++中，switch语句的表达式必须是整型、可转换为整型的类型、枚举或强类型枚举，并且必须与常量进行比较。每个常量值代表一个“case”。若表达式与某个case匹配，就会执行后续的代码，直到遇到break语句。还可以提供一个default，若其他case都不匹配，就会执行default。以下伪代码展示了switch语句的常见用法：

\begin{cpp}
switch (menuItem) {
    case OpenMenuItem:
        // Code to open a file
        break;
    case SaveMenuItem:
        // Code to save a file
        break;
    default:
        // Code to give an error message
        break;
}
\end{cpp}

switch语句可以转换为if/else语句。前面的switch语句可以转换为如下形式：

\begin{cpp}
if (menuItem == OpenMenuItem) {
    // Code to open a file
} else if (menuItem == SaveMenuItem) {
    // Code to save a file
} else {
    // Code to give an error message
}
\end{cpp}

switch语句通常根据表达式的多个特定值执行操作时使用，而不是对表达式进行某种测试。这种情况下，switch语句避免了级联的if/else语句。若只需要检查一个值，使用if或if/else语句就可以。

当找到与switch条件匹配的case表达式，就会执行跟随其后的所有语句，直到遇到break语句。即使遇到另一个case表达式，这种执行也会继续，这称为“fallthrough”（穿透）。在下面的例子中，对于Mode::Standard和Default，执行的是同一组语句。若mode是Custom，则value首先从42改为84，之后Standard和Default的语句也会执行。换句话说，Custom案例会穿透执行，直到最终遇到一个break语句或switch语句的末尾。这段代码还展示了使用适当作用域的using enum声明的好例子，避免了在不同case标签上写Mode::Custom, Mode::Standard和Mode::Default的必要。

\begin{cpp}
enum class Mode { Default, Custom, Standard };

int value { 42 };
Mode mode { /* ... */ };
switch (mode) {
    using enum Mode;

    case Custom:
        value = 84;
    case Standard:
    case Default:
        // Do something with value ...
        break;
}
\end{cpp}

穿透可能会导致错误，例如不小心忘记了一个break语句。因此，一些编译器会在switch语句中检测穿透情况，除非case为空，否则会给出一个警告。之前的例子中，没有编译器会警告Standard案例穿透到Default案例，但是对于Custom案例的穿透，编译器可能会给出警告。为了避免这个警告，并让读者和编译器清楚穿透是有意的，可以使用一个[[fallthrough]]属性：

\begin{cpp}
switch (mode) {
    using enum Mode;

    case Custom:
        value = 84;
        [[fallthrough]];
    case Standard:
    case Default:
        // Do something with value ...
        break;
}
\end{cpp}

通常情况下，围绕在case表达式后面的语句周围的括号是可选的，但在定义变量时，是必要的：

\begin{cpp}
switch (mode) {
    using enum Mode;
    case Custom:
        {
            int someVariable { 42 };
            value = someVariable * 2;
            [[fallthrough]];
        }
    case Standard:
    case Default:
        // Do something with value ...
        break;
}
\end{cpp}

当使用switch语句处理枚举时，若没有为所有的枚举器处理所有不同的情况，大多数编译器会发出警告，无论是通过为每个枚举器显式编写case，还是通过仅为选择的一部分枚举器编写case并有一个default。这里，建议在处理枚举的switch语句中不要包含default，而应该显式地列出所有的枚举器。因为以后向枚举中添加更多的枚举值，这样做会使代码更容易避免错误。若忘记将新的枚举值添加到特定的switch语句中，编译器将发出警告，而不是默默地使用default处理新的枚举值。

\mySamllsection{switch语句的初始化式}

就像if语句一样，可以在switch语句中使用初始化式。语法如下：

\begin{cpp}
switch (<initializer>; <expression>) { <body> }
\end{cpp}

<initializer>中引入的变量仅在<expression>和<body>中可用，其在switch语句外部不可用。

\mySubsubsection{1.1.9.}{条件运算符}

C++有一个接受三个参数的运算符，称为三元运算符。可用作一种简短的条件表达式，即“如果[某事]为真，则[执行动作]，否则[执行其他动作]”。条件运算符由?和:表示。以下代码在变量i大于2时输出“yes”，否则输出“no”：

\begin{cpp}
println("{}", (i > 2) ? "yes" : "no");
\end{cpp}

i > 2周围的括号是可选的，等价与下面的代码:

\begin{cpp}
println("{}", i > 2 ? "yes" : "no");
\end{cpp}

其优势在于它是一个表达式，而不是像if和switch语句那样的语句。前面的例子中，条件运算符可用在执行输出的代码中。记住这种语法使用的一个方便方法是，将问号前面的语句当作一个真正的问题。"例如，i大于2吗？若是，结果是'yes'；若不是，结果是'no'。"

\mySubsubsection{1.1.10.}{逻辑求值运算符}

您已经看到了一个逻辑评估运算符，但没有正式的定义，运算符>会比较两个值。若左边的值大于右边的值，结果为真。所有逻辑评估运算符都遵循这种模式——其结果是真或假。

下表给出了常见的逻辑求值运算符:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{运算符} &
\textbf{描述} &
\textbf{用法} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}\textless\\ \textless{}=\\ \textgreater\\ \textgreater{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}确定左边是否小于、小于或等于、大于或大于或等于右边。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (i \textless 0) \{\\   print("i is negative");\\ \}\end{tabular} \\ \hline
== &
\begin{tabular}[c]{@{}l@{}}确定左边是否等于右边。不要将它与=(赋值)操作符混淆!\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (i == 3) \{\\   print("i is 3");\\ \}\end{tabular} \\ \hline
!= &
\begin{tabular}[c]{@{}l@{}}不是等号。若左边不等于右边，这个语句的结果为true。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (i != 3) \{\\   print("i is not 3");\\ \}\end{tabular} \\ \hline
\textless{}=\textgreater{} &
\begin{tabular}[c]{@{}l@{}}三向比较运算符，也称为太空飞船运算符。\\ 下一节将更详细地解释。\end{tabular} &
result = i \textless{}=\textgreater 0; \\ \hline
! &
\begin{tabular}[c]{@{}l@{}}逻辑否。这是布尔表达式true/false状态的补充，\\ 是一个一元算子。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (!bool1) \{\\   print("bool1 is false");\\ \}\end{tabular} \\ \hline
\&\& &
\begin{tabular}[c]{@{}l@{}}逻辑。若表达式的两个部分都为真，则结果为真。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (bool1 \&\& bool2) \{\\   print("both are true");\\ \}\end{tabular} \\ \hline
|| &
\begin{tabular}[c]{@{}l@{}}逻辑或。若表达式的任何一部分为真，则结果为真。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (bool1 || bool2) \{\\   print("at least one is true");\\ \}\end{tabular} \\ \hline
\end{longtable}

C++在评估逻辑表达式时使用短路逻辑，当最终结果确定，表达式的其余部分将不会计算。例如，若对几个布尔表达式执行逻辑或操作，如以下代码所示，当发现其中一个为真，结果就已知为真，其余的部分就不会进行检查了。

\begin{cpp}
bool result { bool1 || bool2 || (i > 7) || (27 / 13 % i + 1) < 2 };
\end{cpp}

这个例子中，若bool1为真，则整个表达式必须为真，因此其他部分不会计算。这样，语言避免了你的代码做不必要的工作。然而，若后续的子表达式以某种方式影响程序的状态（例如，通过调用一个单独的函数），这可能会成为难以发现的错误的来源。

下面的代码显示了一个使用\&\&的语句，因为0的计算结果总是为false，所以该语句在第二项之后短路:

\begin{cpp}
bool result { bool1 && 0 && (i > 7) && !done };
\end{cpp}

短路可以带来性能上的好处，可以将资源消耗较少的测试放在前面，这样当逻辑短路时，更昂贵的测试不会执行到。指针的上下文中，因为其可以避免在指针无效时执行表达式的某些部分，所以短路也是非常有用的。指针和指针的短路将在本章后面继续讨论。

\mySubsubsection{1.1.11.}{三元比较运算符}

三路比较运算符可以用来确定两个值的顺序，也称为太空船运算符，因为其符号<=>像一艘太空船。使用单个表达式，可以了解一个值是等于、小于还是大于另一个值。因为它必须返回的不仅是真或假，所以它不能返回布尔类型。相反，它返回一个在std命名空间中<compare>定义的类枚举类型。若操作数是整型，结果是一个强序，可以是以下之一：

\begin{itemize}
\item
strong\_ordering::less: 第一个操作数小于第二个

\item
strong\_ordering::greater: 第一个操作数大于第二个

\item
strong\_ordering::equal: 第一个操作数等于第二个操作数
\end{itemize}

下面是它的用法:

\begin{cpp}
int i { 11 };
strong_ordering result { i <=> 0 };
if (result == strong_ordering::less) { println("less"); }
if (result == strong_ordering::greater) { println("greater"); }
if (result == strong_ordering::equal) { println("equal"); }
\end{cpp}

某些类型没有顺序关系。例如，非数（NaN）浮点值永远不会等于、小于或大于任何其他浮点值，所以这种比较结果是一个偏序关系：

\begin{itemize}
\item
partial\_ordering::less: 第一个操作数小于第二个

\item
partial\_ordering::greater: 第一个操作数大于第二个

\item
partial\_ordering::equivalent: 第一个操作数相当于第二个操作数，!(a<b) \&\& !(b<a);例如，-0.0等于+0.0，但它们其实不相等

\item
partial\_ordering::unordered: 若一个或两个操作数都不是数字
\end{itemize}

若真的需要浮点值的强排序，例如，知道比较的两个数是数字，可以使用std::strong\_order()，会产生一个std::strong\_ordering结果。

还有一种弱序关系，可以用来为自定义类型实现三路比较的附加排序类型。弱序关系中，所有值都有序，即没有无序结果，但排序不是强序，所以可能存在实际不等，但使用时等价的值。一个例子是对字符串进行不区分大小写的比较，字符串“Hello World”和“hello world”显然不相等，但它们等价。以下是弱序关系的不同结果：

\begin{itemize}
\item
weak\_ordering::less: 第一个操作数小于第二个

\item
weak\_ordering::greater: 第一个操作数大于第二个

\item
weak\_ordering::equivalent: 第一个操作数等同于第二个操作数
\end{itemize}

三种不同类型的排序支持某些隐式转换。强排序（strong\_ordering）可以隐式转换为偏排序（partial\_ordering）或弱排序（weak\_ordering）。弱排序（weak\_ordering）可以隐式转换为偏排序（partial\_ordering）。

对于基本类型来说，使用三路比较操作符相比于直接使用 ==、<和>操作符进行单个比较，并没有带来太多优势。但当涉及到比较成本较高的对象时，三路比较操作符就变得非常有用了。使用三路比较操作符，这类对象可以通过单个操作符进行排序，而不需要调用两个单独的比较操作符，从而进行两次昂贵的比较。第9章“类和对象”解释了如何为自己的类型添加对三路比较的支持。

最后，<compare>提供了命名比较函数来解释排序的结果。这些函数是std::is\_eq(), is\_neq(), is\_lt(), is\_lteq(), is\_gt()和 is\_gteq()，如果排序代表==，!=，<，<=，>或>=，则分别返回true，否则返回false。下面是一个例子：

\begin{cpp}
int i { 11 };
strong_ordering result { i <=> 0 };
if (is_lt(result)) { println("less"); }
if (is_gt(result)) { println("greater"); }
if (is_eq(result)) { println("equal"); }
\end{cpp}

\mySubsubsection{1.1.12.}{函数}

对于任何具有一定规模的程序来说，将所有代码放在main()函数内部是不可行的。为了使程序更容易理解，需要将代码分解成简洁的函数。

C++中，需要声明一个函数，以便其他代码可以使用它。若函数只在特定的文件内部使用，通常需要在那个源文件中声明和定义函数。若函数要在其他模块或文件使用，需要从模块接口文件中导出函数的声明，而函数的定义可以位于相同的模块接口文件中，或者在一个模块实现文件中（后面会讨论）。

\begin{myNotic}{NOTE}
函数声明称为函数原型或函数头，表示函数如何访问。函数签名的术语用于指代函数名及其参数列表的组合，但不包括返回类型。
\end{myNotic}

函数声明在下面的代码中显示。这个例子有一个返回类型为void，表示该函数不向调用者提供结果。调用者必须为函数提供两个参数以供其使用——一个整数和一个字符。

\begin{cpp}
void myFunction(int i, char c);
\end{cpp}

若没有与这个函数声明相匹配的实际定义，因为使用该函数的代码将会调用不存在的代码，编译过程的链接阶段将会失败。以下的定义打印出两个参数的值：

\begin{cpp}
void myFunction(int i, char c)
{
    println("The value of i is {}.", i);
    println("The value of c is {}.", c);
}
\end{cpp}

程序的其它地方，可以调用myFunction()并为两个参数传递实参。这里展示了一些函数调用的示例：

\begin{cpp}
int someInt { 6 };
char someChar { 'c' };
myFunction(8, 'a');
myFunction(someInt, 'b');
myFunction(5, someChar);
\end{cpp}

\begin{myNotic}{NOTE}
C++与C不同，一个不接受任何参数的函数只需要一个空的参数列表。没有必要使用void来指示没有参数被接受。但当没有值返回时，仍然需要使用void来表示。

\end{myNotic}

C++函数也可以向调用者返回一个值。以下函数将两个数字相加并返回结果：

\begin{cpp}
int addNumbers(int number1, int number2)
{
    return number1 + number2;
}
\end{cpp}

这个函数可以这样调用:

\begin{cpp}
int sum { addNumbers(5, 3) };
\end{cpp}

\mySamllsection{函数返回类型推导}

可以要求编译器自动找出函数的返回类型。要使用此功能，只需将auto指定为返回类型。

\begin{cpp}
auto addNumbers(int number1, int number2)
{
    return number1 + number2;
}
\end{cpp}

编译器根据函数体中用于返回语句的表达式来推断返回类型。因为编译器永远不会插入任何隐式转换来推断函数的返回类型，所以可以有多个返回语句，但都必须都解析为完全相同的类型。这样的函数甚至可以包括递归调用（调用自身），但函数中的第一个返回语句必须是非递归调用。

\mySamllsection{获取当前函数名}

每个函数都有一个局部预定义变量\_\_func\_\_包含当前函数的名称，这个变量很可能会用于日志记录。

\begin{cpp}
int addNumbers(int number1, int number2)
{
    println("Entering function {}", __func__);
    return number1 + number2;
}
\end{cpp}

\mySamllsection{函数重载}

重载函数意味着提供多个具有相同名称但具有不同参数集的函数。因为在调用函数时可以忽略返回值，所以只指定不同的返回类型完全不够;相反，参数的数量和/或类型必须不同。

若希望提供处理整数和双精度的addNumbers()版本。若没有重载，将需要为函数使用唯一名称，例如:

\begin{cpp}
int addNumbersInts(int a, int b) { return a + b; }
double addNumbersDoubles(double a, double b) { return a + b; }
\end{cpp}

有了函数重载，就不需要为函数的不同版本取不同的名字。下面的代码片段定义了两个名为addNumbers()的函数，一个为整型定义，另一个为双精度定义:

\begin{cpp}
int addNumbers(int a, int b) { return a + b; }
double addNumbers(double a, double b) { return a + b; }
\end{cpp}

当调用addNumbers()时，编译器会根据提供的参数自动选择正确的重载函数，这个过程称为重载解析。

\begin{cpp}
println("{}", addNumbers(1, 2)); // Calls the integer version
println("{}", addNumbers(1.11, 2.22)); // Calls the double version
\end{cpp}

\mySubsubsection{1.1.13.}{属性}

属性是一种向源代码中添加可选和/或特定于供应商的信息的机制。C++标准化属性之前，供应商决定如何指定这些信息。例如\_\_attribute\_\_、\_\_declspec等。从C++11开始，通过使用双方括号语法[[attribute]]，对属性有了标准化的支持。

之前的内容使用了[[fallthrough]]属性，是为了防止在switch case语句中故意出现fallthrough时编译器发出警告。C++标准定义了很多的标准属性。

\mySamllsection{[[nodiscard]]}

[[nodiscard]]属性可用于返回值的函数。若调用函数没有使用该函数的返回值，编译器将发出警告。下面是一个例子:

\begin{cpp}
[[nodiscard]] int func() { return 42; }

int main()
{
    func();
}
\end{cpp}

编译器发出类似如下的警告:

\begin{shell}
warning C4834: discarding return value of function with 'nodiscard' attribute
\end{shell}

例如，这个特性可以用于返回错误代码的函数。通过向这些函数添加[[nodiscard]]属性，就不能忽略返回的错误码。

[[nodiscard]]属性可用于类、结构、函数和枚举。将属性应用于整个类的一个示例是，当有一个表示错误条件的类时。通过将[[nodiscard]]应用于这样的类，编译器将对每个返回此类错误条件的函数调用发出警告，并且调用者没有对其进行任何操作。

可以以字符串的形式为[[nodiscard]]属性提供原因。若函数的调用者忽略返回值，则编译器会在生成的警告消息中显示此原因。下面是一个例子:

\begin{cpp}
[[nodiscard("Some explanation")]] int func();
\end{cpp}

\mySamllsection{[[maybe\_unused]]}

[[maybe\_unused]]属性可以用来抑制编译器在某些代码未使用时发出警告，如下例所示:

\begin{cpp}
int func(int param1, int param2)
{
    return 42;
}
\end{cpp}

若编译器警告级别设置得足够高，该函数定义将导致两个编译器警告。例如，Microsoft Visual C++给出了警告:

\begin{shell}
warning C4100: 'param2': unreferenced formal parameter
warning C4100: 'param1': unreferenced formal parameter
\end{shell}

通过使用[[maybe\_unused]]属性，可以抑制这样的警告:

\begin{cpp}
int func(int param1, [[maybe_unused]] int param2)
{
    return 42;
}
\end{cpp}

这种情况下，第二个参数标记为抑制其警告的属性。编译器现在只对param1发出警告:

\begin{shell}
warning C4100: 'param1': unreferenced formal parameter
\end{shell}

[[maybe\_unused]]属性可用于类、结构、非静态数据成员、联合、类型定义、类型别名、变量、函数、枚举和枚举值。其中一些术语你可能还不知道，但在本书后面会讨论到。

\mySamllsection{[[noreturn]]}

向函数添加[[noreturn]]属性意味着永远不会将控制权返回给调用者。通常，该函数要么导致某种终止(进程终止或线程终止)，要么抛出异常。本章后面将讨论异常。有了这个属性，编译器可以避免给出某些警告或错误。下面是一个例子:

\begin{cpp}
import std;
using namespace std;

[[noreturn]] void forceProgramTermination()
{
    exit(1); // Defined in <cstdlib>
}

bool isDongleAvailable()
{
    bool isAvailable { false };
    // Check whether a licensing dongle is available...
    return isAvailable;
}

bool isFeatureLicensed(int featureId)
{
    if (!isDongleAvailable()) {
        // No licensing dongle found, abort program execution!
        forceProgramTermination();
    } else {
        // Dongle available, perform license check of the given feature...
        bool isLicensed { featureId == 42 };
        return isLicensed;
    }
}

int main()
{
    bool isLicensed { isFeatureLicensed(42) };
    println("{}", isLicensed);
}
\end{cpp}

此代码段编译良好，没有任何警告或错误。然而，若删除[[noreturn]]属性，编译器会生成以下警告(Visual C++的输出):

\begin{shell}
warning C4715: 'isFeatureLicensed': not all control paths return a value
\end{shell}

\mySamllsection{[[deprecated]]}

[[deprecated]]可以用来标记已弃用的东西，虽然可以使用，但不鼓励使用。该属性接受一个可选参数，该参数可用于解释弃用的原因，如下所示:

\begin{cpp}
[[deprecated("Unsafe function, please use xyz")]] void func();
\end{cpp}

若使用这个已弃用的函数，将得到编译错误或警告。例如，GCC给出以下警告:

\begin{shell}
warning: 'void func()' is deprecated: Unsafe function, please use xyz
\end{shell}

\mySamllsection{[[likely]] 和 [[unlikely]]}

属性[[likely]]和[[unlikely]]可以用来帮助编译器优化代码。例如，可以使用这些属性来标记if语句的分支，并根据执行分支的可能性来切换语句，但很少需要这些属性。现在的编译器和硬件都有强大的分支预测功能，可以自行解决问题，但在某些情况下，比如性能关键的代码，编译器可能需要帮助。语法如下:

\begin{cpp}
int value { /* ... */ };
if (value > 11) [[unlikely]] { /* Do something ... */ }
else { /* Do something else ... */ }

switch (value)
{
    [[likely]] case 1:
        // Do something ...
        break;
    case 2:
        // Do something ...
        break;
    [[unlikely]] case 12:
        // Do something ...
        break;
}
\end{cpp}

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{[[assume]]}

[[assume]]属性允许编译器假设某些表达式为真，而不需要在运行时对它们求值。编译器可以使用这样的假设来更好地优化代码。作为一个例子，来看看下面的函数:

\begin{cpp}
int divideBy32(int x)
{
    return x / 32;
}
\end{cpp}

该函数接受一个有符号整数，因此编译器必须生成代码以确保除法对正数和负数都有效。若确定x永远不会是负数，并且由于某些原因不能使x的类型为unsigned，可以添加如下假设:

\begin{cpp}
int divideBy32(int x)
{
    [[assume(x >= 0)]];
    return x / 32;
}
\end{cpp}

有了这个假设，编译器就可以省略处理负数的代码，并将除法优化为一条指令，即简单的向右移5位。

\mySubsubsection{1.1.14.}{C风格的数组}

\begin{myWarning}{WARNING}
本节简要解释C风格数组，开发者们可能会在历史代码中看到它们。C++中，最好避免使用C风格的数组，而是使用标准库功能，例如std::array和vector，这些将在下面的两节中讨论。
\end{myWarning}

数组持有一系列值，所有值类型相同，每个值都可以通过其在数组中的位置来访问。C++声明数组时，必须提供数组的大小。不能使用变量作为大小——必须是常量，或者是一个常量表达式（constexpr）。下面的代码展示了声明一个包含三个整数的数组，接着是三行代码用于将元素初始化为0：

\begin{cpp}
int myArray[3];
myArray[0] = 0;
myArray[1] = 0;
myArray[2] = 0;
\end{cpp}

\begin{myWarning}{WARNING}
C++数组的第一个元素始终位于位置0，而不是位置1！数组的最后一个位置始终是数组大小减1！
\end{myWarning}

本章后面“循环”部分讨论了如何使用循环来初始化数组的每个元素。然而，除了使用循环或之前的初始化机制，还可以使用以下单行代码来完成零初始化：

\begin{cpp}
int myArray[3] = { 0 };
\end{cpp}

甚至可以省略0。

\begin{cpp}
int myArray[3] = {};
\end{cpp}

等号也以没有，所以可以这样写:

\begin{cpp}
int myArray[3] {};
\end{cpp}

可以使用初始化列表初始化数组，编译器会自动计算数组的大小。这里有一个例子:

\begin{cpp}
int myArray[] { 1, 2, 3, 4 }; // The compiler creates an array of 4 elements
\end{cpp}

若指定了数组的大小，并且初始化列表中的元素少于给定的大小，则剩余的元素将设置为0。例如，下面的代码只将数组中的第一个元素设置为值2，并将所有其他元素设置为0:

\begin{cpp}
int myArray[3] { 2 };
\end{cpp}

要获取基于堆栈的c风格数组的大小，可以使用std::size()函数，该函数在<array>中定义，返回std::size\_t，这是在<cstddef>中定义的无符号整数类型。下面是一个例子:

\begin{cpp}
std::size_t arraySize { std::size(myArray) };
\end{cpp}

\begin{myNotic}{NOTE}
旧代码中，可能会看到size\_t使用时没有std命名空间的限定，没有使用using namespace std，也没有使用using std::size\_t。当使用import std时，这种方式不再有效，因为import std会将std命名空间中的所有内容导入到此。因此，需要使用std::size\_t，或者使用适当的using指令或声明。另外，第11章解释了可以导入名为std.compat的模块，而非std，但这不推荐用于新代码。
\end{myNotic}

\CXXTwentythreeLogo{-40}{-50}

\begin{myNotic}{NOTE}
C++23为类型std::size\_t引入了一个字面值后缀uz，例如：42uz。
\end{myNotic}

获取基于堆栈的C风格数组大小的旧技巧是使用sizeof操作符，sizeof操作符返回其参数的大小(以字节为单位)。要获得基于堆栈的数组中的元素数，可以用数组的字节大小除以第一个元素的字节大小。这里有一个例子:

\begin{cpp}
std::size_t arraySize { sizeof(myArray) / sizeof(myArray[0]) };
\end{cpp}

前面的例子展示了一个整数的一维数组，可以将其视为一排整数，每个整数都有自己的编号隔间。C++允许多维数组，可以将二维数组想象为一个棋盘，每个位置都有x轴位置和y轴位置。三维数组可以想象为立方体，而更高维度的数组更难可视化。下面的代码展示了创建一个用于井字游戏的字符二维数组的语法，然后在中心方块放置一个“o”：

\begin{cpp}
char ticTacToeBoard[3][3];
ticTacToeBoard[1][1] = 'o';
\end{cpp}

图1.1显示了该板与每个正方形的位置的可视化表示。

\myGraphic{0.6}{content/part1/chapter1/images/1.png}{图 1.1}

\mySubsubsection{1.1.15.}{std::array}

上一节讨论的数组来自C，但在C++中仍然可以工作。C++为固定大小的容器提供了一个特殊类型std::array，定义在<array>中，是对C风格数组的一个薄包装。

使用std::arrays，而非C风格的数组有许多优点。容器总是知道自己的大小，不会自动转换为指针以避免某些类型的错误，并且有迭代器以便于遍历元素。迭代器在第17章“理解迭代器和范围库”中详细讨论。下面的例子演示了如何使用数组容器，数组类型是一个类模板，接受一些类模板参数，允许指定要在容器中存储多少元素。以及其类型。通过在array后面的尖括号内指定类模板参数，来为类模板参数提供类模板实参，例如 array<int,3>。

第12章“使用模板编写通用代码”详细讨论了模板。但现在只需记住，必须在尖括号之间指定两个参数；第一个代表数组中元素的类型，第二个代表数组的大小。

\begin{cpp}
array<int, 3> arr { 9, 8, 7 };
println("Array size = {}", arr.size());
println("2nd element = {}", arr[1]);
\end{cpp}

C++支持类模板参数推导（CTAD），这会第12章中详细讨论。现在只需要记住，这允许避免为某些类模板在尖括号之间指定模板参数。CTAD仅在使用初始化器时有效，因为编译器使用这个初始化器来自动推导模板参数。这对std::array有效，允许将前面的数组改成如下代码：

\begin{cpp}
array arr { 9, 8, 7 };
\end{cpp}

\begin{myNotic}{NOTE}
C风格的数组和std::array有固定的大小，必须在编译时知道，其长度不能在运行时改变。
\end{myNotic}

若想要一个动态大小的数组，建议使用std::vector，下一节将对此进行解释。当向vector中添加新元素时，其大小会自动增加。

\mySubsubsection{1.1.16.}{std::vector}

C++标准库提供了许多不同的非固定大小的容器，可用于存储信息。在<vector>中声明的std::vector就是这种容器。vector类用一种更加灵活和安全的机制，取代了C风格数组。

作为用户，不需要担心内存管理，因为vector会自动分配足够的内存来容纳其元素。vector是动态的，可以在运行时添加和删除元素。第18章“标准库容器”更详细地介绍了容器，vector的基本使用非常简单，这就是为什么它会在本书的开始部分介绍。下面的代码演示了vector的基本功能：


\begin{cpp}
// Create a vector of integers.
vector<int> myVector { 11, 22 };

// Add some more integers to the vector using push_back().
myVector.push_back(33);
myVector.push_back(44);

// Access elements.
println("1st element: {}", myVector[0]);
\end{cpp}

myVector声明为vector<int>。需要使用尖括号来指定模板参数，就像使用std::array时一样。vector是一个通用容器，可以包含几乎任何类型的对象，但vector中的所有元素必须是同一类型，这个类型在尖括号之间指定。模板在第12章和第26章“高级模板”中详细讨论。

就像std::array一样，vector类模板也支持CTAD，可以这样定义myVector:

\begin{cpp}
vector myVector { 11, 22 };
\end{cpp}

同样，CTAD需要初始化列表才能工作。以下是非法的:

\begin{cpp}
vector myVector;
\end{cpp}

要向vector中添加元素，可以使用push\_back()成员函数。可以使用与数组类似的语法访问单个元素，即操作符[]。

\mySubsubsection{1.1.17.}{std::pair}

std::pair类模板定义在<utility>头文件中，其将两个可能不同类型的值组合在一起。这些值可以通过 first 和 second 公共数据成员访问。下面是一个例子：

\begin{cpp}
pair<double, int> myPair { 1.23, 5 };
println("{} {}", myPair.first, myPair.second);
\end{cpp}

pair也支持CTAD，所以可以这样定义myPair:

\begin{cpp}
pair myPair { 1.23, 5 };
\end{cpp}

\begin{myNotic}{NOTE}
虽然可以编写一个返回std::pair的函数，但是建议编写一个包含两个值的小型结构体或类，并从函数中返回该结构体或类的实例。返回pair的缺点是调用端代码必须使用first和second来访问这两个值，通过返回一个合适的结构体或类，可以给这两个值赋予更有意义的名称。
\end{myNotic}

\mySubsubsection{1.1.18.}{std::optional}

std::optional定义在<optional>中，保存一个特定类型的值，或者不保存任何值。它已经在第1章中介绍过了，这是一种非常有用的类型。

基本上，若想要允许参数是可选的，可以使用optional作为函数的参数。它也经常作为函数的返回类型，若函数可能返回某个值，也可能不返回任何值。这消除了从函数返回“特殊”值（如nullptr、-1、EOF等）的需要，还消除了将函数编写为返回一个布尔值（表示成功或失败），同时将函数的实际结果存储在作为输出参数（一个类型为非常量引用的参数，稍后在章节中讨论）传递给函数的需求。

optional类型是一个类模板，因此需要在尖括号之间指定需要的实际类型，例如 optional<int>。这种语法类似于vector中指定存储的类型，例如 vector<int>。

下面是一个返回optional对象的函数示例:

\begin{cpp}
optional<int> getData(bool giveIt)
{
    if (giveIt) {
        return 42;
    }
    return nullopt; // or simply return {};
}
\end{cpp}

可以这样调用这个函数:

\begin{cpp}
optional<int> data1 { getData(true) };
optional<int> data2 { getData(false) };
\end{cpp}

要确定optional对象是否有值，可以使用has\_value()成员函数，或者直接在if语句中使用可选对象:

\begin{cpp}
println("data1.has_value = {}", data1.has_value());
if (!data2) {
    println("data2 has no value.");
}
\end{cpp}

若optional对象有一个值，可以使用value()或解引用操作符*来检索：

\begin{cpp}
println("data1.value = {}", data1.value());
println("data1.value = {}", *data1);
\end{cpp}

若对一个空的optional对象使用value()，将会抛出一个std::bad\_optional\_access异常。

value\_or()可以用来返回optional的值，或者当optional为空时返回另一个值：

\begin{cpp}
println("data2.value = {}", data2.value_or(0));
\end{cpp}

不能在optional中存储引用（将在本章后面讨论），因此optional<T\&>将不起作用但可以在optional中存储指针。

\mySubsubsection{1.1.19.}{结构化绑定}

结构化绑定允许您声明多个变量，这些变量可以从数组、结构体或对组等数据结构中初始化。

假设有如下的std::array:

\begin{cpp}
array values { 11, 22, 33 };
\end{cpp}

可以使用结构化绑定声明三个变量x、y和z，并使用数组中的三个值来初始化它们。对于结构化绑定，必须使用auto关键字，不能使用int代替auto。

\begin{cpp}
auto [x, y, z] { values };
\end{cpp}

使用结构化绑定声明的变量数量必须与右侧表达式中的值数量相匹配。

若结构体中的所有非静态成员都是public，结构化绑定也可以用于结构体。这里有一个例子：

\begin{cpp}
struct Point { double m_x, m_y, m_z; };
Point point;
point.m_x = 1.0; point.m_y = 2.0; point.m_z = 3.0;
auto [x, y, z] { point };
\end{cpp}

作为最后一个例子，下面的代码片段将一对中的元素分解为单独的变量:

\begin{cpp}
pair myPair { "hello", 5 };
auto [theString, theInt] { myPair }; // Decompose using structured bindings.
println("theString: {}", theString);
println("theInt: {}", theInt);
\end{cpp}

还可以使用结构化绑定语法创建一组非常量引用或常量引用，通过使用auto\&或 const auto\&代替auto。非常量引用和常量引用都将在本章后面讨论。

\mySubsubsection{1.1.20.}{循环}

计算机非常适合一遍又一遍地做相同的事情。C++提供了四种循环机制：while循环、do/while循环、for循环和基于范围的for循环。

\mySamllsection{while循环}

while循环允许重复执行一个代码块，只要表达式的计算结果为true。例如，下面这段代码输出“This is silly”五次:

\begin{cpp}
int i { 0 };
while (i < 5) {
    println("This is silly.");
    ++i;
}
\end{cpp}

关键字break可以在循环内部使用，用于立即退出循环并从紧随循环之后的代码行开始继续执行程序。关键字continue可以用于返回到循环顶部并重新计算while中的表达式。因为它会导致程序的执行跳来跳去，所以在循环中使用continue通常认为是不良的风格，所以应该尽量少用。

\mySamllsection{do/while循环}

while循环有一种变体，称为do/while循环。它的工作方式与while循环类似，不同之处在于要执行的代码放在前面，而是否继续的条件的检查发生在最后。通过这种方式，可以使用循环来实现，当希望某个代码块至少执行一次，并根据某些条件可能执行更多次的情况。下面的例子即使条件最终为假，也会打印一次语句：“This is silly.”：

\begin{cpp}
int i { 100 };
do {
    println("This is silly.");
    ++i;
} while (i < 5);
\end{cpp}

\mySamllsection{for循环}

for循环提供了另一种循环的语法。任何for循环都可以转换为while循环，反之亦然。然而，for循环的语法通常更方便，因为它从起始表达式、结束条件和每次迭代结束时执行的表达式的角度来看待循环。在下面的代码中，i初始化为0；只要i小于5，循环就会继续；并且每次迭代的结束时，i会递增1。这段代码实现了与前面while循环示例相同的功能，但由于起始值、结束条件和每次迭代的语句都在一行中可见，因此可读性更强。

\begin{cpp}
for (int i { 0 }; i < 5; ++i) {
    println("This is silly.");
}
\end{cpp}

\mySamllsection{基于范围的循环}

基于范围的for循环是第四种循环机制，可以轻松地遍历容器中的元素。这种类型的循环适用于C风格的数组、初始化列表（本章后面讨论），以及任何支持begin()和end()函数返回迭代器的类型（参见第17章），例如std::array、vector和第18章“标准库容器”中讨论的所有其他标准库容器。

下面的例子首先定义了一个包含四个整数的数组。基于范围的for循环然后遍历这个数组的每个元素的副本，并打印出每个值。要遍历元素本身而不制作副本，请使用引用变量，这将在本章后面讨论。

\begin{cpp}
array arr { 1, 2, 3, 4 };
for (int i : arr) { println("{}", i); }
\end{cpp}

\mySamllsection{基于范围的for循环——初始化式}

您可以在基于范围的for循环中使用初始化列表，类似于if和switch语句的初始化式。语法如下：

\begin{cpp}
for (<initializer>; <range-declaration> : <range-expression>) { <body> }
\end{cpp}

<initializer>中引入的任何变量仅在<range-declaration>、<range-expression>和<body>中可用，在基于范围的for循环外部不可用。下面是一个例子：

\begin{cpp}
for (array arr { 1, 2, 3, 4 }; int i : arr) { println("{}", i); }
\end{cpp}

\mySubsubsection{1.1.21.}{初始化列表}

初始化列表在<initializer\_list>中定义，使得编写可以接受可变数量参数的函数变得容易。std::initializer\_list类型是一个类模板，因此要求在尖括号之间指定列表中元素的类型，类似于在vector中指定存储的元素类型。下面的例子展示了如何使用初始化列表：

\begin{cpp}
import std;
using namespace std;

int sum(initializer_list<int> values)
{
    int total { 0 };
    for (int value : values) {
        total += value;
    }
    return total;
}
\end{cpp}

通过接受一个整数初始化列表作为参数，函数sum()可以使用一个整数的大括号初始化器作为参数来调用，函数体使用基于范围的for循环来累加总和。这个函数可以这样使用：

\begin{cpp}
int a { sum({ 1, 2, 3 }) };
int b { sum({ 10, 20, 30, 40, 50, 60 }) };
\end{cpp}

初始化列表是类型安全的，列表中的所有元素必须是相同类型的。对于这里的sum()函数，初始化列表中的所有元素必须是整数。尝试使用double调用它，如下所示，会导致编译错误或警告，报告中会指出将double转换为int需要窄化转换。

\begin{cpp}
int c { sum({ 1, 2, 3.0 }) };
\end{cpp}

\mySubsubsection{1.1.22.}{C++中的字符串}

C++中有两种处理字符串的方法:

\begin{itemize}
\item
C风格:将字符串表示为字符数组

\item
C++风格:用更容易使用和更安全的字符串类型包装C风格的数组
\end{itemize}

第 2 章提供了详细的讨论。现在，只需要知 C++的std::string类型定义在<string>中，并且可以像使用基本类型一样使用C++字符串。下面的例子显示了字符串可的使用方式：

\begin{cpp}
string myString { "Hello, World" };
println("The value of myString is {}", myString);
println("The second letter is {}", myString[1]);
\end{cpp}

\mySubsubsection{1.1.23.}{C++作为面向对象的语言}

若您是一个C程序员，可能会将本章到目前为止所介绍的特性视为对C语言的有益补充。正如C++这个名字所暗示的，从许多方面来说，这种语言只是“更好的C”。但这种观点忽略了一个主要问题：与C不同，C++是一种面向对象的语言。

面向对象编程（OOP）是一种不同、可以说是更自然的编写代码的方式。若习惯了C或Pascal等过程式语言，不必担心。第5章“使用类进行设计”涵盖了需要了解的背景知识，以帮助您理解面向对象的范式。若已经了解OOP的理论，本节的其余部分将帮助您快速掌握（或刷新记忆）基本的C++对象语法。

\mySamllsection{定义类}

C++中，类定义了对象的特点。类通常在模块接口文件（.cppm）中定义和导出，而实现可以直接在相同的模块接口文件中，或者在一个相应的模块实现文件（.cpp）中。第11章将深入讨论模块。

以下示例展示了一个基本的机票类的定义。这个类可以根据飞行里程和客户是否是精英超级奖励计划的成员，来计算机票价格。

定义首先声明了类名。在一对花括号内，声明了类的数据成员（属性）和成员函数（行为）。每个数据成员和成员函数都与一个特定的访问级别相关联：公有（public）、保护（protected）或私有（private）。这些标签可以以任何顺序出现，并且可以重复。公有成员可以从类外部访问，而私有成员不能从类外部任何地方访问。保护成员可以被派生类访问，第10章将详细解释继承上下文中的派生类。建议将所有数据成员设为私有，并在需要时，使用公有或保护的获取方法（getters）来从对象检索数据，以及使用公有或保护的设置方法（setters）来为对象设置数据。这样，可以轻松地更改数据的表示形式，同时保持公有/保护接口不变。

编写模块接口文件时，请记住使用export module声明来指定您正在编写哪个模块，并明确导出您希望向模块用户提供的数据类型。

\begin{cpp}
export module airline_ticket;

import std;

export class AirlineTicket
{
    public:
        AirlineTicket();
        ~AirlineTicket();
        double calculatePriceInDollars();
        std::string getPassengerName();
        void setPassengerName(std::string name);
        int getNumberOfMiles();
        void setNumberOfMiles(int miles);
        bool hasEliteSuperRewardsStatus();
        void setHasEliteSuperRewardsStatus(bool status);
    private:
        std::string m_passengerName;
        int m_numberOfMiles;
        bool m_hasEliteSuperRewardsStatus;
};
\end{cpp}

本书遵循一个约定，即给类的每个数据成员加上一个以小写字母m开头，后跟一个下划线的前缀，例如m\_passengerName。

具有与类相同名称且没有返回类型的成员函数是构造函数。当创建类的一个对象时，自动调用。以波浪号（~）字符开头，后跟类名称的成员函数是析构函数。当对象销毁时，其会自动调用。

.cppm模块接口文件定义了类，而本例中成员函数的实现位于.cpp模块实现文件中。这个源文件以以下模块声明开始，告诉编译器这是airline\_ticket模块的一个源文件：

\begin{cpp}
module airline_ticket;
\end{cpp}

C++有几种方法可以初始化类的数据成员。一种方法是使用构造函数初始化列表，跟在构造函数头部的冒号之后。以下是一个使用构造函数初始化列表的AirlineTicket构造函数示例：

\begin{cpp}
AirlineTicket::AirlineTicket()
    : m_passengerName { "Unknown Passenger" }
    , m_numberOfMiles { 0 }
    , m_hasEliteSuperRewardsStatus { false }
{}
\end{cpp}

第二个选择是将初始化放在构造函数的主体中，如下所示:

\begin{cpp}
AirlineTicket::AirlineTicket()
{
    // Initialize data members.
    m_passengerName = "Unknown Passenger";
    m_numberOfMiles = 0;
    m_hasEliteSuperRewardsStatus = false;
}
\end{cpp}

若只是初始化数据成员而不做其他事情，则并不真正需要构造函数，因为数据成员可以直接在类定义内初始化，这也称为类内初始化。例如，可以修改类定义中的数据成员以初始化它们，而不是编写一个AirlineTicket构造函数：

\begin{cpp}
private:
    std::string m_passengerName { "Unknown Passenger" };
    int m_numberOfMiles { 0 };
    bool m_hasEliteSuperRewardsStatus { false };
\end{cpp}

若类还需要执行其他类型的初始化，例如打开文件、分配内存等，则需要编写一个构造函数来处理这些初始化。

下面是AirlineTicket类的析构函数：

\begin{cpp}
AirlineTicket::~AirlineTicket()
{
    // Nothing to do in terms of cleanup
}
\end{cpp}

这个析构函数不做任何事情，可以从这个类中删除。这里只显示它，是为了让您了解析构函数的语法。若需要执行一些清理操作，例如关闭文件、释放内存等，则需要使用析构函数。在第8章“熟练掌握类和对象”和第9章中，会对析构函数进行了更加详细地讨论。

其他AirlineTicket类成员函数的定义如下:

\begin{cpp}
double AirlineTicket::calculatePriceInDollars()
{
    if (hasEliteSuperRewardsStatus()) {
        // Elite Super Rewards customers fly for free!
        return 0;
    }
    // The cost of the ticket is the number of miles times 0.1.
    // Real airlines probably have a more complicated formula!
    return getNumberOfMiles() * 0.1;
}

string AirlineTicket::getPassengerName() { return m_passengerName; }
void AirlineTicket::setPassengerName(string name) { m_passengerName = name; }

int AirlineTicket::getNumberOfMiles() { return m_numberOfMiles; }
void AirlineTicket::setNumberOfMiles(int miles) { m_numberOfMiles = miles; }

bool AirlineTicket::hasEliteSuperRewardsStatus()
{
    return m_hasEliteSuperRewardsStatus;
}

void AirlineTicket::setHasEliteSuperRewardsStatus(bool status)
{
    m_hasEliteSuperRewardsStatus = status;
}
\end{cpp}

也可以将成员函数实现直接放在模块接口文件中。语法如下:

\begin{cpp}
export class AirlineTicket
{
    public:
        double calculatePriceInDollars()
        {
            if (hasEliteSuperRewardsStatus()) { return 0; }
            return getNumberOfMiles() * 0.1;
        }

        std::string getPassengerName() { return m_passengerName; }
        void setPassengerName(std::string name) { m_passengerName = name; }

        int getNumberOfMiles() { return m_numberOfMiles; }
        void setNumberOfMiles(int miles) { m_numberOfMiles = miles; }

        bool hasEliteSuperRewardsStatus() { return m_hasEliteSuperRewardsStatus; }
        void setHasEliteSuperRewardsStatus(bool status)
        {
            m_hasEliteSuperRewardsStatus = status;
        }
    private:
        std::string m_passengerName { "Unknown Passenger" };
        int m_numberOfMiles { 0 };
        bool m_hasEliteSuperRewardsStatus { false };
};
\end{cpp}

\mySamllsection{使用类}

要使用AirlineTicket类，首先需要导入其模块:

\begin{cpp}
import airline_ticket;
\end{cpp}

下面的示例程序使用了这个类。下面的例子展示了如何创建一个基于堆栈的AirlineTicket对象:

\begin{cpp}
AirlineTicket myTicket;
myTicket.setPassengerName("Sherman T. Socketwrench");
myTicket.setNumberOfMiles(700);
double cost { myTicket.calculatePriceInDollars() };
println("This ticket will cost ${}", cost);
\end{cpp}

AirlineTicket示例展示了创建和使用类的通用语法。

\mySubsubsection{1.1.24.}{范围解析}

作为C++开发者，需要熟悉作用域的概念，其定义了项目的可见性。程序中的每个名称（包括变量、函数和类名）都在某个作用域内。可以使用命名空间、函数定义、由花括号分隔的块，以及类定义来创建作用域。在for循环和基于范围的for循环的初始化语句中，初始化的变量作用于该for循环，并且在该for循环之外不可见。同样，若在if或switch语句的初始化表达式中初始化了变量，则该变量作用于该if或switch语句，并且在该语句之外不可见。当尝试访问变量、函数或类时，首先在最近的外围作用域中查找该名称，然后是父作用域，以此类推，直到全局作用域。不在命名空间、函数、由花括号分隔的块或类中的名称，都会假定为在全局作用域中。若在全局作用域中没有找到，此时编译器会生成一个未定义符号错误。

有时作用域中的名称会隐藏其他作用域中的同名名称。有时，想要的作用域不是从程序中特定行的默认作用域解析的一部分。若不希望对名称使用默认的作用域解析，可以使用作用域解析运算符::来限定具有特定作用域的名称。以下示例演示了这一点。该示例定义了一个带有get()成员函数的Demo类，一个全局作用域的get()函数，以及一个位于NS命名空间中的get()函数。

\begin{cpp}
class Demo
{
    public:
    int get() { return 5; }
};

int get() { return 10; }

namespace NS
{
    int get() { return 20; }
}
\end{cpp}

全局作用域未命名，但可以单独使用作用域解析操作符(没有名称前缀)来访问，不同的get()函数可以按如下方式调用。这个例子中，代码本身在main()函数中，所以也在全局作用域中:

\begin{cpp}
int main()
{
    Demo d;
    println("{}", d.get()); // prints 5
    println("{}", NS::get()); // prints 20
    println("{}", ::get()); // prints 10
    println("{}", get()); // prints 10
}
\end{cpp}

若将前面的命名空间NS定义为未命名/匿名命名空间，即没有命名的命名空间，如下所示:

\begin{cpp}
namespace
{
    int get() { return 20; }
}
\end{cpp}

因为您将在全局作用域中定义一个get()，而在未命名的名称空间中定义另一个get()，所以下面这行代码将导致关于歧义名称解析的编译错误。

\begin{cpp}
println("{}", get());
\end{cpp}

若在main()函数之前添加以下using指令，也会出现同样的错误:

\begin{cpp}
using namespace NS;
\end{cpp}

\mySubsubsection{1.1.25.}{统一初始化}

在C++11之前，类型的初始化并不总是统一的。例如，以下对圆的定义，一个是结构体，一个是类：

\begin{cpp}
struct CircleStruct
{
    int x, y;
    double radius;
};

class CircleClass
{
    public:
        CircleClass(int x, int y, double radius)
            : m_x { x }, m_y { y }, m_radius { radius } {}
    private:
        int m_x, m_y;
        double m_radius;
};
\end{cpp}

C++11之前中，CircleStruct类型变量和CircleClass类型变量的初始化是不同的:

\begin{cpp}
CircleStruct myCircle1 = { 10, 10, 2.5 };
CircleClass myCircle2(10, 10, 2.5);
\end{cpp}

对于结构体，可以使用\{…\}语法。但对于类，需要使用函数表示法调用构造函数:(…)。

C++11起，可以更统一地使用\{…\}语法初始化类型，如下所示:

\begin{cpp}
CircleStruct myCircle3 = { 10, 10, 2.5 };
CircleClass myCircle4 = { 10, 10, 2.5 };
\end{cpp}

myCircle4的定义自动调用CircleClass的构造函数。甚至使用等号也是可选的，所以下面语句等价:

\begin{cpp}
CircleStruct myCircle5 { 10, 10, 2.5 };
CircleClass myCircle6 { 10, 10, 2.5 };
\end{cpp}

作为另一个例子，在本章前面的“结构体”一节中，Employee结构体初始化如下所示:

\begin{cpp}
Employee anEmployee;
anEmployee.firstInitial = 'J';
anEmployee.lastInitial = 'D';
anEmployee.employeeNumber = 42;
anEmployee.salary = 80'000;
\end{cpp}

统一初始化的情况下，可以重写为:

\begin{cpp}
Employee anEmployee { 'J', 'D', 42, 80'000 };
\end{cpp}

统一初始化并不局限于结构和类，可以用它来初始化C++中的任何东西。例如，下面的代码用值3初始化所有四个变量:

\begin{cpp}
int a = 3;
int b(3);
int c = { 3 }; // Uniform initialization
int d { 3 }; // Uniform initialization
\end{cpp}

统一初始化可用于对变量进行零初始化，只需指定一组空花括号，如下所示:

\begin{cpp}
int e { }; // Uniform initialization, e will be 0
\end{cpp}

这种语法也可以用于结构体。若按照以下方式创建一个Employee结构体的实例，则其数据成员将进行默认初始化，对于像char和int这样的基本类型来说，将包含内存中的随机数据：

\begin{cpp}
Employee anEmployee;
\end{cpp}

然而，若像下面这样创建实例，则所有的数据成员都是零初始化:

\begin{cpp}
Employee anEmployee { };
\end{cpp}

使用统一初始化的一个好处是它可以防止窄化。当使用旧式赋值语法初始化变量时，C++会进行隐式窄化，如下所示:

\begin{cpp}
int main()
{
    int x = 3.14;
}
\end{cpp}

C++在main()函数中使用以下语句时，C++会自动将3.14截断为3，然后将其赋值给x。一些编译器可能会发出关于这种窄化的警告。无论如何，不应该忽视窄化转换，这可能会导致错误。使用统一初始化时，若的编译器完全符合C++11标准，那么对x的赋值必须生成编译错误：

\begin{cpp}
int x { 3.14 }; // Error because narrowing
\end{cpp}

若需要一个窄化转换，建议使用Guidelines Support Library(GSL)中提供的gsl::narrow\_cast()函数。这个函数用于执行显式的窄化转换，并且会在运行时检查转换的有效性，若转换不合法，会抛出一个异常。

统一初始化也可以用在构造函数初始化列表中，用于初始化类的成员数组。例如：

\begin{cpp}
class MyClass
{
    public:
        MyClass()
            : m_array { 0, 1, 2, 3 }
        {
        }
    private:
        int m_array[4];
};
\end{cpp}

统一初始化也可以用于标准库容器，比如std::vector。

\begin{myNotic}{NOTE}
建议使用统一初始化来代替赋值语法来初始化变量。本书在可能的情况下，都使用了统一初始化。
\end{myNotic}

\mySamllsection{指定初始化}

指定初始化器使用数据成员的名称来初始化聚合体类型的数据成员，聚合体类型是指数组类型的对象，或者是满足以下条件的结构体或类的对象：只有公共数据成员，没有用户声明或继承的构造函数，没有虚函数（参见第10章），并且没有虚拟、私有或保护的基类（参见第10章）。指定初始化，后面跟着数据成员的名称，必须按照数据成员的声明顺序排列。不允许混合使用指定初始化器和非指定初始化。任何没有使用指定初始化的数据成员，都将使用它们的默认值进行初始化：

\begin{itemize}
\item
具有类内初始化项的数据成员将获得该值。

\item
没有类内初始化项的数据成员会使用零初始化。
\end{itemize}

来看一下修改过的Employee结构体。这一次，salary数据成员的默认值为75,000。

\begin{cpp}
struct Employee {
    char firstInitial;
    char lastInitial;
    int employeeNumber;
    int salary { 75'000 };
};
\end{cpp}

在前面，的Employee结构体是使用统一的初始化语法初始化的，如下所示:

\begin{cpp}
Employee anEmployee { 'J', 'D', 42, 80'000 }
\end{cpp}

使用指定初始化式，可以这样写:

\begin{cpp}
Employee anEmployee {
    .firstInitial = 'J',
    .lastInitial = 'D',
    .employeeNumber = 42,
    .salary = 80'000
};
\end{cpp}

使用指定初始化的好处是，与统一初始化相比，更容易理解在初始化什么。

使用指定初始化，可以跳过对某些成员的初始化，若对这些成员的默认值感到满意。例如，在创建一个员工时，可以跳过初始化employeeNumber。因为它没有类内初始化，所以employeeNumber将使用零初始化：

\begin{cpp}
Employee anEmployee {
    .firstInitial = 'J',
    .lastInitial = 'D',
    .salary = 80'000
};
\end{cpp}

使用统一的初始化语法，这是不可能的，必须将员工编号指定为0，如下所示:

\begin{cpp}
Employee anEmployee { 'J', 'D', 0, 80'000 };
\end{cpp}

若跳过如下初始化salary数据成员，则salary将获得其默认值，即其在类中的初始化值75,000:

\begin{cpp}
Employee anEmployee {
    .firstInitial = 'J',
    .lastInitial = 'D'
};
\end{cpp}

当成员添加到数据结构中时，使用指定初始化，的现有代码可以继续工作。新的数据成员将使用其默认值进行初始化。

\mySubsubsection{1.1.26.}{指针和动态内存}

动态内存允许您使用编译时不固定大小的数据构建程序，大多数重要的程序都以某种形式使用动态内存。

\mySamllsection{栈和堆}

C++应用程序中，内存可分为两部分——栈和堆。将栈可视化为一副扑克牌的一种方式。当前顶部的牌代表程序的当前作用域，通常是当前正在执行的函数。当前函数内部声明的所有变量都会占用栈帧顶部，即牌堆顶。若当前函数foo()调用另一个函数bar()，则会在牌堆上放置一张新牌，以便bar()有自己的栈帧来工作。从foo()传递到bar()的所有参数都会从foo()栈帧复制到bar()栈帧。图1.2展示了在执行函数foo()时，其中声明了两个整数值的栈可能的样子。

\myGraphic{0.3}{content/part1/chapter1/images/2.png}{图1.2}

栈帧的好处在于，为每个函数提供了一个独立的内存工作空间。若在foo()栈帧内声明了一个变量，调用bar()函数不会改变它，除非你明确告诉它这样做。此外，当foo()函数运行完毕后，栈帧消失，函数内部声明的所有变量不再占用内存。栈分配的变量不需要程序员进行释放（删除），这会自动发生。

堆是一个与当前函数或栈帧完全独立的内存区域。若想在函数完成后仍然让变量存在，可以将变量放在堆上。程序可以在任何时候向堆中添加新的位，或者修改已经存在的位。开发者必须确保删除在堆上分配的内存。这不会自动发生，除非使用智能指针，这在第7章“内存管理”中会详细讨论。

\begin{myWarning}{WARNING}
在历史遗留的代码中，可能会看到指针。现代代码中，只有在不涉及所有权的情况下才允许使用原始/裸指针。否则，应该使用第7章中的智能指针。
\end{myWarning}

\mySamllsection{使用指针}

可以通过显式地方式，为其在堆上分配内存。例如，要将一个整数放入堆区，需要分配内存，但首先需要声明指针:

\begin{cpp}
int* myIntegerPointer;
\end{cpp}

int类型后跟的*，表示声明的变量指向某个整数内存。将指针想象为指向动态分配内存的箭头。目前它还没有指向特定位置，因为还没有给它分配给任何东西；它是一个未初始化的变量。应该始终避免使用未初始化的变量，尤其是未初始化的指针，因为它们可能指向内存中的某个随机位置。这样的指针很可能会导致程序崩溃。这就是为什么你应该总是在声明指针的同时对其进行初始化！若不想立即分配内存，可以将它们初始化为空指针（nullptr——有关更多信息，请参见“空指针常量”部分）：

\begin{cpp}
int* myIntegerPointer { nullptr };
\end{cpp}

空指针是一个特殊的默认值，不是一个有效的指针，在布尔表达式中使用时转换为false。这里有一个例子:

\begin{cpp}
if (!myIntegerPointer) { /* myIntegerPointer is a null pointer. */ }
\end{cpp}

使用new操作符来分配内存:

\begin{cpp}
myIntegerPointer = new int;
\end{cpp}

这种情况下，指针只指向一个整数值的地址。要访问该值，需要对指针解引用。可以把解引用看作是跟随指针的箭头指向自由存储中的实际值。要设置新分配的自由存储整数的值，可以使用如下代码:

\begin{cpp}
*myIntegerPointer = 8;
\end{cpp}

注意，这并不等同于将myIntegerPointer设置为值8。这里不是更改指针，而是更改指针所指向的内存。若重新分配指针的值，将指向内存地址8，最终会导致您的程序崩溃。

使用完动态分配的内存后，需要使用delete运算符释放内存。为了防止在释放指针所指向的内存后继续使用指针，建议将其设置为nullptr（C++11引入，用于指针的空值，以区分NULL）：

\begin{cpp}
delete myIntegerPointer;
myIntegerPointer = nullptr;
\end{cpp}

\begin{myWarning}{WARNING}
指针在解引用之前必须是有效的。解引用空指针或未初始化的指针会导致未定义的行为。程序可能会崩溃，但它也可能继续运行，并开始给出奇怪的结果。
\end{myWarning}

指针并不总是指向空闲存储空间。可以声明一个指向堆栈上变量的指针，甚至可以声明另一个指针。要获取指向变量的指针，可以使用\& ("address of")操作符:

\begin{cpp}
int i { 8 };
int* myIntegerPointer { &i }; // Points to the variable with the value 8
\end{cpp}

C++有一种特殊的语法来处理指向结构体或类的指针。技术上，若有一个指向结构体或类的指针，可以首先使用*解引用它，然后使用正常的.语法来访问其字段，如下面的代码片段所示。该代码片段还演示了如何动态分配和释放一个Employee实例。

\begin{cpp}
Employee* anEmployee { new Employee { 'J', 'D', 42, 80'000 } };
println("{}", (*anEmployee).salary);
delete anEmployee; anEmployee = nullptr;
\end{cpp}

这个语法有点乱。->(箭头)操作符允许您在一个步骤中同时执行解引用和字段访问。下面的语句等价于之前的println()，但更容易阅读:

\begin{cpp}
println("{}", anEmployee->salary);
\end{cpp}

还记得本章前面讨论过的短路逻辑的概念吗?这可以与指针结合使用，以避免使用无效指针，如下例所示:

\begin{cpp}
bool isValidSalary { anEmployee && anEmployee->salary > 0 };
\end{cpp}

或者:

\begin{cpp}
bool isValidSalary { anEmployee != nullptr && anEmployee->salary > 0 };
\end{cpp}

解引用anEmployee以获取薪水值，前提是它是一个有效的指针。若它是一个空指针，逻辑操作会短路，不会解引用anEmployee指针。

\mySamllsection{动态分配数组}

堆也可用于动态分配数组，可以使用new[]操作符为数组分配内存。

\begin{cpp}
int arraySize { 8 };
int* myVariableSizedArray { new int[arraySize] };
\end{cpp}

这将分配足够的内存来保存arraySize整数。图1.3显示了执行这段代码后堆栈和堆存储的样子。指针变量仍然驻留在堆栈中，但是动态创建的数组驻留在堆存储区中。

\myGraphic{1.0}{content/part1/chapter1/images/3.png}{图1.3}

现在内存已经分配，可以使用myVariableSizedArray，就好像是基于堆栈的数组:

\begin{cpp}
myVariableSizedArray[3] = 2;
\end{cpp}

使用完数组后，应该将数组从堆存储区中删除，以便其他变量可以使用该内存。C++可以使用delete[]来完成这个工作:

\begin{cpp}
delete[] myVariableSizedArray;
myVariableSizedArray = nullptr;
\end{cpp}

delete后面的括号表示正在删除一个数组!

\begin{myNotic}{NOTE}
若确实需要动态分配的内存，请避免使用C语言中的malloc()和free()。请使用C++中的new和delete，或者new[]和delete[]。在现代C++中，我们的目标是完全避免使用new、delete、new[]和delete[]，而使用更现代的结构，如标准库容器（例如std::vector）和智能指针，这些内容将在第7章中讨论。
\end{myNotic}

\begin{myWarning}{WARNING}
为了防止内存泄漏，每个对new的调用都应该与delete的调用配对，每个对new[]的调用都应该与delete[]的调用配对。不调用delete或delete[]，或者调用不匹配，会导致内存泄漏，这些问题将在第7章中讨论。
\end{myWarning}

\mySamllsection{空指针常量}

C++11之前，在<cstddef>中定义的常量NULL用于空指针。不能使用import声明来访问这个常量，必须使用\#include <cstddef>。NULL简单地定义为常数0，这可能会导致问题。举个例子:

\begin{cpp}
#include <cstddef>

void func(int i) { /* ... */ }

int main()
{
    func(NULL);
}
\end{cpp}

代码定义了一个带有单个整数参数的函数func()。main()函数使用参数NULL调用func()，这个参数应该是一个空指针常量。然而，由于NULL实际上并不是一个真正的指针，而是与整数0相同，因此触发了对func(int)的调用。因此，一些编译器甚至会对此发出警告。

通过使用真正的空指针常量nullptr，可以避免这个问题。下面的代码使用了真正的空指针常量，并且由于没有接受指针的func()重载，所以以下代码会导致编译错误：

\begin{cpp}
func(nullptr);
\end{cpp}

\mySubsubsection{1.1.27.}{const的用法}

C++关键字const有几种不同的使用方式，其用途是相关的，但存在一些细微的差异。const的微妙之处会使其成为面试中的绝佳问题！const关键字是“constant”（常量）的缩写，指定某些内容保持不变。

编译器通过将尝试更改它的行为，标记为错误来强制执行这一要求。此外，当启用优化时，编译器可以利用这一提示来生成更好的代码。

\mySamllsection{const作为类型的限定符}

若认为关键字const与常量有关，那么您已经正确地发现了它的一个用途。在C语言中，开发者经常使用预处理\#define机制（参见第11章）来声明在程序执行期间不会改变的值的符号名，例如版本号。C++不鼓励使用\#define，而使用const来定义常量。使用const定义常量就像定义变量一样，不同之处在于编译器保证了代码无法更改该值。这里有一些例子：

\begin{cpp}
const int versionNumberMajor { 2 };
const int versionNumberMinor { 1 };
const std::string productName { "Super Hyper Net Modulator" };
const double PI { 3.141592653589793238462 };
\end{cpp}

可以将变量标记为const，包括全局变量和类数据成员。

\mySamllsection{const成员函数}

当变量通过指针包含一个或多个间接层时，使用const变得更加棘手。看看下面的代码行:

\begin{cpp}
int* ip;
ip = new int[10];
ip[4] = 5;
\end{cpp}

假设将const应用于ip，考虑一下这意味着什么。是想防止修改ip变量，还是想避免修改它指向的值？也就是说，是想避免第二条语句执行，还是第三条语句执行？

为了避免修改指向的值（如第三条语句所示），可以在声明ip时添加关键字const，如下所示：

\begin{cpp}
const int* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!
\end{cpp}

现在就不能更改ip所指向的值。另一种语义上等价的写法如下:

\begin{cpp}
int const* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!
\end{cpp}

将const放在int型的前面或后面对其功能没有影响。

若想将ip本身标记为const(而不是它所指向的值)，需要这样写:

\begin{cpp}
int* const ip { nullptr };
ip = new int[10]; // DOES NOT COMPILE!
ip[4] = 5; // Error: dereferencing a null pointer
\end{cpp}

既然ip本身不能更改，编译器要求在声明它时初始化，可以像前面的代码一样使用nullptr，也可以像下面这样使用新分配的内存:

\begin{cpp}
int* const ip { new int[10] };
ip[4] = 5;
\end{cpp}

也可以像这样把指针和所指向的值都标记为const:

\begin{cpp}
int const* const ip { nullptr };
\end{cpp}

下面是另一种等价的语法:

\begin{cpp}
const int* const ip { nullptr };
\end{cpp}

虽然这种语法看起来令人困惑，但实际上有一个简单的规则:const关键字适用于直接在其左边的内容。再看看这句:

\begin{cpp}
int const* const ip { nullptr };
\end{cpp}

从左到右，第一个const紧跟在int这个词的右边，适用于ip指向的int，它指定了不能更改ip指向的值。第二个const紧跟在*的右边，适用于指向int的指针，即ip变量，它指定不能更改ip（指针）本身。

这条规则变得令人困惑的原因是，第一个const可以放在变量前面，像这样：

\begin{cpp}
const int* const ip { nullptr };
\end{cpp}

这种“异常”语法比其他语法更常用。

可以将此规则进行扩展到，如下例所示:

\begin{cpp}
const int * const * const * const ip { nullptr };
\end{cpp}

\begin{myNotic}{NOTE}
这里有一个容易记住的规则，可以帮助你理解复杂的变量声明：从右向左阅读。例如，int* const ip 从右向左读作“ip是一个指向int的常量指针。”进一步，int const* ip 读作“ip是一个指向常量int的指针”，而const int* ip 读作“ip是一个指向int常量的指针。”
\end{myNotic}

\mySamllsection{使用const保护参数}

In C++, you can cast a non-const variable to a const variable. Why would you want to do this? It offers some degree of protection from other code changing the variable. If you are calling a function that a co-worker of yours is writing and you want to ensure that the function doesn’t change the value of an argument you pass in, you can tell your co-worker to have the function take a const parameter. If the function attempts to change the value of the parameter, it will not compile.

In the following code, a string* is automatically cast to a const string* in the call to mysteryFunction(). If the author of mysteryFunction() attempts to change the value of the passed string, the code will not compile. There are ways around this restriction, but using them requires conscious effort. C++ only protects against accidentally changing const variables.

\begin{cpp}
void mysteryFunction(const string* someString)
{
    *someString = "Test"; // Will not compile
}

int main()
{
    string myString { "The string" };
    mysteryFunction(&myString); // &myString is a string*
}
\end{cpp}

You can also use const on primitive-type parameters to prevent accidentally changing them in the body of the function. For example, the following function has a const integer parameter. In the body of the function, you cannot modify the param integer. If you do try to modify it, the compiler will generate an error.

\begin{cpp}
void func(const int param) { /* Not allowed to change param... */ }
\end{cpp}

\mySamllsection{const成员函数}

A second use of the const keyword is to mark class member functions as const, preventing them from modifying data members of the class. The AirlineTicket class introduced earlier can be modified to mark all read-only member functions as const. The const must be added to both the member function declaration and its definition. If any const member function tries to modify one of the AirlineTicket data members, the compiler will emit an error.

\begin{cpp}
export class AirlineTicket
{
    public:
        double calculatePriceInDollars() const;

        std::string getPassengerName() const;
        void setPassengerName(std::string name);

        int getNumberOfMiles() const;
        void setNumberOfMiles(int miles);

        bool hasEliteSuperRewardsStatus() const;
        void setHasEliteSuperRewardsStatus(bool status);
    private:
        std::string m_passengerName { "Unknown Passenger" };
        int m_numberOfMiles { 0 };
        bool m_hasEliteSuperRewardsStatus { false };
};

std::string AirlineTicket::getPassengerName() const
{
    return m_passengerName;
}
// Other member functions omitted...
\end{cpp}

\begin{myNotic}{NOTE}
To follow the const-correctness principle, it’s recommended to declare member functions that do not change any data members of the object as being const. These member functions are also called inspectors, compared to mutators for non-const member functions.
\end{myNotic}

\mySubsubsection{1.1.28.}{引用}

Professional C++ code, including much of the code in this book, uses references extensively. A reference in C++ is an alias for another variable. All modifications to the reference change the value of the variable to which it refers. You can think of references as implicit pointers that save you the trouble of taking the address of variables and dereferencing the pointer. Alternatively, you can think of references as just another name for the original variable. You can create stand-alone reference variables, use reference data members in classes, accept references as parameters to functions, and return references from functions.

\mySamllsection{引用变量}

Reference variables must be initialized as soon as they are created, like this:

\begin{cpp}
int x { 3 };
int& xRef { x };
\end{cpp}

Attaching \& to a type indicates that the variable is a reference. It is still used as though it was a normal variable, but behind the scenes, it is really a pointer to the original variable. Both the variable x and the reference variable xRef point to exactly the same value; i.e., xRef is just another name for x. If you change the value through either one of them, the change is visible through the other one as well. For example, the following code sets x to 10 through xRef:

\begin{cpp}
xRef = 10;
\end{cpp}

You cannot declare a reference variable outside of a class definition without initializing it.

\begin{cpp}
int& emptyRef; // DOES NOT COMPILE!
\end{cpp}

\begin{myWarning}{WARNING}
A reference variable must always be initialized when it’s created.
\end{myWarning}

\mySamllsection{Modifying References}

A reference always refers to the same variable to which it is initialized; references cannot be changed once they are created. The syntax might be confusing for beginning C++ programmers. If you assign a variable to a reference when the reference is declared, the reference refers to that variable. However, if you assign a variable to a reference after that, the variable to which the reference refers is changed to the value of the variable being assigned. The reference is not updated to refer to that variable. Here is a code example:

\begin{cpp}
int x { 3 }, y { 4 };
int& xRef { x };
xRef = y; // Changes value of x to 4. Doesn't make xRef refer to y.
\end{cpp}

You might try to circumvent this restriction by taking the address of y when you assign it:

\begin{cpp}
xRef = &y; // DOES NOT COMPILE!
\end{cpp}

This code does not compile. The address of y is a pointer, but xRef is declared as a reference to an int, not a reference to a pointer.

Some programmers go even further in their attempts to circumvent the intended semantics of references. What if you assign a reference to a reference? Won’t that make the first reference refer to the variable to which the second reference refers? You might be tempted to try this code:

\begin{cpp}
int x { 3 }, z { 5 };
int& xRef { x };
int& zRef { z };
zRef = xRef; // Assigns values, not references
\end{cpp}

The final statement does not change to what zRef refers to. Instead, it sets the value of z to 3, because xRef refers to x, which is 3.

\begin{myWarning}{WARNING}
Once a reference is initialized to refer to a specific variable, you cannot change the reference to refer to another variable; you can change only the value of the variable the reference refers to.
\end{myWarning}

\mySamllsection{References-to-const}
References-to-const
const applied to references is usually easier than const applied to pointers for two reasons. First, references are const by default, in that you can’t change to what they refer. So, there is no need to mark them const explicitly. Second, you can’t create a reference to a reference, so there is usually only one level of indirection with references. The only way to get multiple levels of indirection is to create a reference to a pointer.

Thus, when C++ programmers refer to a reference-to-const, they mean something like this:

\begin{cpp}
int z;
const int& zRef { z };
zRef = 4; // DOES NOT COMPILE
\end{cpp}

By applying const to the int\&, you prevent assignment to zRef, as shown. Similar to pointers, const int\& zRef is equivalent to int const\& zRef. Note, however, that marking zRef const has no effect on z. You can still modify the value of z by changing it directly instead of through the reference.

You cannot create a reference to an unnamed value, such as an integer literal, unless the reference is to a const value. In the following example, unnamedRef1 does not compile because it is a referenceto-non-const referring to a constant. That would mean you could change the value of the constant, 5, which doesn’t make sense. unnamedRef2 works because it’s a reference-to-const, so you cannot for example write unnamedRef2 = 7.

\begin{cpp}
int& unnamedRef1 { 5 }; // DOES NOT COMPILE
const int& unnamedRef2 { 5 }; // Works as expected
\end{cpp}

The same holds for temporary objects. You cannot create a reference-to-non-const to a temporary object, but a reference-to-const is fine. For example, suppose you have the following function returning an std::string object:

\begin{cpp}
string getString() { return "Hello world!"; }
\end{cpp}

You can create a reference-to-const to the result of calling getString(), and that reference keeps the temporary std::string object alive until the reference goes out of scope:

\begin{cpp}
string& string1 { getString() }; // DOES NOT COMPILE
const string& string2 { getString() }; // Works as expected
\end{cpp}

\mySamllsection{References to Pointers and Pointers to References}

You can create references to any type, including pointer types. Here is an example of a reference to a pointer to int:

\begin{cpp}
int* intP { nullptr };
int*& ptrRef { intP };
ptrRef = new int;
*ptrRef = 5;
delete ptrRef; ptrRef = nullptr;
\end{cpp}

The syntax is a little strange: you might not be accustomed to seeing * and \& right next to each other. However, the semantics are straightforward: ptrRef is a reference to intP, which is a pointer to int. Modifying ptrRef changes intP. References to pointers are rare but can occasionally be useful, as discussed in the “Reference Parameters” section later in this chapter.

Taking the address of a reference gives the same result as taking the address of the variable to which the reference refers. Here is an example:

\begin{cpp}
int x { 3 };
int& xRef { x };
int* xPtr { &xRef }; // Address of a reference is pointer to value.
*xPtr = 100;
\end{cpp}

This code sets xPtr to point to x by taking the address of a reference to x. Assigning 100 to *xPtr changes the value of x to 100. Writing the comparison xPtr == xRef will not compile because of a type mismatch; xPtr is a pointer to an int, while xRef is a reference to an int. The comparisons xPtr == \&xRef and xPtr == \&x both compile without errors and are both true.

Finally, note that you cannot declare a reference to a reference or a pointer to a reference. For example, neither int\&\& nor int\&* is allowed.

\mySamllsection{Structured Bindings and References}

Structured bindings are introduced earlier in this chapter. One of the examples given was the following:

\begin{cpp}
pair myPair { "hello", 5 };
auto [theString, theInt] { myPair }; // Decompose using structured bindings
\end{cpp}

Now that you know about references and const variables, it’s time to learn that both can be combined with structured bindings as well. Here’s an example:

\begin{cpp}
auto& [theString, theInt] { myPair }; // Decompose into references-to-non-const
const auto& [theString, theInt] { myPair }; // Decompose into references-to-const
\end{cpp}

\mySamllsection{Reference Data Members}

Data members of classes can be references. As discussed earlier, a reference cannot exist without referring to some other variable, and it is not possible to change where a reference refers to. Thus, reference data members cannot be initialized inside the body of a class constructor, but they must be initialized in the constructor initializer. Syntax-wise, a constructor initializer immediately follows the constructor header and starts with a colon. The following is a quick example with the constructor initializer highlighted. Chapter 9 goes in much more detail.

\begin{cpp}
class MyClass
{
    public:
        MyClass(int& ref) : m_ref { ref } { /* Body of constructor */ }
    private:
        int& m_ref;
};
\end{cpp}

\begin{myWarning}{WARNING}
A reference must always be initialized when it’s created. Usually, references are created when they are declared, but reference data members need to be initialized in a constructor initializer for the containing class.
\end{myWarning}

\mySamllsection{Reference Parameters}

C++ programmers do not often use stand-alone reference variables or reference data members. The most common use of references is for parameters to functions. The default parameter-passing semantics is pass-by-value: functions receive copies of their arguments. When those parameters are modified, the original arguments remain unchanged. Pointers to stack variables are often used in C to allow functions to modify variables in other stack frames. By dereferencing the pointer, the function can change the memory that represents the variable even though that variable isn’t in the current stack frame. The problem with this approach is that it brings the messiness of pointer syntax into what is really a simple task.

Instead of passing pointers to functions, C++ offers a better mechanism, called pass-by-reference, where parameters are references instead of pointers. The following are two implementations of an addOne() function. The first one has no effect on the variable that is passed in because it is passed by value, and thus the function receives a copy of the value passed to it. The second one uses a reference and thus changes the original variable.

\begin{cpp}
void addOne(int i)
{
    i++; // Has no real effect because this is a copy of the original
}

void addOne(int& i)
{
    i++; // Actually changes the original variable
}
\end{cpp}

The syntax for the call to the addOne() function with an integer reference is no different than if the function just took an integer.

\begin{cpp}
int myInt { 7 };
addOne(myInt);
\end{cpp}

\begin{myNotic}{NOTE}
There is a subtle difference between the two addOne() implementations. The version using pass-by-value accepts literals without a problem; for example, addOne(3); is legal. However, doing the same with the pass-by-reference version of addOne() will result in a compilation error. This can be solved by using reference-to-const parameters, discussed in the next section.
\end{myNotic}

Here is another example where pass-by-reference comes in handy; it’s a simple swap function to swap the values of two ints:

\begin{cpp}
void swap(int& first, int& second)
{
    int temp { first };
    first = second;
    second = temp;
}
\end{cpp}

You can call it like this:

\begin{cpp}
int x { 5 }, y { 6 };
swap(x, y);
\end{cpp}

When swap() is called with the arguments x and y, the first parameter is initialized to refer to x, and the second parameter is initialized to refer to y. When swap() modifies first and second, x and y are actually changed.

A common quandary arises when you have a pointer to something that you need to pass to a function that takes a reference. You can “convert” a pointer to a reference in this case by dereferencing the pointer. This action gives you the value to which the pointer points, which the compiler then uses to initialize the reference parameter. For example, you can call swap() like this:

\begin{cpp}
int x { 5 }, y { 6 };
int *xp { &x }, *yp { &y };
swap(*xp, *yp);
\end{cpp}

Finally, if you have a function that needs to return an object of a class that is expensive to copy, you’ll often see the function accepting an output parameter of type reference-to-non-const to such a class that the function then modifies, instead of directly returning such an object. Developers thought that this was the recommended way to prevent any performance penalties with creating copies when returning objects from functions. However, even back then, compilers were usually smart enough to avoid any redundant copies. So, we have the following rule:

\begin{myWarning}{WARNING}
The recommended way to return objects from a function is to return them by value, instead of using output parameters.
\end{myWarning}

\mySamllsection{Pass-by-Reference-to-const}

The main value in reference-to-const parameters is efficiency. When you pass a value into a function, an entire copy is made. When you pass a reference, you are really just passing a pointer to the original so the computer doesn’t need to make a copy. By passing a reference-to-const, you get the best of both worlds: no copy is made, and the original variable cannot be changed. References-toconst become more important when you are dealing with objects because they can be large and making copies of them can have unwanted side effects. The following example shows how to pass an std::string to a function as a reference-to-const:

\begin{cpp}
import std;
using namespace std;
void printString(const string& myString) { println("{}", myString); }

int main()
{
    string someString { "Hello World" };
    printString(someString);
    printString("Hello World"); // Passing literals works.
}
\end{cpp}

\mySamllsection{Pass-by-Reference vs. Pass-by-Value}

Pass-by-reference is required when you want to modify the parameter and see those changes reflected in the variable passed to the function. However, you should not limit your use of pass-by-reference to only those cases. Pass-by-reference avoids copying the arguments to the function, providing two additional benefits:

\begin{itemize}
\item
Efficiency: Large objects could take a long time to copy. Pass-by-reference passes only a reference to the object into the function.

\item
Support: Not all classes allow pass-by-value.
\end{itemize}

If you want to leverage these benefits but do not want to allow the original objects to be modified, you should mark the parameters const, giving you pass-by-reference-to-const.

\begin{myNotic}{NOTE}
These benefits of pass-by-reference imply that you should use pass-by-value only for simple built-in types such as int and double for which you don’t need to modify the arguments. If you need to pass an object to a function, prefer to pass it by reference-to-const instead of by value. This prevents unnecessary copying. Pass it by reference-to-non-const if the function needs to modify the object. Chapter 9 slightly modifies this rule after the introduction of move semantics, allowing passby-value of objects in certain cases.
\end{myNotic}

\mySamllsection{Reference Return Values}

You can return a reference from a function. Of course, you can use this technique only if the variable to which the returned reference refers to continues to exist following the function termination.

\begin{myWarning}{WARNING}
From a function, never return a reference to a variable that is locally scoped to that function, such as an automatically allocated variable on the stack that will be destroyed when the function ends.
\end{myWarning}

One of the main reasons to return a reference is if you want to be able to assign to the return value directly as an lvalue (the left-hand side of an assignment statement). Several overloaded operators commonly return references, such as operators =, +=, and so on. Chapter 15 goes into more details on how to write such overloaded operators yourself.

Another reason to return a reference from a function is if the return type is expensive to copy. By returning a reference or reference-to-const, the copying is avoided, but keep the earlier warning in mind. This is often used to return objects by reference-to-const from class member functions, as demonstrated later in this chapter.

\mySamllsection{Deciding Between References and Pointers}

References in C++ could be considered redundant: everything you can do with references, you can accomplish with pointers. For example, you could write the earlier shown swap() function like this:

\begin{cpp}
void swap(int* first, int* second)
{
    int temp { *first };
    *first = *second;
    *second = temp;
}
\end{cpp}

However, this code is more cluttered than the version with references. References make your programs cleaner and easier to understand. They are also safer than pointers: it’s impossible to have a null reference, and you don’t explicitly dereference references, so you can’t encounter any of the dereferencing errors associated with pointers. Of course, these arguments about references being safer are valid only in the absence of any pointers. For example, take the following function that accepts a reference to an int:

\begin{cpp}
void refcall(int& t) { ++t; }
\end{cpp}

You could declare a pointer and initialize it to point to some random place in memory. Then you could dereference this pointer and pass it as the reference argument to refcall(), as in the following code. This code compiles fine, but it is undefined what will happen when executed. It could for example cause a crash.

\begin{cpp}
int* ptr { (int*)8 };
refcall(*ptr);
\end{cpp}

Most of the time, you can use references instead of pointers. References to objects also support polymorphism, discussed in detail in Chapter 10, in the same way as pointers to objects. However, there are some use cases in which you need to use a pointer. One example is when you need to change the location to which it points. Recall that you cannot change the variable to which a reference refers. For example, when you dynamically allocate memory, you need to store a pointer to the result in a pointer rather than a reference. A second use case in which you need to use a pointer is when the pointer is optional, that is, when it can be nullptr. Yet another use case is if you want to store polymorphic types (discussed in Chapter 10) in a container.

A long time ago, and in legacy code, a way to distinguish between appropriate use of pointers and references in parameters and return types was to consider who owns the memory. If the code receiving the variable became the owner and thus became responsible for releasing the memory associated with an object, it had to receive a pointer to the object. If the code receiving the variable didn’t have to free the memory, it received a reference. Nowadays, however, raw pointers should be avoided in favor of smart pointers (see Chapter 7), which is the recommended way to transfer ownership.

\begin{myNotic}{NOTE}
Prefer references over pointers; that is, use a pointer only if a reference is not possible.
\end{myNotic}

Consider a function that splits an array of ints into two arrays: one of even numbers and one of odd numbers. The function doesn’t know how many numbers in the source array will be even or odd, so it should dynamically allocate the memory for the destination arrays after examining the source array. It should also return the sizes of the two new arrays. Altogether, there are four items to return: pointers to the two new arrays and the sizes of the two new arrays. Obviously, you must use pass-by-reference. The canonical C way to write the function looks like this:

\begin{cpp}
void separateOddsAndEvens(const int arr[], size_t size, int** odds,
    size_t* numOdds, int** evens, size_t* numEvens)
{
    // Count the number of odds and evens.
    *numOdds = *numEvens = 0;
    for (size_t i = 0; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            ++(*numOdds);
        } else {
            ++(*numEvens);
        }
    }

    // Allocate two new arrays of the appropriate size.
    *odds = new int[*numOdds];
    *evens = new int[*numEvens];

    // Copy the odds and evens to the new arrays.
    size_t oddsPos = 0, evensPos = 0;
    for (size_t i = 0; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            (*odds)[oddsPos++] = arr[i];
        } else {
            (*evens)[evensPos++] = arr[i];
        }
    }
}
\end{cpp}

The final four parameters to the function are the “reference” parameters. To change the values to which they refer, separateOddsAndEvens() must dereference them, leading to some ugly syntax in the function body. Additionally, when you want to call separateOddsAndEvens(), you must pass the address of two pointers so that the function can change the actual pointers, and pass the address of two size\_ts so that the function can change the actual size\_ts. Note also that the caller is responsible for deleting the two arrays created by separateOddsAndEvens()!

\begin{cpp}
int unSplit[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int* oddNums { nullptr };
int* evenNums { nullptr };
size_t numOdds { 0 }, numEvens { 0 };

separateOddsAndEvens(unSplit, std::size(unSplit),
    &oddNums, &numOdds, &evenNums, &numEvens);

// Use the arrays...

delete[] oddNums; oddNums = nullptr;
delete[] evenNums; evenNums = nullptr;
\end{cpp}

If this syntax annoys you (which it should), you can write the same function by using references to obtain true pass-by-reference semantics:

\begin{cpp}
void separateOddsAndEvens(const int arr[], size_t size, int*& odds,
    size_t& numOdds, int*& evens, size_t& numEvens)
{
    numOdds = numEvens = 0;
    for (size_t i { 0 }; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            ++numOdds;
        } else {
            ++numEvens;
        }
    }

    odds = new int[numOdds];
    evens = new int[numEvens];

    size_t oddsPos { 0 }, evensPos { 0 };
    for (size_t i { 0 }; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            odds[oddsPos++] = arr[i];
        } else {
            evens[evensPos++] = arr[i];
        }
    }
}
\end{cpp}

In this case, the odds and evens parameters are references to int*s. separateOddsAndEvens() can modify the int*s that are used as arguments to the function (through the reference), without any explicit dereferencing. The same logic applies to numOdds and numEvens, which are references to size\_ts. With this version of the function, you no longer need to pass the addresses of the pointers or size\_ts; the reference parameters handle it for you automatically:

\begin{cpp}
separateOddsAndEvens(unSplit, std::size(unSplit),
    oddNums, numOdds, evenNums, numEvens);
\end{cpp}

Even though using reference parameters is already much cleaner than using pointers, it is recommended that you avoid dynamically allocated arrays as much as possible. For example, by using the Standard Library vector container, the separateOddsAndEvens() function can be rewritten to be much safer, shorter, more elegant, and much more readable, because all memory allocations and deallocations happen automatically.

\begin{cpp}
void separateOddsAndEvens(const vector<int>& arr,
    vector<int>& odds, vector<int>& evens)
{
    for (int i : arr) {
        if (i % 2 == 1) {
            odds.push_back(i);
        } else {
            evens.push_back(i);
        }
    }
}
\end{cpp}

This version can be used as follows:

\begin{cpp}
vector<int> vecUnSplit { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
vector<int> odds, evens;
separateOddsAndEvens(vecUnSplit, odds, evens);
\end{cpp}

Note that you don’t need to deallocate the odds and evens containers; the vector class takes care of this. This version is much easier to use than the versions using pointers or references.

The version using vectors is already much better than the versions using pointers or references, but as I recommended earlier, output parameters should be avoided as much as possible. If a function needs to return something, it should just return it instead of using output parameters! Since C++17, a compiler is not allowed to perform any copying or moving of objects for statements of the form return object; where object is a nameless temporary. This is called mandatory elision of copy/ move operations and means that there’s no performance penalty at all by returning object by value. If object is a local variable that is not a function parameter, non-mandatory elision of copy/move operations is allowed, an optimization also known as named return value optimization (NRVO). This optimization is not guaranteed by the standard. Some compilers perform this optimization only for release builds but not for debug builds. With mandatory and non-mandatory elision, compilers can avoid any copying of objects that are returned from functions. This results in zero-copy pass-by-value semantics. Note that for NRVO, even though the copy/move constructors won’t be called, they still need to be accessible; otherwise, the program is ill-formed according to the standard. Copy/move operations and constructors are discussed in Chapter 9, but those details are not important for the current discussion.

The following version of separateOddsAndEvens() returns a simple struct of two vectors, instead of accepting two output vectors as parameters, and uses designated initializers.

\begin{cpp}
struct OddsAndEvens { vector<int> odds, evens; };

OddsAndEvens separateOddsAndEvens(const vector<int>& arr)
{
    vector<int> odds, evens;
    for (int i : arr) {
        if (i % 2 == 1) {
            odds.push_back(i);
        } else {
            evens.push_back(i);
        }
    }
    return OddsAndEvens { .odds = odds, .evens = evens };
}
\end{cpp}

With these changes, the code to call separateOddsAndEvens() becomes compact yet easy to read and understand:

\begin{cpp}
vector<int> vecUnSplit { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
auto oddsAndEvens { separateOddsAndEvens(vecUnSplit) };
// Do something with oddsAndEvens.odds and oddsAndEvens.evens...
\end{cpp}

\begin{myNotic}{NOTE}
Avoid output parameters. If a function needs to return something, just return it by value.
\end{myNotic}

\mySubsubsection{1.1.29.}{const\_cast()}

In C++ every variable has a specific type. It is possible in certain situations to cast a variable of one type to a variable of another type. To that end, C++ provides five types of casts: const\_cast(), static\_cast(), reinterpret\_cast(), dynamic\_cast(), and std::bit\_cast(). This section discusses const\_cast(). The second type of cast, static\_cast(), is briefly introduced earlier in this chapter and discussed in more detail in Chapter 10. The other remaining casts are also discussed in Chapter 10.

const\_cast() is the most straightforward of the different casts available. You can use it to add const-ness to a variable or cast away const-ness of a variable. It is the only cast of the five that is allowed to cast away const-ness. Theoretically, of course, there should be no need for a const cast. If a variable is const, it should stay const. In practice, however, you sometimes find yourself in a situation where a function is specified to take a const parameter, which it must then pass to a function that takes a non-const parameter, and you are absolutely sure that the latter function will not modify its non-const argument. The “correct” solution would be to make const consistent in the program, but that is not always an option, especially if you are using third-party libraries. Thus, you sometimes need to cast away the const-ness of a variable, but again you should do this only when you are sure the function you are calling will not modify the object; otherwise, there is no other option than to restructure your program. Here is an example:

\begin{cpp}
void thirdPartyLibraryFunction(char* str);

void f(const char* str)
{
    thirdPartyLibraryFunction(const_cast<char*>(str));
}
\end{cpp}

Additionally, the Standard Library provides a helper function called std::as\_const(), defined in <utility>, which returns a reference-to-const of its reference parameter. Basically, as\_const(obj) is equivalent to const\_cast<const T\&>(obj), where T is the type of obj. Using as\_const() results in shorter and more readable code compared to using const\_cast(). Concrete use cases for as\_const() are coming later in this book, but its basic use is as follows:

\begin{cpp}
string str { "C++" };
const string& constStr { as_const(str) };
\end{cpp}

\mySubsubsection{1.1.30.}{Exceptions}

C++ is a flexible language, but it does allow you to do unsafe things. For example, the compiler will let you write code that scribbles on random memory addresses or tries to divide by zero (computers don’t deal well with infinity). One language feature that attempts to add a degree of safety is exceptions.

An exception is an exceptional situation, that is, a situation that you don’t expect or want in the normal flow of execution of a program. For example, if you are writing a function that retrieves a web page, several things could go wrong. The Internet host that contains the page might be down, the page might come back blank, or the connection could be lost. One way you could handle this situation is by returning a special value from the function, such as nullptr or an error code. Exceptions provide a much better mechanism for dealing with problems.

Exceptions come with some new terminology. When a piece of code detects an exceptional situation, it throws an exception. Another piece of code catches the exception and takes appropriate action. The following example shows a function, divideNumbers(), that throws an exception if the caller passes in a denominator of zero. The std::invalid\_argument exception is defined in <stdexcept>.

\begin{cpp}
double divideNumbers(double numerator, double denominator)
{
    if (denominator == 0) {
        throw invalid_argument { "Denominator cannot be 0." };
    }
    return numerator / denominator;
}
\end{cpp}

When the throw statement is executed, the function immediately ends without returning a value. If the caller surrounds the function call with a try/catch block, as shown in the following code, it receives the exception and is able to handle it. Chapter 14, “Handling Errors,” goes into much more detail on exception handling, but for now, just remember that it is recommended to catch exceptions by reference-to-const, such as const invalid\_argument\& in the following example. Also note that all Standard Library exception classes have a member function called what(), which returns a string containing a brief explanation of the exception.

\begin{cpp}
try {
    println("{}", divideNumbers(2.5, 0.5));
    println("{}", divideNumbers(2.3, 0));
    println("{}", divideNumbers(4.5, 2.5));
} catch (const invalid_argument& exception) {
    println("Exception caught: {}", exception.what());
}
\end{cpp}

The first call to divideNumbers() executes successfully, and the result is printed on the screen. The second call throws an exception. No value is returned, and the only output is the error message that is printed when the exception is caught. The third call is never executed because the second call throws an exception, causing the program to jump to the catch block. The output for the preceding code snippet is as follows:

\begin{shell}
5
Exception caught: Denominator cannot be 0.
\end{shell}

Exceptions can get tricky in C++. To use exceptions properly, you need to understand what happens to the stack variables when an exception is thrown, and you have to be careful to properly catch and handle the necessary exceptions. Also, if you need to include more information about an error in an exception, you can write your own exception types. Lastly, the C++ compiler doesn’t force you to catch every exception that might occur. If your code never catches any exceptions but an exception is thrown, the program will be terminated. These trickier aspects of exceptions are covered in detail in Chapter 14.

\mySubsubsection{1.1.31.}{Type Aliases}

A type alias provides a new name for an existing type declaration. You can think of a type alias as syntax for introducing a synonym for an existing type declaration without creating a new type. The following gives a new name, IntPtr, to the int* type declaration:

\begin{cpp}
using IntPtr = int*;
\end{cpp}

You can use the new type name and the definition it aliases interchangeably. For example, the following two lines are valid:

\begin{cpp}
int* p1;
IntPtr p2;
\end{cpp}

Variables created with the new type name are completely compatible with those created with the original type declaration. So, it is perfectly valid, given these definitions, to write the following, because they are not just compatible types; they are the same type:

\begin{cpp}
p1 = p2;
p2 = p1;
\end{cpp}

The most common use for type aliases is to provide manageable names when the real type declarations become too unwieldy. This situation commonly arises with templates. An example from the Standard Library itself is std::basic\_string<T> to represent strings. It’s a class template where T is the type of each character in the string, for example char. You have to specify the template type parameter any time you want to refer to such a type. For declaring variables, specifying function parameters, and so on, you would have to write basic\_string<char>:

\begin{cpp}
void processVector(const vector<basic_string<char>>& vec) { /* omitted */ }

int main()
{
    vector<basic_string<char>> myVector;
    processVector(myVector);
}
\end{cpp}

Since basic\_string<char> is used that frequently, the Standard Library provides the following type alias as a shorter, more meaningful name:

\begin{cpp}
using string = basic_string<char>;
\end{cpp}

With this type alias, the previous code snippet can be written more elegantly:

\begin{cpp}
void processVector(const vector<string>& vec) { /* omitted */ }

int main()
{
    vector<string> myVector;
    processVector(myVector);
}
\end{cpp}

\mySubsubsection{1.1.32.}{typedefs}

Type aliases were introduced in C++11. Before C++11, you had to use typedefs to accomplish something similar but in a more convoluted way. This old mechanism is still explained here because you will come across it in legacy code bases.

Just as a type alias, a typedef provides a new name for an existing type declaration. For example, take the following type alias:

\begin{cpp}
using IntPtr = int*;
\end{cpp}

This can be written as follows with a typedef:

\begin{cpp}
typedef int* IntPtr;
\end{cpp}

As you can see, it’s much less readable. The order is reversed, which causes a lot of confusion, even for professional C++ developers. Other than being more convoluted, a typedef behaves the same as a type alias. For example, the typedef can be used as follows:

\begin{cpp}
IntPtr p;
\end{cpp}

Type aliases and typedefs are not entirely equivalent, though. Compared to typedefs, type aliases are more powerful when used with templates, but that is a topic covered in Chapter 12 because it requires more details about templates.

\begin{myNotic}{NOTE}
Always prefer type aliases over typedefs.
\end{myNotic}

\mySubsubsection{1.1.33.}{Type Inference}

Type inference allows the compiler to automatically deduce the type of an expression. There are two keywords for type inference: auto and decltype.

\mySamllsection{The auto Keyword}

The auto keyword has a number of different uses:

\begin{itemize}
\item
To deduce a function’s return type, as explained earlier in this chapter

\item
To define structured bindings, as explained earlier in this chapter

\item
To deduce the type of an expression, as discussed in this section

\item
To deduce the type of non-type template parameters; see Chapter 12

\item
To define abbreviated function templates; see Chapter 12

\item
To use with decltype(auto); see Chapter 12

\item
To write functions using the alternative function syntax; see Chapter 12

\item
To write generic lambda expressions; see Chapter 19, “Function Pointers, Function Objects, and Lambda Expressions”
\end{itemize}

auto can be used to let the compiler automatically deduce the type of a variable at compile time. The following statement shows the simplest use of the auto keyword in that context:

\begin{cpp}
auto x { 123 }; // x is of type int.
\end{cpp}

In this example, you don’t win much by typing auto instead of int; however, it becomes useful for more complicated types. Suppose you have a function called getFoo() that has a complicated return type. If you want to assign the result of calling getFoo() to a variable, you can spell out the complicated type, or you can simply use auto and let the compiler figure it out:

\begin{cpp}
auto result { getFoo() };
\end{cpp}

This has the added benefit that you can easily change the function’s return type without having to update all the places in the code where that function is called.

\mySamllsection{The auto\& Syntax}

Using auto to deduce the type of an expression strips away reference and const qualifiers. Suppose you have the following:

\begin{cpp}
const string message { "Test" };
const string& foo() { return message; }
\end{cpp}

You can call foo() and store the result in a variable with the type specified as auto, as follows:

\begin{cpp}
auto f1 { foo() };
\end{cpp}

Because auto strips away reference and const qualifiers, f1 is of type string, and thus a copy is made! If you want a reference-to-const, you can explicitly make it a reference and mark it const, as follows:

\begin{cpp}
const auto& f2 { foo() };
\end{cpp}

Earlier in this chapter, the as\_const() utility function is introduced. It returns a reference-to-const version of its reference parameter. Be careful when using as\_const() in combination with auto. Since auto strips away reference and const qualifiers, the following result variable has type string, not const string\&, and hence a copy is made:

\begin{cpp}
string str { "C++" };
auto result { as_const(str) };
\end{cpp}

\begin{myWarning}{WARNING}
Always keep in mind that auto strips away reference and const qualifiers and thus creates a copy! If you do not want a copy, use auto\& or const auto\&.
\end{myWarning}

\mySamllsection{The auto* Syntax}

The auto keyword can also be used for pointers. Here’s an example:

\begin{cpp}
int i { 123 };
auto p { &i };
\end{cpp}

The type of p is int*. There is no danger here to accidentally make a copy, unlike when working with references as discussed in the previous section. However, when working with pointers, I do recommend using the auto* syntax as it more clearly states that pointers are involved, for example:

\begin{cpp}
auto* p { &i };
\end{cpp}

Additionally, using auto* versus just auto does resolve a strange behavior when using auto, const, and pointers together. Suppose you write the following:

\begin{cpp}
const auto p1 { &i };
\end{cpp}

Most of the time, this is not doing what you expect it to do!

Often, when you use const, you want to protect the thing to which the pointer is pointing to. You would think that p1 is of type const int*, but in fact, the type is int* const, so it’s a const pointer to a non-const integer! Putting the const after the auto as follows doesn’t help; the type is still int* const:

\begin{cpp}
auto const p2 { &i };
\end{cpp}

When you use auto* in combination with const, then it is behaving as you would expect. Here’s an example:

\begin{cpp}
const auto* p3 { &i };
\end{cpp}

Now p3 is of type const int*. If you really want a const pointer instead of a const integer, you put the const at the end:

\begin{cpp}
auto* const p4 { &i };
\end{cpp}

p4 has type int* const.

Finally, with this syntax you can make both the pointer and the integer constant:

\begin{cpp}
const auto* const p5 { &i };
\end{cpp}

p5 is of type const int* const. You cannot achieve this if you omit the *.

\mySamllsection{Copy List vs. Direct List Initialization}

There are two types of initializations that use braced initializer lists:

\begin{itemize}
\item
Copy list initialization: T obj = \{arg1, arg2, ...\};

\item
Direct list initialization: T obj \{arg1, arg2, ...\};
\end{itemize}

In combination with auto type deduction, there is an important difference between copy- and direct list initialization. Here is an example:

\begin{cpp}
// Copy list initialization
auto a = { 11 }; // initializer_list<int>
auto b = { 11, 22 }; // initializer_list<int>

// Direct list initialization
auto c { 11 }; // int
auto d { 11, 22 }; // Error, too many elements.
\end{cpp}

For copy list initialization, all the elements in the braced initializer must be of the same type. For example, the following does not compile:

\begin{cpp}
auto b = { 11, 22.33 }; // Compilation error
\end{cpp}

\mySamllsection{The decltype Keyword}

The decltype keyword takes an expression as argument and computes the type of that expression, as shown here:

\begin{cpp}
int x { 123 };
decltype(x) y { 456 };
\end{cpp}

In this example, the compiler deduces the type of y to be int because that is the type of x.

The difference between auto and decltype is that decltype does not strip reference and const qualifiers. Take, again, a function foo() returning a reference-to-const string. Defining f2 using decltype as follows results in f2 being of type const string\&, and thus no copy is made:

\begin{cpp}
decltype(foo()) f2 { foo() };
\end{cpp}

On first sight, decltype doesn’t seem to add much value. However, it is powerful in the context of templates, discussed in Chapters 12 and 26.

\mySubsubsection{1.1.34.}{The Standard Library}

C++ comes with a Standard Library, which contains a lot of useful classes that can readily be used in your code. The benefit of using these classes is that you don’t need to reinvent their functionality, and you don’t need to waste time on implementing things that have already been implemented for you. Another benefit is that the classes available in the Standard Library are heavily tested and verified for correctness by thousands of users. The Standard Library classes are also optimized for performance, so using them will most likely result in better performance compared to making your own implementation.

A lot of functionality is provided by the Standard Library. Chapters 16 to 24 provide more details; however, when you start working with C++, it is good to have an idea of what the Standard Library can do for you from the beginning. This is especially important if you are a C programmer. As a C programmer, you might try to solve problems in C++ the same way you would solve them in C, but in C++ there is probably an easier and safer solution to the problem that involves using Standard Library classes.

That is the reason why this chapter already introduces some Standard Library classes, such as std::string, array, vector, pair, and optional. These are used throughout examples in this book from the beginning, to make sure you get into the habit of using Standard Library classes. Many more classes are introduced in Chapters 16 to 24.






